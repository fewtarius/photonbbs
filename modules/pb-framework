#!/usr/bin/perl
#
#  Photon BBS Framework
#  (C) 2002-2013 Fewtarius

use Fcntl qw(:DEFAULT :flock);

sub doevents {
  $currenttime=time;
  $idletime=$currenttime-$idle;
  $idlenotifycheck=$config{'idledisconnect'}/2;
  if ($idletime >= $idlenotifycheck) {
    if ($idlenotified eq 0) {
      writeline($config{'errorcolor'}."\e[s\nWarning: Your session will be disconnected in ".$idlenotifycheck." seconds due to inactivity.\e[u");
      $idlenotified=1;
    }
  }
  if ($idletime >= $config{'idledisconnect'}) {
    errorout("idle session terminated.");
  }
  $cppid = getppid;
  if ($ppid != $cppid) {
    errorout("parent process died, terminating.");
  }
  if ($atmenu eq "1") {
    unless ($noevents eq "1") {
      getpages();
    }
  }
}

sub section_header {
    my ($label) = @_;
    use constant BORDER_LEN => 79;
    my $pad = int((BORDER_LEN - length($label) - 4) / 2);
    # ───┤ label ├─── using CP437 box drawing
    return (chr(196) x $pad) . chr(180) . " $label " . chr(195) . (chr(196) x ($pad + (BORDER_LEN - length($label) - 4) % 2));
}

sub section_footer {
    my $border = chr(196) x 79;
    return chr(192) . $border . chr(217);
}

sub usersonline {
  @userlst=<$config{'home'}$config{'nodes'}/*>;
  $sysinfo{'users'}=scalar(@userlst);
  if ($sysinfo{'users'} < 0) {
    $sysinfo{'users'}=0;
  }
  @userlst=();
}

sub whosonline {
  writeline($config{'themecolor'}."\nWho's Online".$config{'promptcolor'}.":",1);

  # Collect all node files
  my @whosonline = ();
  my @node_files = <$config{'home'}$config{'nodes'}/*>;

  foreach my $node_file (@node_files) {
    open(my $fh, "<", $node_file) or next;
    my $line = <$fh>;
    close($fh);
    chomp($line);

    # Parse the node file data
    my ($ip, $node, $pid, $time, $user, $proto, $location) = split(/\|/, $line);

    # Validate the data format
    next unless defined $ip && defined $node && defined $pid && defined $time && defined $user && defined $proto && defined $location;

    # Calculate idle time
    my $idle_time = int(time - $time);
    my $idle_display = $idle_time > 60 ? sprintf("%dm", $idle_time / 60) : sprintf("%ds", $idle_time);

    # Load user status
    my $status = "Avail"; # Shortened for 80 cols
    my $uid = finduserid($user);
    my $is_hidden = 0;
    if ($uid ne "") {
      my $user_file = "$config{'home'}$config{'data'}/users/$uid.dat";
      if (open(my $ufh, "<", $user_file)) {
        while (<$ufh>) {
          $status .= "/DND" if /^dnd=1/;
          if (/^hidden=Y/) {
            $status .= "/Inv";
            $is_hidden = 1;
          }
        }
        close($ufh);
      }
    }

    # Skip hidden users unless the current user has sec_sysop or higher
    if ($is_hidden == 1 && $info{'sec_level'} < $config{'sec_sysop'}) {
      next;
    }

    # Format the data for display
    push @whosonline, {
      node      => sprintf("%03d", $node),
      user      => $user,
      proto     => $proto,
      location  => $location,
      idle_time => $idle_display,
      status    => $status,
    };
  }

  # Sort by node number
  @whosonline = sort { $a->{node} <=> $b->{node} } @whosonline;

  # Display the header (widen Location to 32 chars for longer descriptions)
  writeline($config{'systemcolor'} . sprintf("%-4s %-10s %-7s %-32s %-5s %-10s", "Node", "User", "Via", "Location", "Idle", "Status"), 1);

  # Display each user's data (truncate fields as needed)
  foreach my $entry (@whosonline) {
    my $node      = $entry->{node};
    my $user      = substr($entry->{user}, 0, 10);
    my $proto     = substr($entry->{proto}, 0, 7);
    my $location  = substr($entry->{location}, 0, 32);
    my $idle_time = substr($entry->{idle_time}, 0, 5);
    my $status    = substr($entry->{status}, 0, 10);
    printf "%-4s %-10s %-7s %-32s %-5s %-10s\n",
      $node, $user, $proto, $location, $idle_time, $status;
  }

  # If no users are online, display a message
  if (scalar(@whosonline) == 0) {
    writeline($config{'systemcolor'}."No users are currently online.", 1);
  }

  writeline($RST."\n");
  unless ($_[0] =~ /nopause/) {
    pause();
  }
}

sub iamat {
  unless (-d "$config{'home'}$config{'nodes'}") {
    mkdir "$config{'home'}$config{'nodes'}";
  }
  unless ($info{'hidden'} eq "Y") {
    $who = $_[0];
  } else {
    $who = "*** HIDDEN ***";
  }
  $location = $_[1];
  $whofile = $config{'home'} . $config{'nodes'} . "/" . $info{'node'};
  lockfile("$whofile");
  open(who, ">$whofile");
  print who $sysinfo{'ip'} . "|" . $info{'node'} . "|" . $$ . "|" . time . "|" . $info{'handle'} . "|" . $info{'proto'} . "|" . $location;
  close(who);
  unlockfile("$whofile");
}


sub errorout {
  cbreak(off);
  logger ("ERROR".$config{'promptcolor'}.": ".$_[0]." ".$info{'handle'}." on node ".$info{'node'}." Exiting..");
  writeline ("\n".$config{'errorcolor'}."ERROR".$config{'promptcolor'}.": ".$config{'datacolor'}.$_[0]."\e[K\nExiting..\e[K\n",1);
  bye();
}

sub bye {
  if ($info{'handle'}) {}
  iamat($info{'handle'},"Logging off!");
  cbreak(off);
  writeline($theme{'goodbyemsg'}.$RST,1);
  if ($config{'nodupes'} eq 1) {
    if (-e "$config{'home'}$config{'data'}/iplist") {
      lockfile("$config{'home'}$config{'data'}/iplist");
      open (in,"<$config{'home'}$config{'data'}/iplist");
      lockfile("$config{'home'}$config{'data'}/iplist_");
      open (out,">$config{'home'}$config{'data'}/iplist_");
       while (<in>) {
        chomp $_;
        if ($_ =~/$info{'connect'}/i) {
          next;
        } else {
           print out $_."\n";
        }
      }
      close(out);
      unlockfile("$config{'home'}$config{'data'}/iplist_");
      close(in);
      unlockfile("$config{'home'}$config{'data'}/iplist");
      unlink ("$config{'home'}$config{'data'}/iplist");
      rename ("$config{'home'}$config{'data'}/iplist_","$config{'home'}$config{'data'}/iplist");
    }
  }

  if (-e "$config{'home'}$config{'messages'}/teleconf/TELEPUB_/$info{'node'}") {
    unlink("$config{'home'}$config{'messages'}/teleconf/TELEPUB_/$info{'node'}");
  }

  if ($info{'handle'}) {
    logger("NOTICE".$config{'promptcolor'}.": ".$info{'handle'}." Logged off!");
  }
  @list=`find $config{'home'} -name $info{'node'} -print`;
  foreach $item(@list) {
    chomp $item;
    system ("rm -rf $item 2>/dev/null");
  }

  if ( -e "$config{'doors'}/nodes/$info{'node'}") {
    system ("rm -rf $config{'doors'}/nodes/$info{'node'} 2>/dev/null");
  }

  # Only remove node file if it matches our PID
  my $nodefile = "$config{'home'}$config{'nodes'}/$info{'node'}";
  if (-e $nodefile) {
    open(my $fh, '<', $nodefile);
    my $line = <$fh>;
    close($fh);
    my (undef, undef, $npid, undef, undef, undef, undef) = split(/\|/, $line);
    if ($npid && $npid == $$) {
      unlink $nodefile;
    }
  }

  # Remove user's IP from iplist
  if ($config{'nodupes'} eq "1" && -e "$config{'home'}$config{'data'}/iplist") {
    lockfile("$config{'home'}$config{'data'}/iplist");
    open(my $in, "<", "$config{'home'}$config{'data'}/iplist");
    open(my $out, ">", "$config{'home'}$config{'data'}/iplist_");
    while (<$in>) {
      chomp;
      next if /$info{'connect'}/i; # Skip the user's IP
      print $out "$_\n";
    }
    close($in);
    close($out);
    unlockfile("$config{'home'}$config{'data'}/iplist");
    unlink("$config{'home'}$config{'data'}/iplist");
    rename("$config{'home'}$config{'data'}/iplist_", "$config{'home'}$config{'data'}/iplist");
  }

  kill getppid;
  exit(0);
}

sub colorize {
  if ($info{'ansi'} eq "1") {
    $CLR="\e[2J\e[0H";
    $RST="\e[0m";
    $BLK="\e[0;30m"; #BLACK
    $RED="\e[0;31m"; #RED
    $GRN="\e[0;32m"; #GREEN
    $YLW="\e[0;33m"; #YELLOW
    $BLU="\e[0;34m"; #BLUE
    $MAG="\e[0;35m"; #MAGENTA
    $CYN="\e[0;36m"; #WHITE
    $WHT="\e[0;37m"; #CYAN
    $BBK="\e[1;30m"; #GREY
    $BRD="\e[1;31m"; #BRIGHT RED
    $BGN="\e[1;32m"; #BRIGHT GREEN
    $BYL="\e[1;33m"; #BRIGHT YELLOW
    $BBL="\e[1;34m"; #BRIGHT BLUE
    $BMG="\e[1;35m"; #BRIGHT MAGENTA
    $BCN="\e[1;36m"; #BRIGHT CYAN
    $BWH="\e[1;37m"; #BRIGHT WHITE
  } else {
    $CLR="";
    $RST="";
    $BLK="";
    $RED="";
    $GRN="";
    $YLW="";
    $BLU="";
    $MAG="";
    $WHT="";
    $CYN="";
    $BBK="";
    $BRD="";
    $BGN="";
    $BYL="";
    $BBL="";
    $BMG="";
    $BCN="";
    $BWH="";
    print "";
  }
}

sub applytheme {
  $thmfile=$config{'home'}.$config{'themes'}."/".$_[0];
  if (-e $thmfile) {
    lockfile("$thmfile");
    open (atheme,"<$thmfile");
     @themein=<atheme>;
    close (atheme);
    unlockfile("$thmfile");
  } else {
    errorout ("Could not load theme file [".$thmfile."] , exiting..".$RST);
  }
  chomp ($ctime=`date +\%H:\%M`);
  chomp ($cdate=`date +\%Y-\%h-\%d`);
  $menu=lc($menuname);
  foreach (@themein) {
    ($key,$value) = split(/\=/);
    chomp $value;
    unless ($value eq "") {
      $$key = $value;
      $$key =~s/\@SYSTEMCLR/$config{'systemcolor'}/g;
      $$key =~s/\@USERCLR/$config{'usercolor'}/g;
      $$key =~s/\@INPUTCLR/$config{'inputcolor'}/g;
      $$key =~s/\@ERRORCLR/$config{'errorcolor'}/g;
      $$key =~s/\@THEMECLR/$config{'themecolor'}/g;
      $$key =~s/\@PROMPTCLR/$config{'promptcolor'}/g;
      $$key =~s/\@DATACLR/$config{'datacolor'}/g;
      $$key =~s/\@LINECLR/$config{'linecolor'}/g;
      $$key =~s/\@USRNM/$info{'username'}/g;
      $$key =~s/\@SYSNM/$config{'systemname'}/g;
      $$key =~s/\@MENU/$menu/g;
      $$key =~s/\@NODE/$info{'node'}/g;
      $$key =~s/\@CONNECT/$info{'connect'}/g;
      $$key =~s/\@USER/$info{'handle'}/g;
      $$key =~s/\@EMAIL/$info{'email'}/g;
      $$key =~s/\@TIME/$ctime/g;
      $$key =~s/\@DATE/$cdate/g;
      $$key =~s/\@TOTALCALLS/$config{'totcalls'}/g;
      $$key =~s/\@DEFAULT/$info{'defchan'}/g;
      $$key =~s/\@PROTO/$info{'proto'}/g;
      $$key =~s/\@BLK/$BLK/g;
      $$key =~s/\@RED/$RED/g;
      $$key =~s/\@GRN/$GRN/g;
      $$key =~s/\@YLW/$YLW/g;
      $$key =~s/\@BLU/$BLU/g;
      $$key =~s/\@MAG/$MAG/g;
      $$key =~s/\@WHT/$WHT/g;
      $$key =~s/\@CYN/$CYN/g;
      $$key =~s/\@BBK/$BBK/g;
      $$key =~s/\@BRD/$BRD/g;
      $$key =~s/\@BGN/$BGN/g;
      $$key =~s/\@BYL/$BYL/g;
      $$key =~s/\@BBL/$BBL/g;
      $$key =~s/\@BMG/$BMG/g;
      $$key =~s/\@BCN/$BCN/g;
      $$key =~s/\@BWH/$BWH/g;
      $$key =~s/\\n/\n/g; $$key =~s/\\t/\t/g; $$key =~ s/(\$\w+)/$1/eeg;
      $theme{$key}=$$key;
      $$key="";
    }
  }
}

sub lockfile {
  $tolock=$_[0];
  $lockwait=5;
  while (-e "$tolock.lock") {
    # If lockfile is stale (>60s), remove it
    if (-e "$tolock.lock" && (time - (stat("$tolock.lock"))[9]) > 60) {
      unlink("$tolock.lock");
      last;
    }
    --$lockwait;
    if ($lockwait eq 0) {
      last;
    }
    sleep 1;
  }
  if ($lockwait le 0) {
    logger("ERROR: $info{'handle'} forced unlock on $tolock");
    unlink("$tolock.lock");
  }
  open(out,">$tolock.lock");
    print out $info{'handle'};
  close(out);
  chmod 0777,"$tolock.lock";
}

sub unlockfile {
   $tolock=$_[0];
   unlink("$tolock.lock");
}

sub readconfig {
  $rfile=$config{'home'}.$config{'data'}."/".$_[0];
  lockfile("$rfile");
  open (config,"<$rfile");
  while (<config>) {
    $line=$_;
    chomp $line;
    unless ($line =~/^#/) {
      if ($line =~/#/i) {
        ($newline,$junk)=split(/#/,$line);
        while ($newline =~/\s$/) {
          chop $newline;
        }
        $line=$newline;
      }
      ($key,$value)=split(/=/,$line);
      $config{$key}=$value;
    }
  }
  close (config);
  unlockfile("$rfile");
}

sub cbreak {
  if ($_[0] eq "on") {
    if ($BSD_STYLE) {
      system "stty -echo cbreak <$mytty >$mytty 2>&1";
    } else {
      system "stty -echo raw opost <$mytty >$mytty 2>&1";
    }
  }
  if ($_[0] eq "off") {
    if ($BSD_STYLE) {
      system "stty echo -cbreak <$mytty >$mytty 2>&1";
    } else {
      system "stty echo -raw <$mytty >$mytty 2>&1";
    }
  }
}

sub waitkey {
  $idle=time;
  $idlenotified=0;
  $default=$_[0];
  $key="";
  cbreak(on);
  for (;;) {
    wastart: {
    eval {
      local $SIG{ALRM}=sub{$key="";doevents();goto wastart;};
      alarm 1;
      $key = "";
      $key=getc(STDIN);
      doevents();
      alarm 0;
    };
    };

    if ($key ne "") {
      unless ($key eq "\n") {
        writeline ($config{'inputcolor'}.$key);
      } else {
        $key=$default;
        writeline ($config{'inputcolor'}.$key);
      }
      last;
    } else {
      next;
    }
  }
  return $key;
}

sub writeline {
  $wrline=$_[0];
  $wrline =~s/\@RST/$RST/g;
  $wrline =~s/\@BLK/$BLK/g;
  $wrline =~s/\@RED/$RED/g;
  $wrline =~s/\@GRN/$GRN/g;
  $wrline =~s/\@YLW/$YLW/g;
  $wrline =~s/\@BLU/$BLU/g;
  $wrline =~s/\@MAG/$MAG/g;
  $wrline =~s/\@WHT/$WHT/g;
  $wrline =~s/\@CYN/$CYN/g;
  $wrline =~s/\@BBK/$BBK/g;
  $wrline =~s/\@BRD/$BRD/g;
  $wrline =~s/\@BGN/$BGN/g;
  $wrline =~s/\@BYL/$BYL/g;
  $wrline =~s/\@BBL/$BBL/g;
  $wrline =~s/\@BMG/$BMG/g;
  $wrline =~s/\@BCN/$BCN/g;
  $wrline =~s/\@BWH/$BWH/g;
  print $wrline . "\e[K";
  if ($_[1] eq "1") {
    print "\n";
  }
}

sub getline {
  $idle=time;
  $idlenotified=0;
  cbreak("on");
  $input{'type'}=$_[0];
  $input{'length'}=$_[1];
  $input{'text'}=$_[2];
  $result="";
  if ($_[3]) {
    $result=$input{'text'};
    for (1..$input{'length'}) {
      print "\e[0;47;0m ";   ### Add to theme file!
    }
    print "\e[".$input{'length'}."D";
  }
  writeline ($config{'inputcolor'}.$input{'text'});
  for (;;) {
    start: {
    eval {
      local $SIG{ALRM}=sub{$key="";doevents();goto start;};
      alarm 1;
      $key="";
      $key=getc(STDIN);
      doevents();
      alarm 0;
    };
    };
    if ($key =~/\n/ || $key =~/\r/) {
      chomp $result;
      $retmsg=$result;
      $result="";
      print $RST;
      unless ($retmsg ne "") {
        print $RST;
      }
      cbreak(off);
      if ($input{'type'} =~/chat/) {
        print "\e[80D\e[2K";
      } else {
        writeline("\n");
      }
      return ($retmsg);
    }
    # Enhanced backspace/delete logic
    if ($key =~/\c?/ || $key =~/\ch/) {
      if (length($result) > 0) {
        # Always delete just one character for DOB
        $result = substr($result, 0, -1);
        print "\e[1D \e[1D";
      }
      next;
    }
    if (ord($key) >= 32 && ord($key) <= 126) {
      if ($input{'type'} eq "dob") {
        $input{'length'}=10;
        # Only allow digits and slashes
        unless ($key =~ /[0-9\/]/) {
          $key = "";
          next;
        }
        # If user types a slash, only allow at positions 2 or 5
        if ($key eq "/") {
          unless (length($result) == 2 || length($result) == 5) {
            next;
          }
        }
        # If user types a digit, auto-insert slash after MM and DD if not present
        if ($key =~ /[0-9]/) {
          if ((length($result) == 2 || length($result) == 5) && substr($result, -1) ne "/") {
            $result .= "/";
            print "/";
          }
        }
      }
      if ($input{'type'} eq "phone") {
        $input{'length'}=14;
        unless ($key =~/[0-9]/) {
          $key="";
          next;
        }
        if (length($result) lt 1) {
          $key="(".$key;
        }
        if (length($result) eq 3) {
          $key=$key.")";
        }
        if (length($result) eq 4) {
          $key=")".$key;
        }
        if (length($result) eq 5) {
          $key=" ".$key;
        }
        if (length($result) eq 8) {
          $key=$key."-";
        }
        if (length($result) eq 9) {
          $key="-".$key;
        }
      }
      unless (length($result) == $input{'length'}) {
        unless ($input{'type'} =~/password/) {
          print $key;
        } elsif ($key ne "") {
          print $config{'passchr'};
        }
        $result = $result . $key;
        if ($input{'type'} =~/chat/) {
          if ($result eq "$config{'help'}") {
            $retmsg=$result;
            $result="";
            writeline("\n");
            return ($retmsg);
          }
        }
      }
    }
  }
}

sub colorline {
  $_[0] =~s/\@SYSTEMCLR/$config{'systemcolor'}/g;
  $_[0] =~s/\@USERCLR/$config{'usercolor'}/g;
  $_[0] =~s/\@INPUTCLR/$config{'inputcolor'}/g;
  $_[0] =~s/\@ERRORCLR/$config{'errorcolor'}/g;
  $_[0] =~s/\@THEMECLR/$config{'themecolor'}/g;
  $_[0] =~s/\@PROMPTCLR/$config{'promptcolor'}/g;
  $_[0] =~s/\@DATACLR/$config{'datacolor'}/g;
  $_[0] =~s/\@LINECLR/$config{'linecolor'}/g;
  $_[0] =~s/\@RST/$RST/g;
  $_[0] =~s/\@BLK/$BLK/g;
  $_[0] =~s/\@RED/$RED/g;
  $_[0] =~s/\@GRN/$GRN/g;
  $_[0] =~s/\@YLW/$YLW/g;
  $_[0] =~s/\@BLU/$BLU/g;
  $_[0] =~s/\@MAG/$MAG/g;
  $_[0] =~s/\@WHT/$WHT/g;
  $_[0] =~s/\@CYN/$CYN/g;
  $_[0] =~s/\@BBK/$BBK/g;
  $_[0] =~s/\@BRD/$BRD/g;
  $_[0] =~s/\@BGN/$BGN/g;
  $_[0] =~s/\@BYL/$BYL/g;
  $_[0] =~s/\@BBL/$BBL/g;
  $_[0] =~s/\@BMG/$BMG/g;
  $_[0] =~s/\@BCN/$BCN/g;
  $_[0] =~s/\@BWH/$BWH/g;
  return $_[0];
}

sub readfile {
  if ($_[2]) {
    $filename=$_[0];
  } else {
      $filename=$config{'home'}.$config{'text'}."/".$_[0];
  }
  $pause=$_[1];
  usersonline();
  lockfile("$filename") || errorout ("Unable to open $filename");
  open (file,"<$filename") || errorout ("Unable to open $filename");
  $linecount=1;
  $menu=lc($menuname);
  chomp ($ctime=`date +\%H:\%M`);
  chomp ($cdate=`date +\%Y-\%h-\%d`);
  while (<file>) {
    s/\@SYSTEMCLR/$config{'systemcolor'}/g;
    s/\@USERCLR/$config{'usercolor'}/g;
    s/\@INPUTCLR/$config{'inputcolor'}/g;
    s/\@ERRORCLR/$config{'errorcolor'}/g;
    s/\@THEMECLR/$config{'themecolor'}/g;
    s/\@PROMPTCLR/$config{'promptcolor'}/g;
    s/\@DATACLR/$config{'datacolor'}/g;
    s/\@LINECLR/$config{'linecolor'}/g;
    s/\@SYSNM/$config{'systemname'}/g;
    s/\@NODE/$info{'node'}/g;
    s/\@CONNECT/$info{'connect'}/g;
    s/\@HOST/$sysinfo{'host'}/g;
    s/\@IP/$sysinfo{'ip'}/g;
    s/\@USERS/$sysinfo{'users'}/g;
    s/\@TIME/$ctime/g;	s/\@DATE/$cdate/g;
    s/\@DEFAULT/$info{'defchan'}/g;
    s/\@PROTO/$info{'proto'}/g;
    s/\@USER/$info{'handle'}/g;
    s/\@RNAME/$info{'rname'}/g;
    s/\@DOB/$info{'dob'}/g;
    s/\@PHONE/$info{'phonenumber'}/g;
    s/\@LOCAL/$info{'location'}/g;
    s/\@CREDITS/$info{'credits'}/g;
    s/\@TLEFT/$info{'tlimit'}/g;
    s/\@ID/$info{'id'}/g;
    s/\@EMAIL/$info{'email'}/g;
    s/\@DND/$info{'dnd'}/g;
    s/\@BANNED/$info{'banned'}/g;
    s/\@CLR/$CLR/g;
    s/\@RST/$RST/g;
    s/\@BLK/$BLK/g;
    s/\@RED/$RED/g;
    s/\@GRN/$GRN/g;
    s/\@YLW/$YLW/g;
    s/\@BLU/$BLU/g;
    s/\@MAG/$MAG/g;
    s/\@WHT/$WHT/g;
    s/\@CYN/$CYN/g;
    s/\@BBK/$BBK/g;
    s/\@BRD/$BRD/g;
    s/\@BGN/$BGN/g;
    s/\@BYL/$BYL/g;
    s/\@BBL/$BBL/g;
    s/\@BMG/$BMG/g;
    s/\@BCN/$BCN/g;
    s/\@BWH/$BWH/g;
    s/~AT/\@/g;

    if ($info{'ansi'} eq 1) {
      $ansi="Y";
    } else {
      $ansi="N";
    }
    s/\@ANSI/$ansi/g;
    s/\\n/\n/g;
    s/\\t/\t/g;

    unless ($inteleconf eq 1) {
      print $_;
    } else {
      chomp $_;
      unless ($_ eq "") {
        print "\e[80D\e[2K".$_."\n";
        $gotapage="1";
      }
    }

    if ($inteleconf eq "1" && $gotapage eq "1") {
      writeline($RST.$config{'inputcolor'}.$config{'promptchr'}." ".$result);
    }

    unless ($pause eq "1") {
      ++$linecount;
      if ($linecount == $config{'rows'}) {
        unless ($wait eq "C") {
          $wait=pause();
        }
        if ($wait eq "Q") {
          last;
        }
        if ($wait eq "N") {
          $linecount=1;
        }
      }
    }
  }
  close (file);
  unlockfile("$filename") || errorout ("Unable to open $filename");
}

sub pause {
  writeline ($theme{'pause'}." ".$RST);
  $noevents=1;
  $key=waitkey();
  $noevents="";
  $key=uc($key);
  print "\e[2K\e[80D";
  unless ($key =~/C/ || $key =~/N/ || $key =~/Q/) {
    $key="N";
  }
  return $key;
}

sub hi {
  $ppid=getppid;

  # --- Use server-assigned node number from ARGV[2] ---
  my $nodeid = $ARGV[2];
  if (!$nodeid || $nodeid !~ /^\d+$/) {
    writeline("No node number provided by server, cannot continue.");
    logger("ERROR: No node number provided by server, disconnecting.");
    exit 1;
  }
  $info{'node'} = $nodeid;

  if ( $ARGV[1] =~ /sftp/i  || $ARGV[1] =~ /scp/i || $ARGV[1] =~ /exec/i ) {
    writeline("Attempt reported.",1);
    logger("ERROR: Connection attempt via SCP or SFTP from (@ARGV).");
    exit 0;
  }

  # Robust protocol/IP detection for all telnetd variants
  if ($ARGV[0] && $ARGV[1] && $ARGV[0] !~ /^-/) {
      # Standard: proto, connect
      $info{'proto'}   = $ARGV[0];
      $info{'connect'} = $ARGV[1];
  } elsif ($ARGV[1] && $ARGV[1] !~ /^-/) {
      # in.telnetd: proto, connect
      $info{'proto'}   = $ARGV[0] // "TELNET";
      $info{'connect'} = $ARGV[1];
  } elsif ($ARGV[2] && $ARGV[2] !~ /^-/) {
      # BSD/BusyBox: -h, connect, -p
      $info{'proto'}   = "TELNET";
      $info{'connect'} = $ARGV[2];
  } elsif ($ENV{'SSH_CLIENT'}) {
      @sshprts = split(/\ /, $ENV{'SSH_CLIENT'});
      $info{'connect'} = shift(@sshprts);
      $info{'proto'} = "SSH";
  } else {
      $info{'connect'} = $mtty;
      $info{'proto'} = "LOCAL";
  }

  $cli=join(' ',@ARGV);
  chomp ($cli);

  unless ($info{'connect'} =~/\w\.\w/i || $info{'connect'} =~/\w{4,32}/i) {
     writeline("Dont know who you are, can not continue.");
     logger ("ERROR: Can't find IP address for connection ($cli), disconnecting.");
     bye()
  }

  if ($config{'nodupes'} eq 1) {
    unless (-e "$config{'home'}$config{'data'}/iplist") {
      open (out,">$config{'home'}$config{'data'}/iplist");
       print out "UNKNOWNUSER\n";
      close(out);
    }
    # Always lock before reading or writing
    lockfile("$config{'home'}$config{'data'}/iplist");
    open (in,"<$config{'home'}$config{'data'}/iplist");
    my @lines = <in>;
    close(in);

    # Check for duplicates
    foreach my $line (@lines) {
      chomp $line;
      if ($line =~/$info{'connect'}/i) {
        writeline ($config{'systemcolor'}."\nIP ".$config{'usercolor'}.$info{'connect'}.$config{'systemcolor'}." is already logged on ..",1);
        ($kpid,$kip)=split(/:/,$line);
        logger("WARN: Duplicate IP ".$info{'connect'}." connected. Killing PID ".$kpid);
        kill 15,$kpid;
        unlockfile("$config{'home'}$config{'data'}/iplist");
        bye();
      }
    }

    # Add this session
    open (out,">>$config{'home'}$config{'data'}/iplist");
    print out getppid.":".$info{'connect'}."\n";
    close(out);
    unlockfile("$config{'home'}$config{'data'}/iplist");
  }

  cbreak(on);
  eval {
    if ( $config{'clearlogin'} eq "1" ) {
       print "\e[2J\e[0H";
    }
    if ($config{'headers'} eq 1) {
      @OPENING=split(//,"\nConnected to ".$config{'systemname'})
    }
    push (@OPENING,"\nAuto-sensing .");
    for (0..scalar(@OPENING)) {
     select(undef, undef, undef, 0.010);
     print shift(@OPENING);
    }

    local $SIG{ALRM} = sub {$response="\c[6c";next;};
    print "\e[c";
    alarm 1;
    while ($tchr=getc(STDIN)){
      $termmode=$termmode.getc(STDIN);
      if ($termmode =~/\cx/i) {
        $termmode="1c";
        last;
      } elsif ($termmode =~/[0-9]c/i) {
       last;
      }
    }
    alarm 0;
  };
  print ".";
  if ($termmode =~/[0-1]c/gi) {
    $info{'ext'}="asc";
    $info{'ansi'}="0";
  } else {
    $info{'ext'}="ans";
    $info{'ansi'}="1";
  }
  eval {
    alarm 1;
    local $SIG{ALRM} = sub {$tchr="c";next;};
    while ($tchr=$tchr.getc(STDIN)) {
      if ($tchr =~/c$/i) {
        break;
      }
    }
    alarm 0;
  };
  print ".";
  eval {
    alarm 1;
      local $SIG{ALRM} = sub {$tchr="";next;};
      while ($tchr=$tchr.getc(STDIN)) {
        last;
      }
    alarm 0;
  };
  print ".";
  chomp ($info{'tty'}=`tty | sed -e s#/##g -e s#[a-z]##g`);

  # Now that the node is reserved, write initial session info
  iamat("CONNECT", "Logging on");

  if (-e "$config{'home'}$config{'messages'}/$info{'node'}.page") {
    unlink("$config{'home'}$config{'messages'}/$info{'node'}.page");
  }

  if (-e "$config{'home'}$config{'data'}/banned_ip") {
    lockfile("$config{'home'}$config{'data'}/banned_ip");
    open (in,"<$config{'home'}$config{'data'}/banned_ip");
      while(<in>) {
        chomp $_;
          if ($info{'connect'} =~/$_/i) {
            writeline ($config{'systemcolor'}."\nHost ".$config{'usercolor'}.$info{'connect'}.$config{'systemcolor'}." has been ".$config{'errorcolor'}."banned".$config{'systemcolor'}.", terminating connection ..",1);
              logger("WARN: Banned User connected from".$config{'promptcolor'}.": ".$info{'connect'});
              close(in);
            unlockfile("$config{'home'}$config{'data'}/banned_ip");
            bye();
          }
      }
    close(in);
    unlockfile("$config{'home'}$config{'data'}/banned_ip");
  }

  if (-e "$config{'home'}/$config{'data'}/totalcalls") {
    lockfile("$config{'home'}/$config{'data'}/totalcalls");
    open (tcalls,"<$config{'home'}/$config{'data'}/totalcalls");
    $config{'totcalls'}=<tcalls>;
    chomp ($config{'totcalls'});
    close (tcalls);
    unlockfile("$config{'home'}/$config{'data'}/totalcalls");
  }
  ++$config{'totcalls'};
  lockfile("$config{'home'}/$config{'data'}/totalcalls");
  open (tcalls,">$config{'home'}/$config{'data'}/totalcalls");
   print tcalls $config{'totcalls'};
  close (tcalls);
  unlockfile("$config{'home'}/$config{'data'}/totalcalls");
}

sub logger {
  system ("logger -p $config{'facility'} -t \"$sysinfo{'servername'}\" \"$_[0]\"");
  if ( $config{'slackintegration'} eq "1" ) {
    if ( $config{'slackerrors'} eq "0" && "$_[0]" =~ /^ERR/ ) {
      return;
    }
    if ( $config{'slackwarnings'} eq "0" && "$_[0]" =~ /^WARN/ ) {
      return;
    }
    system ('curl -X POST --data-urlencode "payload={\"channel\": \"'.$config{'slackchannel'}.'\", \"username\": \"'.$config{'slackuser'}.'\", \"text\": \"'.$_[0].'\", \"icon_emoji\": \"'.$config{'slackemoji'}.'\"}" "https://hooks.slack.com/services/'.$config{'slackapipath'}.'" >/dev/null 2>&1');
  }
  # --- Discord Webhook Integration ---
  if ( $config{'discordintegration'} eq "1" && $config{'discordwebhook'} ne "" ) {
    if ( $config{'discorderrors'} eq "0" && "$_[0]" =~ /^ERR/ ) {
      return;
    }
    if ( $config{'discordwarnings'} eq "0" && "$_[0]" =~ /^WARN/ ) {
      return;
    }
    my $discord_payload = '{'.
      '"username": "'.$config{'discorduser'}.'",'.
      ($config{'discordavatar'} ne "" ? '"avatar_url": "'.$config{'discordavatar'}.'",' : '').
      '"content": "'.escape_discord($_[0]).'"'.
      '}';
    system('curl -H "Content-Type: application/json" -X POST -d \''.$discord_payload.'\' "'.$config{'discordwebhook'}.'" >/dev/null 2>&1');
  }
}

# Helper: Escape Discord special chars (basic)
sub escape_discord {
  my $msg = shift;
  $msg =~ s/"/\\"/g;
  $msg =~ s/\n/\\n/g;
  $msg =~ s/\r//g;
  return $msg;
}

sub bulletins {
  $bullidx=$config{'home'}.$config{'data'}."/bullidx.dat";
  if (-e $bullidx) {
    lockfile("$bullidx");
    open (in,"<$bullidx");
    @bulls=<in>;
    close (in);
  }
  unlockfile("$bullidx");
  if (scalar(@bulls) > "0") {
    writeline($config{'themecolor'}."Found ".$config{'datacolor'}.scalar(@bulls).$config{'themecolor'}." bulletin(s)!",1);
  } else {
    writeline($config{'systemcolor'}."No new bulletins are available today.",1);
    return;
  }
  if ($config{'bulletins'} eq 0) {
    return;
  }
  bullmenu();
}

sub bullmenu {
  bullmenu: {
    $inteleconf=0;
    writeline("\n");
    iamat($info{'handle'},"Bulletins Menu");
    $count=1;

    ###
    ### bulletins.xxx should contain the index
    ### if it doesn't exist, generate a menu
    ###

    $readit=0;
    if (-e "$config{'home'}$config{'text'}/bulletins.$info{'ext'}") {
      readfile("welcome.$info{'ext'}");
      $readit=1;
    }
    if (-e "$config{'home'}$config{'text'}/bulletins.txt" && $readit ne "1") {
      readfile("welcome.txt");
      $readit=1;
    }

    if ($readit ne "1") {
      writeline("$theme{'bulltop'}\n",1);
    }

    $bullidx=$config{'home'}.$config{'data'}."/bullidx.dat";
    lockfile("$bullidx");
    open (in,"<$bullidx");
    @bulls=<in>;
    close (in);
    unlockfile("$bullidx");

    unless($readit eq 1) {
      for (0..scalar(@bulls)) {
        $bulln=$_+1;
        chomp ($bulls[$_]);
        ($bullid,$bulltext)=split(/\|/,$bulls[$_]);
        if ($bulltext ne "") {
          writeline($config{'datacolor'}.$bulln.$config{'usercolor'}." ...".$config{'themecolor'}." ".$bulltext,1);
        }
      }
    }

    writeline($config{'themecolor'}."\nEnter Option, or \"".$config{'datacolor'}."Q".$config{'themecolor'}."\" to quit".$config{'promptcolor'}.": ");
    $result=getline(text,,1);
    unless ($result =~/^[Qq]$/ || $result eq "") {
      iamat($info{'handle'},"Reading a bulletin");
      $result=$result-1;
      if ($result lt 0) {
        $result=0;
      }
      chomp ($bulls[$_]);
      ($bullid,$bulltext)=split(/\|/,$bulls[$result]);
      if (-e "$config{'home'}/$config{'text'}/$bullid") {
        writeline("\n");
        readfile($bullid);
        goto bullmenu;
      }
    }
    writeline("\n");
  }
  $inteleconf=1;
}

# Add a function to enumerate active sessions/nodes for external tools
sub list_sessions {
  my @sessions;
  my $nodes_dir = $config{'home'}.$config{'nodes'};
  opendir(my $dh, $nodes_dir) or return ();
  while (my $node = readdir($dh)) {
    next if $node =~ /^\./;
    my $file = "$nodes_dir/$node";
    next unless -f $file;
    open(my $fh, '<', $file) or next;
    my $line = <$fh>;
    close($fh);
    chomp $line;
    # $line format: ip|node|pid|time|user|proto|location
    my ($ip, $nodeid, $pid, $time, $user, $proto, $location) = split(/\|/, $line);
    push @sessions, {
      ip       => $ip,
      node     => $nodeid,
      pid      => $pid,
      time     => $time,
      user     => $user,
      proto    => $proto,
      location => $location,
      file     => $file,
    };
  }
  closedir($dh);
  return @sessions;
}

return 1;
