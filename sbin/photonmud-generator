#!/usr/bin/perl
# PhotonMUD Map Generator
# Version 1.0
#
# This script generates a complete realm map for PhotonMUD, including:
# - Varied terrain (mountains, lakes, rivers, forests, hills, swamps)
# - Towns and castles with interior layouts
# - Cave systems and dungeons
# - Connected road networks
# - Monster placement and treasure distribution
# - Market system with shops and traders
#
# Usage: photonmud-generator [options]
#   --biome-balance=TYPE    Set terrain balance (default|lush|arid)
#   --mountain-pct=N        Mountain coverage percentage (default 20)
#   --lake-pct=N           Lake coverage percentage (default 4)
#   --river-pct=N          River coverage percentage (default 2)
#   --town-pct=N           Town coverage percentage (default 0.07)
#   --castle-pct=N         Castle coverage percentage (default 0.02)
#
# Created as part of the PhotonBBS suite
# https://github.com/fewtarius/photonbbs
#############################################################################

print "\n";
print "PhotonMUD Map Generator\n";
print "Copyright (c) 2025 Fewtarius\n";
print "\n";

use strict;
use warnings;
use List::Util qw(min max);
use Math::Trig qw(pi);
use Fcntl qw(SEEK_SET);
use POSIX qw(ceil);
use Carp qw(cluck confess);
use List::Util qw(min max);
use Math::Trig qw(pi);
use Getopt::Long;

my @map;
my $tiles = [];
my $castles = [];

my $biome_balance = 'default';
my $mountain_pct;
my $lake_pct;
my $river_pct;
my $town_pct;
my $castle_pct;

my %treasure_held_by_monsters;
my %treasure_placed_in_realm;
my @seller_types;

GetOptions(
    "biome-balance=s" => \$biome_balance,
    "mountain-pct=f"  => \$mountain_pct,
    "lake-pct=f"      => \$lake_pct,
    "river-pct=f"     => \$river_pct,
    "town-pct=f"      => \$town_pct,
    "castle-pct=f"    => \$castle_pct,
) or die "Usage: $0 [--biome-balance=default|lush|arid] [--mountain-pct=20] [--lake-pct=4] [--river-pct=2] [--town-pct=0.07] [--castle-pct=0.02]\n";

$SIG{__WARN__} = sub {
    my $msg = shift;
    if ($msg =~ /uninitialized value.*in addition.*line 681/) {
        confess("DEBUG: $msg");
    } else {
        warn $msg;
    }
};

our %config;
sub require_module {
    my ($mod) = @_;
    my $sys_path = "/opt/photonbbs/modules/$mod";
    my $local_path = "./modules/$mod";
    if (-e $sys_path) {
        require $sys_path;
    } elsif (-e $local_path) {
        require $local_path;
    } else {
        die "Cannot find required module $mod in /opt/photonbbs/modules or ./modules";
    }
}

require_module("pb-defaults");
require_module("pm-defaults");
require_module("pm-cache");      # Must be before pm-objects (provides data_cache_get)
require_module("pm-objects");

sub titlecase {
    my ($str) = @_;
   
    $str = lc($str);
   
    $str =~ s/(\b\w)/\U$1/g;
   
    $str =~ s/([A-Za-z])'S(\b)/$1's$2/g;
   
    $str =~ s/([A-Za-z])’S(\b)/$1’s$2/g;
    return $str;
}

sub load_data_file {
    my ($file, $arrayref, $by_name) = @_;
    open(my $fh, "<", $file) or die "Can't open $file: $!";
    my %rec;
    while (<$fh>) {
        chomp;
        if (/^Record\s+\d+:/) {
            %rec = ();
        } elsif (/^Parsed fields/) {
            push @$arrayref, { %rec };
            $by_name->{$rec{name}} = $#$arrayref if $rec{name};
        } elsif (/^\s+(\w+)\s+:\s*(.*)$/) {
            $rec{$1} = $2;
        }
    }
    close $fh;
}

sub read_object_record {
    my ($objnum) = @_;
    my $file = "$config{'home'}/$config{'data'}/objects.dat";
    my $reclen = 256;

    open(my $fh, "<:raw", $file) or do {
        return {};
    };

    seek($fh, ($objnum - 1) * ($reclen + 4), SEEK_SET);
    read($fh, my $buf, $reclen);
    close($fh);

   
    if ($buf =~ /^\0+$/) {
        return {};
    }

   
    my $offset = 0;
    if (substr($buf, 0, 2) eq "\0\0" && substr($buf, 2, 1) =~ /[ -~]/) {
        $offset = 2;
    }

    my %obj;
    $obj{name}        = substr($buf,   $offset + 0, 30); $obj{name}        =~ s/[\0 ]+$//;
    $obj{shortname}   = substr($buf,  $offset + 30, 30); $obj{shortname}   =~ s/[\0 ]+$//;
    $obj{roomlink}    = unpack("f<", substr($buf, $offset + 60, 4));
    $obj{invisible}   = unpack("s",  substr($buf, $offset + 64, 2));
    $obj{jailtrap}    = unpack("s",  substr($buf, $offset + 66, 2));
    $obj{doorlock}    = unpack("s",  substr($buf, $offset + 68, 2));
    $obj{destination} = unpack("s",  substr($buf, $offset + 70, 2));
    $obj{permanent}   = unpack("s",  substr($buf, $offset + 72, 2));
    $obj{hidden}      = unpack("s",  substr($buf, $offset + 74, 2));
    $obj{closed}      = unpack("s",  substr($buf, $offset + 76, 2));
    $obj{keyed}       = unpack("s",  substr($buf, $offset + 78, 2));
    $obj{relocks}     = unpack("s",  substr($buf, $offset + 80, 2));
    $obj{longdesc}    = substr($buf, $offset + 82, 80);  $obj{longdesc}    =~ s/[\0 ]+$//;
    $obj{fromhour}    = unpack("s",  substr($buf, $offset + 162, 2));
    $obj{frommin}     = unpack("s",  substr($buf, $offset + 164, 2));
    $obj{tohour}      = unpack("s",  substr($buf, $offset + 166, 2));
    $obj{tomin}       = unpack("s",  substr($buf, $offset + 168, 2));
    $obj{lightroom}   = unpack("s",  substr($buf, $offset + 170, 2));
    $obj{lighttime}   = unpack("s",  substr($buf, $offset + 172, 2));
    $obj{shortdesc}   = substr($buf, $offset + 174, 80); $obj{shortdesc}   =~ s/[\0 ]+$//;
    $obj{teleport}    = unpack("f<", substr($buf, $offset + 252, 4));
    $obj{trap}        = unpack("s",  substr($buf, $offset + 254, 2));

    return \%obj;
}

sub read_treasure_record {
    my ($treasnum) = @_;
    my $file = "$config{'home'}/$config{'data'}/treasure.dat";
    my $reclen = 140;

    open(my $fh, "<:raw", $file) or do { return {}; };
    seek($fh, ($treasnum - 1) * $reclen, SEEK_SET);
    my $buf = '';
    my $read = read($fh, $buf, $reclen);
    close($fh);

   
    return {} if !$read || length($buf) < $reclen || $buf =~ /^\0+$/;

   
    my $offset = 0;
    if (substr($buf, 0, 2) eq "\0\0" && substr($buf, 2, 1) =~ /[ -~]/) {
        $offset = 2;
    }

    my %treas;
    $treas{name}        = substr($buf,   $offset + 0, 30);  $treas{name}      =~ s/[\0 ]+$//;
    $treas{shortname}   = substr($buf,  $offset + 30, 30);  $treas{shortname} =~ s/[\0 ]+$//;
    $treas{weight}      = unpack("s", substr($buf, $offset + 60, 2));
    $treas{gold}        = unpack("s", substr($buf, $offset + 62, 2));
    $treas{spell}       = unpack("s", substr($buf, $offset + 64, 2));
    $treas{plus}        = unpack("s", substr($buf, $offset + 66, 2));
    $treas{coin}        = unpack("s", substr($buf, $offset + 68, 2));
    $treas{keyed}       = unpack("s", substr($buf, $offset + 70, 2));
    $treas{scroll}      = unpack("s", substr($buf, $offset + 72, 2));
    $treas{charges}     = unpack("s", substr($buf, $offset + 74, 2));
    $treas{potion}      = unpack("s", substr($buf, $offset + 76, 2));
    $treas{armor}       = unpack("s", substr($buf, $offset + 78, 2));
    $treas{shield}      = unpack("s", substr($buf, $offset + 80, 2));
    $treas{weapon}      = unpack("s", substr($buf, $offset + 82, 2));
    $treas{container}   = unpack("s", substr($buf, $offset + 84, 2));
    $treas{type}        = unpack("s", substr($buf, $offset + 86, 2));
    $treas{locked}      = unpack("s", substr($buf, $offset + 88, 2));
    $treas{closed}      = unpack("s", substr($buf, $offset + 90, 2));
    $treas{loadable}    = unpack("s", substr($buf, $offset + 92, 2));
    $treas{ammunition}  = unpack("s", substr($buf, $offset + 94, 2));
    $treas{ammoloads}   = unpack("s", substr($buf, $offset + 96, 2));
    $treas{invisible}   = unpack("s", substr($buf, $offset + 98, 2));
    $treas{permanent}   = unpack("s", substr($buf, $offset +100, 2));
    $treas{proficiency} = unpack("s", substr($buf, $offset +102, 2));
    $treas{ringtype}    = unpack("s", substr($buf, $offset +104, 2));
    $treas{ringspell}   = unpack("s", substr($buf, $offset +106, 2));
    $treas{edible}      = unpack("s", substr($buf, $offset +108, 2));
    $treas{rustable}    = unpack("s", substr($buf, $offset +110, 2));
    $treas{rustpercent} = unpack("s", substr($buf, $offset +112, 2));
    $treas{stealable}   = unpack("s", substr($buf, $offset +114, 2));
    $treas{stealpercent}= unpack("s", substr($buf, $offset +116, 2));
    $treas{launchable}  = unpack("s", substr($buf, $offset +118, 2));
    $treas{launchloads} = unpack("s", substr($buf, $offset +120, 2));
    $treas{launchammo}  = unpack("s", substr($buf, $offset +122, 2));
    $treas{movable}     = unpack("s", substr($buf, $offset +124, 2));
    $treas{vehicle}     = unpack("s", substr($buf, $offset +126, 2));
    $treas{vehiclehits} = unpack("s", substr($buf, $offset +128, 2));
    $treas{vehicletype} = unpack("s", substr($buf, $offset +130, 2));
    $treas{lighttype}   = unpack("s", substr($buf, $offset +132, 2));
    $treas{lightcharges}= unpack("s", substr($buf, $offset +134, 2));
    $treas{fueltype}    = unpack("s", substr($buf, $offset +136, 2));
    $treas{fuelcharges} = unpack("s", substr($buf, $offset +138, 2));
    return \%treas;
}

sub read_monster_record {
    my ($monnum) = @_;
    my $file = "$config{'home'}/$config{'data'}/monsters.dat";
    my $reclen = 180;  # Changed from 144 to 180
    my %mon;
    open(my $fh, "<:raw", $file) or return {};
    seek($fh, ($monnum - 1) * $reclen, SEEK_SET);
    my $buf = '';
    my $read = read($fh, $buf, $reclen);
    close($fh);

    # Return {} if !$read || length($buf) < $reclen || $buf =~ /^\0+$/;
    return {} if !$read || length($buf) < $reclen || $buf =~ /^\0+$/;

    $mon{name}        = substr($buf, 0, 30);  $mon{name}        =~ s/[\0 ]+$//;
    $mon{plural}      = substr($buf, 30, 30); $mon{plural}      =~ s/[\0 ]+$//;
    $mon{treasure}    = substr($buf, 60, 10); $mon{treasure}    =~ s/[\0 ]+$//;
    $mon{exp}         = unpack("d", substr($buf, 70, 8));
    $mon{gold}        = unpack("d", substr($buf, 78, 8));
    $mon{number}      = unpack("s", substr($buf, 86, 2));
    $mon{level}       = unpack("s", substr($buf, 88, 2));
    $mon{hits}        = unpack("s", substr($buf, 90, 2));
    $mon{poison}      = unpack("s", substr($buf, 92, 2));
    $mon{leveldrain}  = unpack("s", substr($buf, 94, 2));
    $mon{spell}       = unpack("s", substr($buf, 96, 2));
    $mon{block}       = unpack("s", substr($buf, 98, 2));
    $mon{prevent}     = unpack("s", substr($buf,100, 2));
    $mon{follow}      = unpack("s", substr($buf,102, 2));
    $mon{magic}       = unpack("s", substr($buf,104, 2));
    $mon{jail}        = unpack("s", substr($buf,106, 2));
    $mon{teleport}    = unpack("f<", substr($buf,108, 4));
    $mon{follow_percent}  = unpack("s", substr($buf,112, 2));
    $mon{block_percent}   = unpack("s", substr($buf,114, 2));
    $mon{prevent_percent} = unpack("s", substr($buf,116, 2));
    $mon{spell_percent}   = unpack("s", substr($buf,118, 2));
    $mon{poison_percent}  = unpack("s", substr($buf,120, 2));
    $mon{drain_percent}   = unpack("s", substr($buf,122, 2));
    $mon{rate}        = unpack("s", substr($buf,124, 2));
    $mon{rate_percent}= unpack("s", substr($buf,126, 2));
    $mon{permanent}   = unpack("s", substr($buf,128, 2));
    $mon{talk}        = substr($buf,130, 10); $mon{talk}        =~ s/[\0 ]+$//;
    $mon{psionic}     = unpack("s", substr($buf,140, 2));
    $mon{psionic_spell}=unpack("s", substr($buf,142, 2));
    $mon{region}      = substr($buf,144, 16); $mon{region}      =~ s/[\0 ]+$//;
    $mon{behaviors}   = substr($buf,160, 20); $mon{behaviors}   =~ s/[\0 ]+$//;  # Added this line
    return \%mon;
}

my @objects;
my %object_by_name;
{
    my $i = 1;
    while (1) {
        my $obj = read_object_record($i);
        last unless $obj && $obj->{name};
        push @objects, $obj;
        $object_by_name{$obj->{name}} = $#objects;
        $i++;
    }
}

my @treasures;
my %treasure_by_name;
{
    my $i = 1;
    while (1) {
        my $treas = read_treasure_record($i);
        last unless $treas && $treas->{name};
        push @treasures, $treas;
        $treasure_by_name{$treas->{name}} = $#treasures;
        $i++;
    }
}

my @monsters;
my %monster_by_name;
{
    my $i = 1;
    while (1) {
        my $mon = read_monster_record($i);
        last unless $mon && $mon->{name};
        push @monsters, $mon;
        $monster_by_name{$mon->{name}} = $#monsters;
        $i++;
    }
}

my @npcs;
my %npc_by_name;
{
    my $file = "$config{'home'}/$config{'data'}/nonplyrs.dat";
    my $reclen = 144;
    my $i = 1;
    open(my $fh, "<:raw", $file) or die "Can't open $file: $!";
    while (1) {
        my $buf = '';
        my $read = read($fh, $buf, $reclen);
        last unless $read && length($buf) == $reclen;
        my %npc;
        $npc{name}        = substr($buf, 0, 30);  $npc{name}        =~ s/[\0 ]+$//;
        $npc{plural}      = substr($buf, 30, 30); $npc{plural}      =~ s/[\0 ]+$//;
        $npc{treasure}    = substr($buf, 60, 10); $npc{treasure}    =~ s/[\0 ]+$//;
        $npc{exp}         = unpack("d", substr($buf, 70, 8));
        $npc{gold}        = unpack("d", substr($buf, 78, 8));
        $npc{number}      = unpack("s", substr($buf, 86, 2));
        $npc{level}       = unpack("s", substr($buf, 88, 2));
        $npc{hits}        = unpack("s", substr($buf, 90, 2));
        $npc{poison}      = unpack("s", substr($buf, 92, 2));
        $npc{leveldrain}  = unpack("s", substr($buf, 94, 2));
        $npc{spell}       = unpack("s", substr($buf, 96, 2));
        $npc{block}       = unpack("s", substr($buf, 98, 2));
        $npc{prevent}     = unpack("s", substr($buf,100, 2));
        $npc{follow}      = unpack("s", substr($buf,102, 2));
        $npc{magic}       = unpack("s", substr($buf,104, 2));
        $npc{jail}        = unpack("s", substr($buf,106, 2));
        $npc{teleport}    = unpack("f<", substr($buf,108, 4));
        $npc{follow_percent}  = unpack("s", substr($buf,112, 2));
        $npc{block_percent}   = unpack("s", substr($buf,114, 2));
        $npc{prevent_percent} = unpack("s", substr($buf,116, 2));
        $npc{spell_percent}   = unpack("s", substr($buf,118, 2));
        $npc{poison_percent}  = unpack("s", substr($buf,120, 2));
        $npc{drain_percent}   = unpack("s", substr($buf,122, 2));
        $npc{rate}        = unpack("s", substr($buf,124, 2));
        $npc{rate_percent}= unpack("s", substr($buf,126, 2));
        $npc{permanent}   = unpack("s", substr($buf,128, 2));
        $npc{talk}        = substr($buf,130, 10); $npc{talk}        =~ s/[\0 ]+$//;
        $npc{psionic}     = unpack("s", substr($buf,140, 2));
        $npc{psionic_spell}=unpack("s", substr($buf,142, 2));
        push @npcs, \%npc;
        $npc_by_name{$npc{name}} = $#npcs;
        $i++;
    }
    close($fh);
}

my @DIRS = qw(N S E W NE SE SW NW UP DOWN IN OUT);

my @river_dirs = (
    [0, 1, 1.0],    # N
    [1, 0, 1.0],    # E
    [0, -1, 1.0],   # S
    [-1, 0, 1.0],   # W
    [1, 1, 1.4],    # NE
    [1, -1, 1.4],   # SE
    [-1, 1, 1.4],   # SW
    [-1, -1, 1.4]   # NW
);

my $WIDTH  = $config{'width'};
my $HEIGHT = $config{'height'};
my $ELEV_SEED  = defined $config{'elev_seed'}  ? $config{'elev_seed'}  : rand(10000);
my $BIOME_SEED = defined $config{'biome_seed'} ? $config{'biome_seed'} : rand(10000);
my @mountain_clusters;
my @lake_clusters;
my @towns;
my @castles;
my @centers;

my %rooms;
my @room_keys;
my $next_idx = 1 + $WIDTH * $HEIGHT;
my %castle_name_map;

my %elevation;
my %biome;

my @town_names = qw(
    Oakvale Greendale Mistwood Redbrook Silverford
    Goldcrest Ironhill Willowmere Stormwatch Sunspire
    Frostholm Ravenmoor Briar Glen
    Winterhold Riverwood Falkreath Whiterun Solitude
    Bree Edoras Dale Rohan Gondor
    Camelot Tintagel Avalon Nottingham York
    Canterbury Oxford Chester Warwick Durham
    Bruges Ghent Antwerp Lyon Avignon
    Prague Vienna Salzburg Innsbruck Lucerne
    Rothenburg Heidelberg Bamberg Tallinn Riga
    Dubrovnik Split Kotor Brasov Sibiu
    Sighisoara Carcassonne Toledo Segovia Granada
    Siena Volterra SanGimignano Arezzo Lucca
);

my @castle_names = qw(
    Blackstone Stormkeep Dawnspire Ironhold Frostgate
    Highclere Neuschwanstein Windsor Alnwick Warwick
    Edinburgh Stirling Bamburgh EileanDonan
    Hohenzollern Bran Peles Corvinus
    Kilkenny Blarney Leeds Arundel
    Caernarfon Conwy Harlech Dover
    Bodiam Hever Chillon Peleș
    Alcazar Himeji Matsumoto Kronborg
    Trakai Malbork Mir Nesvizh
    Lichtenstein BurgEltz Houska Predjama
);

my @house_names = (
    "The Silver Lantern", "The Gilded Hearth", "The Whispering Pines", "The Mossy Nook", "The Old Willow",
    "The Dancing Fox", "The Bluebell Cottage", "The Starlit Porch", "The Amber Hearth", "The Crooked Chimney",
    "The Lanternlight House", "The Ivy Gate", "The Rosewood Door", "The Sunbeam Cottage", "The Thistle Den",
    "The Maple Eaves", "The Hearthstone", "The Quiet Burrow", "The Lark's Nest", "The Painted Shutters",
    "The Mossy Roof", "The Saffron Window", "The Wren's Hollow", "The Fern Cottage", "The Oakshade",
    "The Lantern House", "The Misty Porch", "The Blue Door", "The Old Mill House", "The Sparrow's Rest",
    "The Honeycomb", "The Pebble Path", "The Hearthfire", "The Willowshade", "The Foxglove House",
    "The Lantern's End", "The Mossy Steps", "The Briar Patch", "The Sunflower House", "The Whispering Door",
    "The Rowan House", "The Fernshade", "The Lily Pad", "The Hearthside", "The Lantern's Glow",
    "The Ivy Cottage", "The Mossy Gate", "The Painted Hearth", "The Old Oak", "The Lantern's Watch",
    "The Bluebell Gate", "The Starlit Hearth", "The Amber Door", "The Crooked Path", "The Lantern's Rest",
    "The Ivy Hearth", "The Rose Cottage", "The Sunlit Porch", "The Thistle House", "The Maple Hearth",
    "The Hearth Hollow", "The Quiet Hearth", "The Lark's Gate", "The Painted Porch", "The Mossy Hearth",
    "The Saffron Hearth", "The Wren's Rest", "The Fern Rest", "The Oak Rest", "The Lantern Rest",
    "The Misty Rest", "The Blue Rest", "The Old Rest", "The Sparrow's Rest", "The Honey Rest",
    "The Pebble Rest", "The Willow Rest", "The Foxglove Rest", "The Lantern's Hearth End", "The Mossy End",
    "The Briar End", "The Sunflower End", "The Whispering End", "The Rowan End", "The Ferny End",
    "The Lily End", "The Hearthside End", "The Lantern's Glow End", "The Ivy End", "The Moss End",
    "The Painted End", "The Old End", "The Lantern's Watch End", "The Bluebell End", "The Starlit End",
    "The Amber End", "The Crooked End", "The Lantern's Rest End", "The Ivy Rest End", "The Rose Rest End",
    "The Sunlit Rest End", "The Thistle Rest End", "The Maple Rest End", "The Hearth Rest End",
    "The Quiet Rest End", "The Lark's Rest End", "The Painted Rest End", "The Mossy Rest End",
    "The Saffron Rest End", "The Wren's Rest End", "The Fern Rest End", "The Oak Rest End",
    "The Lantern Rest End", "The Misty Rest End", "The Blue Rest End", "The Old Rest End",
    "The Sparrow's Rest End", "The Honey Rest End", "The Pebble Rest End", "The Willow Rest End",
    "The Foxglove Rest End",
);

my @mountain_names = (
    "The Misty Mountains", "The Ironspine", "The Frostpeaks", "The Dragonteeth", "The Stormcrags",
    "The Shadow Range", "The Silver Heights", "The Thunder Peaks", "The Blackridge", "The Sunspire Mountains",
    "The Ember Range", "The Howling Cliffs", "The Crystal Mountains", "The Bloodfangs", "The Moonspire",
    "The Shrouded Peaks", "The Granite Wall", "The Skyreach", "The Wolffangs", "The Starspire",
    "The Dreadspire", "The Cloudwall", "The Firepeaks", "The Deepcrags", "The Whitecaps",
    "The Broken Teeth", "The Windspire", "The Gloomridge", "The Highspire", "The Ironwall",
    "The Frostwall", "The Ashen Peaks", "The Sable Range", "The Pale Mountains", "The Stormwall",
    "The Nightspire", "The Dawnspire", "The Wildspire", "The Greycliffs", "The Redridge",
    "The Winterspire", "The Goldspire", "The Stonewall", "The Blue Ridge", "The Thunderwall",
    "The Lost Peaks", "The Watcher's Range", "The Spine of the World", "The Sleeping Giants", "The Old Bones"
);

my @lake_names = (
    "Lake Silvermere", "Lake Moonshadow", "Lake Starfall", "Lake Deepwater", "Lake Crystal",
    "Lake Frostveil", "Lake Dreaming", "Lake Willowmere", "Lake Sunfire", "Lake Mistveil",
    "Lake Shadowmere", "Lake Goldleaf", "Lake Bluebell", "Lake Whisper", "Lake Emberdeep",
    "Lake Ravenwing", "Lake Windrush", "Lake Brightwater", "Lake Nightfall", "Lake Stormwatch",
    "Lake Wolfwater", "Lake Foxglove", "Lake Swan", "Lake Sable", "Lake Larkspur",
    "Lake Thorn", "Lake Rose", "Lake Fern", "Lake Lily", "Lake Rowan",
    "Lake Briar", "Lake Sunflower", "Lake Lantern", "Lake Ivy", "Lake Pebble",
    "Lake Honey", "Lake Sparrow", "Lake Maple", "Lake Hearth", "Lake Lanternlight",
    "Lake Crocus", "Lake Blueglass", "Lake Dusk", "Lake Dawn", "Lake Whispering",
    "Lake Lantern's Rest", "Lake Painted", "Lake Mossy", "Lake Old Oak", "Lake Crooked"
);

# Add this near your other name arrays:

my @river_names = (
    "Anduin", "Bruinen", "Sirion", "Isen", "Baranduin", "Celduin", "Gwathló", "Lune", "Gelion", "Adurant",
    "Aros", "Mindeb", "Teiglin", "Narog", "Brandywine", "Silverlode", "Snowbourn", "Entwash", "Withywindle",
    "Morthond", "Greyflood", "Limlight", "Celebrant", "Glanduin", "Poros", "Erui", "Gilrain", "Ringló",
    "Celon", "Ascar", "Rivil", "Serni", "Harnen", "Rhun", "Rhovanion", "Sundering", "Esgalduin", "Nenning",
    "Aldor", "Aelin-uial", "Ivrin", "Taeglin", "Rathlóriel", "Rill", "Mistyflow", "Starwater", "Moonbrook",
    "Shadowmere", "Frostwater", "Dragonwash", "Elfspring", "Wyrmflow", "Sunriver", "Nightbrook", "Stormrun",
    "Duskwater", "Brightstream", "Thornriver", "Goldrun", "Ironflow", "Crystalbrook", "Deepmere", "Wolfwater",
    "Willowrun", "Foxstream", "Ravenwash", "Mistbrook", "Dreamflow", "Starfall", "Glittering River", "Duskmere",
    "Silverstream", "Firebrook", "Windrush", "Eaglewater", "Moonshadow", "Dewriver", "Starshine", "Feyrun",
    "Shadowrun", "Sunbrook", "Froststream", "Dragonmere", "Elvenflow", "Wyrmwater", "Sunshine River", "Nightstream",
    "Stormbrook", "Duskstream", "Brightwater", "Thornbrook", "Goldwater", "Ironbrook", "Crystalstream", "Deepwater",
    "Wolfstream", "Willowbrook", "Foxwater", "Ravenstream", "Miststream", "Dreambrook", "Starwater", "Glitterbrook"
);

# Add this near your other name arrays:
my @villager_names = (
    "Aelric", "Bran", "Cedric", "Darian", "Eldric", "Frodo", "Galen", "Hob", "Isolde", "Jareth",
    "Kael", "Lira", "Mira", "Nessa", "Orin", "Perrin", "Quinn", "Rowan", "Sable", "Tamsin",
    "Ulric", "Vara", "Willow", "Xander", "Ysolde", "Zane", "Bryn", "Cora", "Della", "Ewan",
    "Finn", "Gwyn", "Hilda", "Ivor", "Joss", "Kira", "Lyle", "Moss", "Nell", "Orrin",
    "Pip", "Rhea", "Soren", "Tilda", "Una", "Viggo", "Wren", "Yara", "Zara", "Bram",
    "Elora", "Fira", "Garrick", "Hollis", "Ilya", "Juna", "Kestrel", "Linden", "Mira", "Nash",
    "Oona", "Pax", "Riven", "Sorrel", "Thane", "Uri", "Vesper", "Wynn", "Yorick", "Zephyr",
    "Arian", "Balin", "Caspian", "Doran", "Eira", "Faelan", "Gareth", "Hal", "Inara", "Jorah",
    "Kellan", "Leif", "Mirael", "Niall", "Orla", "Perris", "Quilla", "Ronan", "Selene", "Tarin",
    "Ulani", "Varek", "Willa", "Xanthe", "Yorun", "Zarek", "Balinor", "Celandine", "Darian", "Eldan",
    "Firael", "Galenor", "Hester", "Ilona", "Jorunn", "Kestrel", "Lorien", "Merrin", "Nimue", "Orrick"
);

my @villager_titles = (
    "the Bard", "the Farmer", "the Miller", "the Potter", "the Weaver", "the Fletcher", "the Shepherd",
    "the Fisher", "the Tinker", "the Tailor", "the Baker", "the Brewer", "the Mason", "the Carpenter",
    "the Scribe", "the Herbalist", "the Hunter", "the Minstrel", "the Cobbler", "the Gardener",
    "the Cook", "the Candle Maker", "the Spinner", "the Cooper", "the Tanner", "the Smith", "the Dyer",
    "the Beekeeper", "the Stablemaster", "the Woodcutter", "the Watchman", "the Piper", "the Storyteller"
);

my @realm_cores = (
    "Barrowlands", "Shadowvale", "Frostmarch", "Starwood", "Moonspire", "Sunreach",
    "Bloodfen", "Dragonmere", "Wolfpine", "Ravenmoor", "Oakenshade", "Ashenhold",
    "Obsidian Peaks", "Emerald Glade", "Sable Downs", "Ivory Bastion", "Azure Isles",
    "Scarlet Fen", "Gloomhollow", "Thundercrag", "Wildgrove", "Winterdeep", "Summerfield",
    "Autumnwood", "Springvale", "Celestial Heights", "Mystic Hollow", "Arcane Wilds",
    "Grimwood", "Silent Vale", "Sacred Grove", "Cinderfall", "Mistlands", "Nightreach",
    "Brightwater", "Dreadhills", "Wyrmspire", "Eaglecrest", "Lion's Gate", "Serpent's Run",
    "Stonebarrow", "Fireplain", "Icereach", "Windmere", "Valebrook", "Stormwatch",
    "Sunspire", "Moonshadow", "Starfall", "Ironwood", "Goldleaf", "Silverpine",
    "Bluehollow", "Redridge", "Greenfen", "Blackmoor", "Whitepeak", "Duskmire",
    "Dawnglade", "Shadowfen", "Frostvale", "Stormvale", "Dragonspire", "Wolfden",
    "Ravenwing", "Oakheart", "Ashvale", "Obsidian Vale", "Emerald Vale", "Sable Vale",
    "Ivory Vale", "Azure Vale", "Scarlet Vale", "Gloom Vale", "Thunder Vale", "Wild Vale",
    "Winter Vale", "Summer Vale", "Autumn Vale", "Spring Vale", "Celestial Vale",
    "Mystic Vale", "Arcane Vale", "Grim Vale", "Silent Vale", "Sacred Vale", "Cinder Vale",
    "Mist Vale", "Night Vale", "Bright Vale", "Dread Vale", "Wyrm Vale", "Eagle Vale",
    "Lion Vale", "Serpent Vale", "Stone Vale", "Fire Vale", "Ice Vale", "Wind Vale",
    "Barrow Vale", "Fenlands", "Hollowlands", "Deepwoods", "Highlands",
    "Shrouded Peaks", "Haunted Marsh", "Crystal Expanse", "Sunken Wilds", "Twilight Glens",
    "Moonlit Forest", "Starless Depths", "Dragon's Spine", "Witchwood", "Feywild",
    "Elderwood", "Runebarrow", "Frosthold", "Stormhold", "Ironhold", "Goldspire",
    "Silverhold", "Shadowhold", "Sunhold", "Moonhold", "Starhold", "Dreadhold",
    "Bloodspire", "Frostspire", "Stormspire", "Nightspire", "Dawnspire", "Duskspire",
    "Ironspire", "Ashspire", "Obsidian Spire", "Crystal Spire", "Starspire", "Wolfspire",
    "Dragonhold", "Wyrmhold", "Ravenhold", "Lionhold", "Serpenthold", "Eaglehold",
    "Shadowkeep", "Sunkeep", "Moonkeep", "Stormkeep", "Frostkeep", "Firekeep",
    "Goldkeep", "Silverkeep", "Ivorykeep", "Emeraldkeep", "Sablekeep", "Cinderkeep",
    "Mistkeep", "Dreadkeep", "Grimhold", "Brightspire", "Starhold", "Moonwatch",
    "Sunwatch", "Stormwatch", "Frostwatch", "Ironwatch", "Dreadwatch", "Shadowwatch",
    "Dragonwatch", "Wolfwatch", "Ravenwatch", "Lionwatch", "Serpentwatch", "Eaglewatch",
    "Crystalhold", "Obsidianhold", "Ashenhold", "Cinderhold", "Nightwatch", "Dawnwatch",
    "Duskhold", "Twilight Hold", "Twilight Spire", "Twilight Bastion", "Sunfire Bastion",
    "Frostfire Bastion", "Starfire Bastion", "Moonfire Bastion", "Stormfire Bastion",
    "Goldbastion", "Silverbastion", "Ironbastion", "Obsidian Bastion", "Crystal Bastion",
    "Dragon Bastion", "Wyrm Bastion", "Raven Bastion", "Wolf Bastion", "Lion Bastion",
    "Serpent Bastion", "Eagle Bastion", "Shadow Bastion", "Dread Bastion", "Grim Bastion",
    "Bright Bastion", "Mist Bastion", "Cinder Bastion", "Ash Bastion", "Ivory Bastion",
    "Emerald Bastion", "Sable Bastion", "Sun Bastion", "Moon Bastion", "Star Bastion",
    "Storm Bastion", "Frost Bastion", "Fire Bastion", "Ice Bastion", "Wind Bastion",
    "Barrow Bastion", "Fen Bastion", "Hollow Bastion", "Deep Bastion", "High Bastion",
    "Shrouded Bastion", "Haunted Bastion", "Crystal Bastion", "Sunken Bastion",
    "Twilight Bastion", "Moonlit Bastion", "Starless Bastion", "Dragon's Bastion",
    "Witch Bastion", "Fey Bastion", "Elder Bastion", "Rune Bastion",
);

my @realm_prefixes = (
    "", "The Realm of ", "The Kingdom of ", "The Land of ", "The Domain of "
);

my %treasure_categories = (
    'weapon' => [grep { $_->{weapon} > 0 } @treasures],
    'armor'  => [grep { $_->{armor} > 0 || $_->{shield} > 0 } @treasures],
    'magic'  => [grep { $_->{spell} > 0 || $_->{potion} > 0 || $_->{scroll} > 0 } @treasures],
    'general' => [grep { $_->{weapon} == 0 && $_->{armor} == 0 && $_->{shield} == 0 && 
                        $_->{spell} == 0 && $_->{potion} == 0 && $_->{scroll} == 0 } @treasures],
);

# Categorize by value tier
my %treasure_tiers = (
    'common'    => [grep { $_->{gold} <= 50 } @treasures],
    'uncommon'  => [grep { $_->{gold} > 50 && $_->{gold} <= 200 } @treasures],
    'rare'      => [grep { $_->{gold} > 200 && $_->{gold} <= 1000 } @treasures],
    'epic'      => [grep { $_->{gold} > 1000 && $_->{gold} <= 5000 } @treasures],
    'legendary' => [grep { $_->{gold} > 5000 } @treasures],
);

my @cave_entrance_keys;
my @dungeon_entrance_keys;

# Calculate total area
my $TOTAL_AREA = $WIDTH * $HEIGHT;

# Mountain area: up to 20% of the map (default)
my $mountain_area = int($TOTAL_AREA * (($mountain_pct // 20) / 100));
my $mountain_clusters_count = int($TOTAL_AREA / 1200);
$mountain_clusters_count = 4 if $mountain_clusters_count < 4;

# Lake area: up to 4% of the map (default)
my $lake_area = int($TOTAL_AREA * (($lake_pct // 4) / 100));
my $lake_clusters_count = int($TOTAL_AREA / 2000);
$lake_clusters_count = 6 if $lake_clusters_count < 6;

# Rivers: up to 10% of the map (default)
my $river_count = defined $river_pct
    ? int($TOTAL_AREA * ($river_pct / 100) / 150)
    : int($TOTAL_AREA / 2500);
$river_count = 4 if $river_count < 4;

# Towns: 1 per 1500 tiles (default ~0.07%)
my $town_count = defined $town_pct
    ? int($TOTAL_AREA * ($town_pct / 100))
    : int($TOTAL_AREA / 1500);
$town_count = 2 if $town_count < 2;
$town_count = 10 if $town_count > 10;

# Castles: about 1 per 5000 tiles (default ~0.02%)
my $castle_density = $castle_pct ? int($TOTAL_AREA / ($TOTAL_AREA * ($castle_pct / 100))) : 5000;
my $base_castle_count = defined $castle_pct
    ? int($TOTAL_AREA * ($castle_pct / 100))
    : int($TOTAL_AREA / $castle_density + 0.5);

# Add a random variation: ±1 for small/medium maps, ±2 for very large maps
my $variation = ($TOTAL_AREA > 100_000) ? 2 : 1;
my $castle_count = $base_castle_count + int(rand(2 * $variation + 1)) - $variation;
$castle_count = 2 if $castle_count < 2;
$castle_count = 15 if $castle_count > 15;

# Clamp to minimum and maximum
$castle_count = 2 if $castle_count < 2;
$castle_count = 15 if $castle_count > 15;

my $base_min = 1;
my $base_max = 3;

my $base_grid = $config{'width'} * $config{'height'};;
my $mult = sqrt($TOTAL_AREA / $base_grid);
$mult = 1 if $mult < 1;

my $cave_count = int(1 + 1.2 * $mult);     
$cave_count = 1 if $cave_count < 1;
$cave_count = 3 if $cave_count > 3;

my $dungeon_count = int(1 + 1.2 * $mult);  
$dungeon_count = 1 if $dungeon_count < 1;
$dungeon_count = 3 if $dungeon_count > 3;

my $mountain_rooms = 0;
my $castles_placed = 0;
my $lake_rooms = 0;
my $caves_placed = 0;
my $dungeons_placed = 0;

my @shuffled_castle_names = @castle_names;
@shuffled_castle_names = sort { rand() <=> rand() } @shuffled_castle_names;

my @shuffled_town_names = @town_names;
@shuffled_town_names = sort { rand() <=> rand() } @shuffled_town_names;
my %town_name_map;

my %biome_presets = (
    default => {
        forest_chance => 0.65,
        hill_chance   => 0.3,
        swamp_chance  => 0.25,
        patch_min     => 15,
        patch_max     => 80,
    },
    lush => {
        forest_chance => 0.9,
        hill_chance   => 0.5,
        swamp_chance  => 0.7,
        patch_min     => 20,
        patch_max     => 100,
    },
    arid => {
        forest_chance => 0.5,
        hill_chance   => 0.8,
        swamp_chance  => 0.2,
        patch_min     => 10,
        patch_max     => 50,
    },
);

my %BIOME_TYPES = (
    'mountain' => {
        elevation_min => 0.6,
        humidity     => 0.3,
        temperature  => 0.2,
        vegetation   => 0.1
    },
    'forest' => {
        elevation_min => -0.2,
        elevation_max => 0.6,
        humidity     => 0.7,
        temperature  => 0.5,
        vegetation   => 0.9
    },
    'grass' => {
        elevation_min => -0.3,
        elevation_max => 0.4,
        humidity     => 0.5,
        temperature  => 0.6,
        vegetation   => 0.6
    },
    'hill' => {
        elevation_min => 0.1,
        elevation_max => 0.5,
        humidity     => 0.4,
        temperature  => 0.5,
        vegetation   => 0.4
    },
    'swamp' => {
        elevation_min => -0.4,
        elevation_max => 0.0,
        humidity     => 0.9,
        temperature  => 0.6,
        vegetation   => 0.7
    },
    'lake' => {
        elevation_max => -0.3,
        humidity     => 1.0,
        temperature  => 0.5,
        vegetation   => 0.2
    }
);

die "Unknown biome balance '$biome_balance'. Valid: " . join(", ", keys %biome_presets) . "\n"
    unless exists $biome_presets{$biome_balance};

# Hash function for consistent randomization
our $HASH_PRIME = 2654435761;
our $mod_prime = 4294967291;  # Largest 32-bit prime

print "Generating realm with settings:\n";
print "  Biome Balance: $biome_balance\n";
print "  Mountain Coverage: ", ($mountain_pct // 20), "%\n";
print "  Lake Coverage: ", ($lake_pct // 4), "%\n";
print "  River Density: ", ($river_pct // 2), "%\n";
print "  Town Density: ", ($town_pct // 0.07), "%\n";
print "  Castle Density: ", ($castle_pct // 0.02), "%\n\n";

sub generate_realm_name {
    my $core = $realm_cores[int(rand(@realm_cores))];
    my $prefix = (rand() < 0.15) ? $realm_prefixes[int(rand(@realm_prefixes))] : "";
    
    # Remove any extra spaces
    $prefix =~ s/\s+$//;
    $core =~ s/^\s+//;
    
    return $prefix ? "$prefix $core" : $core;  # Single space between prefix and core
}

sub add_shop_inventory {
    my ($shop_name, $shop_type, $count) = @_;
    
    # Determine shop specialization
    my $specialization = '';
    if ($shop_type =~ /Armory|Blacksmith/i) {
        $specialization = 'weapon';
    } elsif ($shop_type =~ /Tailor|Clothier/i) {
        $specialization = 'armor';
    } elsif ($shop_type =~ /Magic|Potion|Spell/i) {
        $specialization = 'magic';
    } else {
        $specialization = 'general';
    }
    
    # Prepare categorized treasures
    my @weapons = grep { $_->{weapon} > 0 } @treasures;
    my @armors = grep { $_->{armor} > 0 || $_->{shield} > 0 } @treasures;
    my @magic_items = grep { $_->{spell} > 0 || $_->{potion} > 0 || $_->{scroll} > 0 } @treasures;
    my @general_items = grep { 
        $_->{weapon} == 0 && $_->{armor} == 0 && $_->{shield} == 0 && 
        $_->{spell} == 0 && $_->{potion} == 0 && $_->{scroll} == 0 
    } @treasures;
    
    # Get the right category based on specialization
    my @primary_items;
    if ($specialization eq 'weapon') {
        @primary_items = @weapons;
    } elsif ($specialization eq 'armor') {
        @primary_items = @armors;
    } elsif ($specialization eq 'magic') {
        @primary_items = @magic_items;
    } else {
        @primary_items = @general_items;
    }
    
    # Fallback if primary category is empty
    @primary_items = @treasures unless @primary_items;
    
    my %used_items;
    my $added = 0;
    
    # Add specialized items (70% of inventory)
    my $primary_count = int($count * 0.7);
    for (1..$primary_count) {
        # Skip if we've reached our target
        last if $added >= $count;
        
        # Try to find an unused item
        my $attempts = 0;
        my $item;
        do {
            my $shop_idx = int(rand(@primary_items));
            $item = $primary_items[$shop_idx];
            $attempts++;
            
            # Skip if it's used or held by monsters
            next if $used_items{$item->{name}};
            next if $treasure_held_by_monsters{find_treasure_index_by_name($item->{name})};
            
            # Calculate a reasonable price (always positive)
            my $base_price = $item->{gold} > 0 ? $item->{gold} : 20;
            my $markup = 1.0 + (rand(0.5));  # 100-150% of base price
            my $price = int($base_price * $markup);
            $price = max(1, $price);  # Ensure positive price
            
            my $charges = $item->{charges} > 0 ? $item->{charges} : 1;
            
            # Find the index
            $shop_idx = find_treasure_index_by_name($item->{name});
            if ($shop_idx > 0) {
                add_market_listing($item->{name}, $shop_name, $price, 2, $shop_idx, $charges);
                $used_items{$item->{name}} = 1;
                $added++;
            }
        } while ($attempts < 15 && $added < $count);
    }
    
    # Add regular objects (30% of inventory) - NOW WITH PERMANENT CHECK
    my $object_count = $count - $added;
    for (1..$object_count) {
        my $attempts = 0;
        my $added_object = 0;
        
        while ($attempts < 15 && !$added_object) {
            my $oidx = int(rand(@objects));
            my $o = $objects[$oidx];
            $attempts++;
            
            # Skip if already used
            next if $used_items{"obj_".$o->{name}};
            
            # Skip if permanent
            next if $o->{permanent} && $o->{permanent} != 0;
            
            # Set a reasonable price for objects
            my $price = 25 + int(rand(75));
            
            # Debug this part - make sure object indices are correct
            print STDERR "Adding object: $o->{name}, idx: ".($oidx+1)."\n" if $ENV{DEBUG};
            
            # Add the object to market with extra check
            if ($o->{name} && length($o->{name}) > 0) {
                add_market_listing($o->{name}, $shop_name, $price, 1, $oidx+1, 1);
                $used_items{"obj_".$o->{name}} = 1;
                $added_object = 1;
                $added++;
            }
        }
    }
    
    return $added;
}

sub generate_black_market_items {
    my ($max_items) = @_;
    
    # Get suitable rare/valuable items
    my @valuable_items = grep { $_->{gold} >= 100 } @treasures;
    return 0 unless @valuable_items;
    
    # Find appropriate locations
    my @black_market_locations;
    for my $room (values %rooms) {
        my $feature = $room->{feature} // '';
        my $region  = $room->{region}  // '';
        
        if (($region eq "Castle" && $feature =~ /Keep|Vault/) ||
            ($region eq "Dungeon" && $feature eq "DungeonVault") ||
            ($region eq "Cave" && $feature eq "CaveLake")) {
            push @black_market_locations, $room;
        }
    }
    
    return 0 unless @black_market_locations;
    
    my %used_items;
    my $items_added = 0;
    
    for (1..$max_items) {
        last if $items_added >= $max_items;
        
        # Select random location
        my $location = $black_market_locations[int(rand(@black_market_locations))];
        my $region = $location->{region} // '';
        
        # Create seller name
        my $seller_prefix = $region eq "Castle" ? 
                          ($location->{castle_name} // "Castle") :
                          ($region eq "Dungeon" ? "Dungeon" : "Cave");
        
        @seller_types = (
            "Fence", "Smuggler", "Trader", "Merchant", "Dealer"
        );
        my $seller_type = $seller_types[int(rand(@seller_types))];
        my $seller_name = "$seller_prefix $seller_type";
        
        # Try to find an unused valuable item
        my $attempts = 0;
        my $item_added = 0;
        
        while ($attempts < 15 && !$item_added) {
            my $blackmarket_idx = int(rand(@valuable_items));
            my $item = $valuable_items[$blackmarket_idx];
            $attempts++;
            
            # Skip if used or held by monsters
            next if $used_items{$item->{name}};
            next if $treasure_held_by_monsters{find_treasure_index_by_name($item->{name})};
            
            # Higher markup for black market
            my $base_price = $item->{gold} > 0 ? $item->{gold} : 100;
            my $markup = 1.5 + rand(1.0);  # 150-250% markup
            my $price = int($base_price * $markup);
            $price = max(100, $price);  # Minimum 100 gold
            
            my $charges = $item->{charges} > 0 ? $item->{charges} : 1;
            
            # Find the index
            $blackmarket_idx = find_treasure_index_by_name($item->{name});
            if ($blackmarket_idx > 0) {
                add_market_listing($item->{name}, $seller_name, $price, 2, $blackmarket_idx, $charges);
                $used_items{$item->{name}} = 1;
                $item_added = 1;
                $items_added++;
            }
        }
    }
    
    # Also add some non-permanent objects for variety
    my $object_items = int($max_items / 3); # 1/3 of the total
    
    for (1..$object_items) {
        last if $items_added >= $max_items;
        
        # Select random location
        my $location = $black_market_locations[int(rand(@black_market_locations))];
        my $region = $location->{region} // '';
        
        # Create seller name - same as above
        my $seller_prefix = $region eq "Castle" ? 
                          ($location->{castle_name} // "Castle") :
                          ($region eq "Dungeon" ? "Dungeon" : "Cave");
        my $seller_type = $seller_types[int(rand(@seller_types))];
        my $seller_name = "$seller_prefix $seller_type";
        
        # Try to find a suitable object
        my $attempts = 0;
        my $added_object = 0;
        
        while ($attempts < 15 && !$added_object) {
            my $oidx = int(rand(@objects));
            my $o = $objects[$oidx];
            $attempts++;
            
            # Skip if already used
            next if $used_items{"obj_".$o->{name}};
            
            # Skip if permanent
            next if $o->{permanent} && $o->{permanent} != 0;
            
            # Only use objects that might be valuable or interesting
            next unless $o->{shortname} =~ /gem|jewel|scroll|key|book|potion|amulet|ring|staff|wand|chest|box|map/i;
            
            # Set a premium price for black market objects
            my $price = 75 + int(rand(125));
            
            # Add the object to market
            if ($o->{name} && length($o->{name}) > 0) {
                add_market_listing($o->{name}, $seller_name, $price, 1, $oidx+1, 1);
                $used_items{"obj_".$o->{name}} = 1;
                $added_object = 1;
                $items_added++;
            }
        }
    }
    
    return $items_added;
}

sub get_town_size {
    my ($town_name) = @_;
    
    # Count rooms that belong to this town
    my $count = 0;
    foreach my $room_id (keys %rooms) {
        my $room = $rooms{$room_id};
        if ($room->{town_name} && $room->{town_name} eq $town_name) {
            $count++;
        }
    }
    
    return $count;
}

sub add_object_to_room {
    my ($room, $object_name, $hidden) = @_;
    my $idx = $object_by_name{$object_name} + 1;
    return unless $idx;
    if ($hidden) {
        $room->{hiddenobj} .= "$idx ";
    } else {
        $room->{object} .= "$idx ";
    }
}

sub add_treasure_to_room {
    my ($room, $treasure_name, $charges) = @_;
    my $idx = $treasure_by_name{$treasure_name} + 1;
    return unless $idx;
    my @treasures = split(/\s+/, $room->{treasure});
    my @charges   = split(/\s+/, $room->{trecharges});
    push @treasures, $idx;
    push @charges, $charges // 1;
    $room->{treasure}   = join(' ', @treasures);
    $room->{trecharges} = join(' ', @charges);
}

# Room types for cave generation
use constant {
    CAVE_TUNNEL    => 'CaveTunnel',    # 2 exits, linear passage
    CAVE_JUNCTION  => 'CaveJunction',  # 3-4 exits, where tunnels meet
    CAVE_CAVERN    => 'CaveCavern',    # Large room, many exits possible
    CAVE_SHAFT     => 'CaveShaft',     # Vertical passage with UP/DOWN
    CAVE_DEADEND   => 'CaveDeadend',   # End of a tunnel, 1 exit
    CAVE_LAKE      => 'CaveLake',      # Underground lake
    CAVE_ENTRANCE  => 'CaveEntrance',  # Entry from surface
};

sub generate_cave_map {
    my ($entrance_key, $next_idx_ref, $rooms_ref, $room_keys_ref) = @_;
    my $entrance_room = $rooms_ref->{$entrance_key};
    my %cave_rooms;
    
    # Cave parameters
    my $max_tunnels = 4 + int(rand(3));    # 4-6 main tunnels
    my $max_depth = 3 + int(rand(3));      # 3-5 levels deep
    my $tunnel_length = 5 + int(rand(4));  # 5-8 rooms per tunnel
    
    my $cave_center_x = 6;  # Local coordinate center
    my $cave_center_y = 6;
    
    # Start with entrance cavern
    my $entrance_local_key = "cave:$entrance_room->{idx}:$cave_center_x:$cave_center_y:0";
    $cave_rooms{$entrance_local_key} = {
        idx        => $$next_idx_ref++,
        x          => $cave_center_x,
        y          => $cave_center_y,
        z          => 0,
        region     => "Cave",
        feature    => CAVE_ENTRANCE,
        room_type  => 'cavern',  # Internal tracking
        impassable => 0,
        exits      => {},
    };
    push @$room_keys_ref, $entrance_local_key;
    
    # Track occupied positions
    my %occupied;
    $occupied{"$cave_center_x,$cave_center_y,0"} = $entrance_local_key;
    
    # Generate tunnels branching from the entrance
    my @directions = (['N', 0, -1], ['S', 0, 1], ['E', 1, 0], ['W', -1, 0]);
    my @shuffled_dirs = sort { rand() <=> rand() } @directions;
    
    my $tunnels_created = 0;
    for my $dir_info (@shuffled_dirs) {
        last if $tunnels_created >= $max_tunnels;
        
        my ($dir_name, $dx, $dy) = @$dir_info;
        my $opposite = $dir_name eq 'N' ? 'S' : $dir_name eq 'S' ? 'N' : $dir_name eq 'E' ? 'W' : 'E';
        
        # Create a tunnel in this direction
        my ($x, $y, $z) = ($cave_center_x, $cave_center_y, 0);
        my $prev_key = $entrance_local_key;
        my $tunnel_len = $tunnel_length + int(rand(3)) - 1;
        my $depth_change_points = int(rand(3));  # 0-2 points where tunnel goes deeper
        my @depth_changes = ();
        for (1..$depth_change_points) {
            push @depth_changes, 1 + int(rand($tunnel_len - 2));
        }
        
        for my $step (1..$tunnel_len) {
            # Move in tunnel direction
            $x += $dx;
            $y += $dy;
            
            # Check for depth change (shaft going down)
            my $going_down = grep { $_ == $step } @depth_changes;
            if ($going_down && $z < $max_depth - 1) {
                # Create a shaft room
                my $shaft_key = "cave:$entrance_room->{idx}:$x:$y:$z";
                if (!exists $occupied{"$x,$y,$z"}) {
                    $cave_rooms{$shaft_key} = {
                        idx        => $$next_idx_ref++,
                        x          => $x,
                        y          => $y,
                        z          => $z,
                        region     => "Cave",
                        feature    => CAVE_SHAFT,
                        room_type  => 'shaft',
                        impassable => 0,
                        exits      => {},
                    };
                    push @$room_keys_ref, $shaft_key;
                    $occupied{"$x,$y,$z"} = $shaft_key;
                    
                    # Connect to previous room
                    $cave_rooms{$prev_key}->{exits}{$dir_name} = $cave_rooms{$shaft_key}->{idx};
                    $cave_rooms{$shaft_key}->{exits}{$opposite} = $cave_rooms{$prev_key}->{idx};
                    
                    # Go down
                    $z++;
                    my $lower_key = "cave:$entrance_room->{idx}:$x:$y:$z";
                    $cave_rooms{$lower_key} = {
                        idx        => $$next_idx_ref++,
                        x          => $x,
                        y          => $y,
                        z          => $z,
                        region     => "Cave",
                        feature    => CAVE_TUNNEL,
                        room_type  => 'tunnel',
                        impassable => 0,
                        exits      => {},
                    };
                    push @$room_keys_ref, $lower_key;
                    $occupied{"$x,$y,$z"} = $lower_key;
                    
                    # Connect shaft to lower room
                    $cave_rooms{$shaft_key}->{exits}{'DOWN'} = $cave_rooms{$lower_key}->{idx};
                    $cave_rooms{$lower_key}->{exits}{'UP'} = $cave_rooms{$shaft_key}->{idx};
                    
                    $prev_key = $lower_key;
                    next;
                }
            }
            
            # Skip if position occupied
            next if exists $occupied{"$x,$y,$z"};
            
            # Determine room type based on position
            my $feature;
            my $room_type;
            if ($step == $tunnel_len) {
                # End of tunnel
                if (rand() < 0.3 && $z < $max_depth - 1) {
                    # 30% chance: cavern at end with possible downward shaft
                    $feature = CAVE_CAVERN;
                    $room_type = 'cavern';
                } elsif (rand() < 0.2) {
                    # 20% chance: underground lake
                    $feature = CAVE_LAKE;
                    $room_type = 'cavern';
                } else {
                    # Dead end
                    $feature = CAVE_DEADEND;
                    $room_type = 'deadend';
                }
            } elsif ($step == int($tunnel_len / 2) && rand() < 0.4) {
                # 40% chance: junction in middle of tunnel
                $feature = CAVE_JUNCTION;
                $room_type = 'junction';
            } else {
                # Regular tunnel
                $feature = CAVE_TUNNEL;
                $room_type = 'tunnel';
            }
            
            my $key = "cave:$entrance_room->{idx}:$x:$y:$z";
            $cave_rooms{$key} = {
                idx        => $$next_idx_ref++,
                x          => $x,
                y          => $y,
                z          => $z,
                region     => "Cave",
                feature    => $feature,
                room_type  => $room_type,
                impassable => 0,
                exits      => {},
            };
            push @$room_keys_ref, $key;
            $occupied{"$x,$y,$z"} = $key;
            
            # Connect to previous room (tunnel: only 2 exits)
            $cave_rooms{$prev_key}->{exits}{$dir_name} = $cave_rooms{$key}->{idx};
            $cave_rooms{$key}->{exits}{$opposite} = $cave_rooms{$prev_key}->{idx};
            
            # If this is a junction or cavern, potentially branch
            if ($room_type eq 'junction' || $room_type eq 'cavern') {
                # Create a side tunnel
                my @side_dirs = grep { $_->[0] ne $dir_name && $_->[0] ne $opposite } @directions;
                my $side = $side_dirs[int(rand(@side_dirs))];
                create_side_tunnel($entrance_room->{idx}, $key, $side, $x, $y, $z, 
                                  \%cave_rooms, \%occupied, $next_idx_ref, $room_keys_ref, 3 + int(rand(3)));
            }
            
            $prev_key = $key;
        }
        
        $tunnels_created++;
    }
    
    # Connect entrance to surface
    $entrance_room->{exits}{'DOWN'} = $cave_rooms{$entrance_local_key}->{idx};
    $cave_rooms{$entrance_local_key}->{exits}{'UP'} = $entrance_room->{idx};
    
    # Add cave rooms to main rooms hash
    @$rooms_ref{keys %cave_rooms} = values %cave_rooms;
}

sub create_side_tunnel {
    my ($entrance_idx, $start_key, $dir_info, $start_x, $start_y, $start_z, 
        $cave_rooms_ref, $occupied_ref, $next_idx_ref, $room_keys_ref, $length) = @_;
    
    my ($dir_name, $dx, $dy) = @$dir_info;
    my $opposite = $dir_name eq 'N' ? 'S' : $dir_name eq 'S' ? 'N' : $dir_name eq 'E' ? 'W' : 'E';
    
    my ($x, $y, $z) = ($start_x, $start_y, $start_z);
    my $prev_key = $start_key;
    
    for my $step (1..$length) {
        $x += $dx;
        $y += $dy;
        
        next if exists $occupied_ref->{"$x,$y,$z"};
        
        my $feature = ($step == $length) ? CAVE_DEADEND : CAVE_TUNNEL;
        my $room_type = ($step == $length) ? 'deadend' : 'tunnel';
        
        my $key = "cave:$entrance_idx:$x:$y:$z";
        $cave_rooms_ref->{$key} = {
            idx        => $$next_idx_ref++,
            x          => $x,
            y          => $y,
            z          => $z,
            region     => "Cave",
            feature    => $feature,
            room_type  => $room_type,
            impassable => 0,
            exits      => {},
        };
        push @$room_keys_ref, $key;
        $occupied_ref->{"$x,$y,$z"} = $key;
        
        # Connect rooms - tunnel has only 2 exits
        $cave_rooms_ref->{$prev_key}->{exits}{$dir_name} = $cave_rooms_ref->{$key}->{idx};
        $cave_rooms_ref->{$key}->{exits}{$opposite} = $cave_rooms_ref->{$prev_key}->{idx};
        
        $prev_key = $key;
    }
}

sub generate_dungeon_map {
    my ($entrance_key, $next_idx_ref, $rooms_ref, $room_keys_ref) = @_;
    my $entrance_room = $rooms_ref->{$entrance_key};
    my %dungeon_rooms;
    
    # Dungeon parameters
    my $max_depth = 4 + int(rand(2));      # 4-5 levels deep
    my $corridor_length = 4 + int(rand(3)); # 4-6 rooms per corridor
    
    my $dungeon_center_x = 6;
    my $dungeon_center_y = 6;
    
    # Start with entrance chamber
    my $entrance_local_key = "dungeon:$entrance_room->{idx}:$dungeon_center_x:$dungeon_center_y:0";
    $dungeon_rooms{$entrance_local_key} = {
        idx        => $$next_idx_ref++,
        x          => $dungeon_center_x,
        y          => $dungeon_center_y,
        z          => 0,
        region     => "Dungeon",
        feature    => "DungeonChamber",
        room_type  => 'chamber',
        impassable => 0,
        exits      => {},
    };
    push @$room_keys_ref, $entrance_local_key;
    
    my %occupied;
    $occupied{"$dungeon_center_x,$dungeon_center_y,0"} = $entrance_local_key;
    
    # Generate dungeon structure: main corridor going down, with branches
    my @directions = (['N', 0, -1], ['S', 0, 1], ['E', 1, 0], ['W', -1, 0]);
    
    # Create main downward path with corridors on each level
    my ($x, $y, $z) = ($dungeon_center_x, $dungeon_center_y, 0);
    my $prev_key = $entrance_local_key;
    my $prev_stair_key = $entrance_local_key;
    
    for my $level (0..$max_depth-1) {
        # Create corridors on this level
        my @shuffled_dirs = sort { rand() <=> rand() } @directions;
        my $corridors_on_level = 2 + int(rand(2));  # 2-3 corridors per level
        my $corridor_count = 0;
        
        for my $dir_info (@shuffled_dirs) {
            last if $corridor_count >= $corridors_on_level;
            
            my ($dir_name, $dx, $dy) = @$dir_info;
            my $opposite = $dir_name eq 'N' ? 'S' : $dir_name eq 'S' ? 'N' : $dir_name eq 'E' ? 'W' : 'E';
            
            # Start corridor from the stair/entrance position, not center
            my ($cx, $cy) = ($x, $y);  # x, y is updated to stair position each level
            my $corridor_prev_key = $prev_stair_key;
            my $this_corridor_len = $corridor_length + int(rand(3)) - 1;
            
            for my $step (1..$this_corridor_len) {
                $cx += $dx;
                $cy += $dy;
                
                # Check if this position is already occupied
                if (exists $occupied{"$cx,$cy,$level"}) {
                    # If there's already a room here, connect to it and stop this corridor
                    my $existing_key = $occupied{"$cx,$cy,$level"};
                    if ($dungeon_rooms{$existing_key} && $dungeon_rooms{$corridor_prev_key}) {
                        # Connect to existing room (create intersection)
                        $dungeon_rooms{$corridor_prev_key}->{exits}{$dir_name} = $dungeon_rooms{$existing_key}->{idx};
                        $dungeon_rooms{$existing_key}->{exits}{$opposite} = $dungeon_rooms{$corridor_prev_key}->{idx};
                    }
                    last;  # Stop extending this corridor
                }
                
                # Determine room type
                my $feature;
                my $room_type;
                if ($step == $this_corridor_len) {
                    # End of corridor: chamber, guardroom, or prison
                    my @end_types = ("DungeonChamber", "DungeonGuardroom", "DungeonPrison");
                    $feature = $end_types[int(rand(@end_types))];
                    $room_type = 'chamber';
                } elsif ($step == int($this_corridor_len / 2) && rand() < 0.5) {
                    # Middle: possible side room
                    $feature = "DungeonCell";
                    $room_type = 'cell';
                } else {
                    # Regular corridor
                    $feature = "DungeonCorridor";
                    $room_type = 'corridor';
                }
                
                my $key = "dungeon:$entrance_room->{idx}:$cx:$cy:$level";
                $dungeon_rooms{$key} = {
                    idx        => $$next_idx_ref++,
                    x          => $cx,
                    y          => $cy,
                    z          => $level,
                    region     => "Dungeon",
                    feature    => $feature,
                    room_type  => $room_type,
                    impassable => 0,
                    exits      => {},
                };
                push @$room_keys_ref, $key;
                $occupied{"$cx,$cy,$level"} = $key;
                
                # Connect - corridors only have 2 exits
                $dungeon_rooms{$corridor_prev_key}->{exits}{$dir_name} = $dungeon_rooms{$key}->{idx};
                $dungeon_rooms{$key}->{exits}{$opposite} = $dungeon_rooms{$corridor_prev_key}->{idx};
                
                $corridor_prev_key = $key;
            }
            
            $corridor_count++;
        }
        
        # Create stairs down to next level (if not last level)
        if ($level < $max_depth - 1) {
            # Find a good spot for stairs - try one of the directions
            my @stair_dirs = sort { rand() <=> rand() } @directions;
            my $stair_created = 0;
            
            for my $dir_info (@stair_dirs) {
                last if $stair_created;
                my ($dir_name, $dx, $dy) = @$dir_info;
                my $opposite = $dir_name eq 'N' ? 'S' : $dir_name eq 'S' ? 'N' : $dir_name eq 'E' ? 'W' : 'E';
                
                my ($sx, $sy) = ($x + $dx, $y + $dy);
                next if exists $occupied{"$sx,$sy,$level"};
                
                # Create stairwell room on this level
                my $stair_key = "dungeon:$entrance_room->{idx}:$sx:$sy:$level";
                $dungeon_rooms{$stair_key} = {
                    idx        => $$next_idx_ref++,
                    x          => $sx,
                    y          => $sy,
                    z          => $level,
                    region     => "Dungeon",
                    feature    => "DungeonStairs",
                    room_type  => 'stairs',
                    impassable => 0,
                    exits      => {},
                };
                push @$room_keys_ref, $stair_key;
                $occupied{"$sx,$sy,$level"} = $stair_key;
                
                # Connect to level start
                $dungeon_rooms{$prev_stair_key}->{exits}{$dir_name} = $dungeon_rooms{$stair_key}->{idx};
                $dungeon_rooms{$stair_key}->{exits}{$opposite} = $dungeon_rooms{$prev_stair_key}->{idx};
                
                # Create landing on lower level
                my $lower_level = $level + 1;
                my $lower_key = "dungeon:$entrance_room->{idx}:$sx:$sy:$lower_level";
                $dungeon_rooms{$lower_key} = {
                    idx        => $$next_idx_ref++,
                    x          => $sx,
                    y          => $sy,
                    z          => $lower_level,
                    region     => "Dungeon",
                    feature    => "DungeonLanding",
                    room_type  => 'landing',
                    impassable => 0,
                    exits      => {},
                };
                push @$room_keys_ref, $lower_key;
                $occupied{"$sx,$sy,$lower_level"} = $lower_key;
                
                # Connect stairs up/down
                $dungeon_rooms{$stair_key}->{exits}{'DOWN'} = $dungeon_rooms{$lower_key}->{idx};
                $dungeon_rooms{$lower_key}->{exits}{'UP'} = $dungeon_rooms{$stair_key}->{idx};
                
                # Update position for next level
                $x = $sx;
                $y = $sy;
                $prev_stair_key = $lower_key;
                $stair_created = 1;
            }
        }
        
        # On deepest level, create the vault
        if ($level == $max_depth - 1) {
            # Find spot for vault
            my @vault_dirs = sort { rand() <=> rand() } @directions;
            for my $dir_info (@vault_dirs) {
                my ($dir_name, $dx, $dy) = @$dir_info;
                my $opposite = $dir_name eq 'N' ? 'S' : $dir_name eq 'S' ? 'N' : $dir_name eq 'E' ? 'W' : 'E';
                
                my ($vx, $vy) = ($x + $dx, $y + $dy);
                next if exists $occupied{"$vx,$vy,$level"};
                
                my $vault_key = "dungeon:$entrance_room->{idx}:$vx:$vy:$level";
                $dungeon_rooms{$vault_key} = {
                    idx        => $$next_idx_ref++,
                    x          => $vx,
                    y          => $vy,
                    z          => $level,
                    region     => "Dungeon",
                    feature    => "DungeonVault",
                    room_type  => 'vault',
                    impassable => 0,
                    exits      => {},
                };
                push @$room_keys_ref, $vault_key;
                $occupied{"$vx,$vy,$level"} = $vault_key;
                
                # Connect vault to landing/previous room
                $dungeon_rooms{$prev_stair_key}->{exits}{$dir_name} = $dungeon_rooms{$vault_key}->{idx};
                $dungeon_rooms{$vault_key}->{exits}{$opposite} = $dungeon_rooms{$prev_stair_key}->{idx};
                last;
            }
        }
    }
    
    # Connect entrance to surface
    $entrance_room->{exits}{'DOWN'} = $dungeon_rooms{$entrance_local_key}->{idx};
    $dungeon_rooms{$entrance_local_key}->{exits}{'UP'} = $entrance_room->{idx};
    
    @$rooms_ref{keys %dungeon_rooms} = values %dungeon_rooms;
}

sub place_grass {
  my $room_count = 0;
  for my $y (0..$HEIGHT-1) {
      for my $x (0..$WIDTH-1) {
          my $key = "$x,$y,0";
          $rooms{$key} = {
              idx        => $y * $WIDTH + $x + 1,
              x          => $x,
              y          => $y,
              z          => 0,
              region     => "Grass",
              feature    => "Grass",
              impassable => 0,
              exits      => {},
              object              => '',
              hiddenobj           => '',
              treasure            => '',
              trecharges          => '',
              monsterclass        => 0,
              container           => '',
              container_permanent => 0,
          };
          push @room_keys, $key;
          $room_count++;
      }
  }
  my $conn_count = 0;
  for my $key (@room_keys) {
      my $room = $rooms{$key};
      my ($x, $y) = ($room->{x}, $room->{y});
      my %dir_delta = (
          N  => [ 0, -1], S  => [ 0,  1], E  => [ 1,  0], W  => [-1,  0],
          NE => [ 1, -1], SE => [ 1,  1], SW => [-1,  1], NW => [-1, -1],
      );
      for my $dir (keys %dir_delta) {
          my ($dx, $dy) = @{$dir_delta{$dir}};
          my ($nx, $ny) = ($x+$dx, $y+$dy);
          next if $nx < 0 || $nx >= $WIDTH || $ny < 0 || $ny >= $HEIGHT;
          my $nkey = "$nx,$ny,0";
          next if $room->{impassable} || ($rooms{$nkey} && $rooms{$nkey}->{impassable});
          $room->{exits}{$dir} = $rooms{$nkey}->{idx};
          $conn_count++;
      }
  }
}

sub place_castles {
    
    # First collect all town locations to avoid placing castles too close
    my @town_centers;
    for my $town (@towns) {
        my ($tx, $ty, $tw, $th) = @$town;
        push @town_centers, [$tx + int($tw/2), $ty + int($th/2)];
    }
    
    # Spacing requirements scaled to map size
    my $min_castle_spacing = max(10, int(min($WIDTH, $HEIGHT) * 0.10));
    my $min_town_distance = max(8, int(min($WIDTH, $HEIGHT) * 0.08));
    
    # Create zones for castle placement
    my $zones_per_side = ceil(sqrt($castle_count * 3)); 
    my $zone_w = int($WIDTH / $zones_per_side);
    my $zone_h = int($HEIGHT / $zones_per_side);
    
    my @zone_coords;
    for my $zx (0..$zones_per_side-1) {
        for my $zy (0..$zones_per_side-1) {
            my $x0 = $zx * $zone_w + int($zone_w * 0.1);
            my $x1 = ($zx == $zones_per_side-1) ? 
                     $WIDTH - int($zone_w * 0.1) : 
                     ($zx+1)*$zone_w - int($zone_w * 0.1);
            my $y0 = $zy * $zone_h + int($zone_h * 0.1);
            my $y1 = ($zy == $zones_per_side-1) ? 
                     $HEIGHT - int($zone_h * 0.1) : 
                     ($zy+1)*$zone_h - int($zone_h * 0.1);
            
            if ($x1 - $x0 >= 5 && $y1 - $y0 >= 5) {
                push @zone_coords, [$x0, $x1, $y0, $y1];
            }
        }
    }

    # Calculate zone weights based on distance from center and terrain
    my @zone_weights;
    my $center_x = $WIDTH / 2;
    my $center_y = $HEIGHT / 2;
    
    for my $i (0..$#zone_coords) {
        my ($x0, $x1, $y0, $y1) = @{$zone_coords[$i]};
        my $zone_center_x = ($x0 + $x1) / 2;
        my $zone_center_y = ($y0 + $y1) / 2;
        
        # Count suitable terrain in zone
        my $suitable_terrain = 0;
        my $total_checked = 0;
        
        for my $x ($x0..$x1) {
            for my $y ($y0..$y1) {
                my $key = "$x,$y,0";
                next unless exists $rooms{$key};
                $total_checked++;
                my $r = $rooms{$key};
                if ($r->{region} =~ /^(Grass|Hill|Forest)$/ && !$r->{impassable}) {
                    $suitable_terrain++;
                }
            }
        }
        
        # Calculate base terrain score
        my $terrain_score = $total_checked ? ($suitable_terrain / $total_checked) : 0;
        
        # Calculate distance from center score (0.0 to 1.0)
        my $dist_from_center = sqrt(
            ($zone_center_x - $center_x)**2 + 
            ($zone_center_y - $center_y)**2
        ) / sqrt($WIDTH**2 + $HEIGHT**2);
        my $center_score = 1 - ($dist_from_center * 0.5);
        
        # Calculate distance from other castles
        my $min_castle_dist = 1e9;
        for my $castle (@castles) {
            my ($cx, $cy) = @$castle;
            my $dist = sqrt(($zone_center_x - $cx)**2 + ($zone_center_y - $cy)**2);
            $min_castle_dist = $dist if $dist < $min_castle_dist;
        }
        
        # Calculate distance from towns
        my $min_town_dist = 1e9;
        for my $tc (@town_centers) {
            my $dist = sqrt(($zone_center_x - $tc->[0])**2 + ($zone_center_y - $tc->[1])**2);
            $min_town_dist = $dist if $dist < $min_town_dist;
        }
        
        # Combine all factors into final weight
        $zone_weights[$i] = $terrain_score * $center_score * 
            ($min_castle_dist < $min_castle_spacing ? 0.1 : 1.0) *
            ($min_town_dist < $min_town_distance ? 0.1 : 1.0);
    }

    my @used_zones;
    my $castles_placed = 0;
    my $castle_attempts = 0;
    my $max_attempts = $castle_count * 300;

    while ($castles_placed < $castle_count && $castle_attempts < $max_attempts) {
        $castle_attempts++;
        
        # Select zone weighted by suitability
        my $total_weight = 0;
        $total_weight += $_ for @zone_weights;
        my $r = rand($total_weight);
        my $acc = 0;
        my $zone_idx;
        
        for my $i (0..$#zone_weights) {
            next if $used_zones[$i];
            $acc += $zone_weights[$i];
            if ($r <= $acc) {
                $zone_idx = $i;
                last;
            }
        }
        
        # Fallback to any unused zone if weighted selection fails
        unless (defined $zone_idx) {
            for my $i (0..$#zone_coords) {
                unless ($used_zones[$i]) {
                    $zone_idx = $i;
                    last;
                }
            }
        }
        
        next unless defined $zone_idx;
        
        my ($zone_x0, $zone_x1, $zone_y0, $zone_y1) = @{$zone_coords[$zone_idx]};
        
        # Try multiple positions within the zone
        my $placed = 0;
        for my $attempt (1..50) {
            my $cw = 4 + int(rand(2));
            my $ch = 4 + int(rand(2));
            
            my $cx = $zone_x0 + int(rand($zone_x1 - $zone_x0 - $cw));
            my $cy = $zone_y0 + int(rand($zone_y1 - $zone_y0 - $ch));
            
            # Verify minimum distances
            my $too_close = 0;
            for my $c (@castles) {
                my ($ox, $oy) = @$c;
                my $dist = sqrt(($cx - $ox)**2 + ($cy - $oy)**2);
                if ($dist < $min_castle_spacing) {
                    $too_close = 1;
                    last;
                }
            }
            
            for my $tc (@town_centers) {
                my $dist = sqrt(($cx - $tc->[0])**2 + ($cy - $tc->[1])**2);
                if ($dist < $min_town_distance) {
                    $too_close = 1;
                    last;
                }
            }
            next if $too_close;
            
            # Check terrain suitability
            my $suitable = 1;
            my $terrain_counts = {};
            
            for my $dy (-1..$ch) {
                for my $dx (-1..$cw) {
                    my $x = $cx + $dx;
                    my $y = $cy + $dy;
                    my $key = "$x,$y,0";
                    next unless exists $rooms{$key};
                    my $r = $rooms{$key};
                    $terrain_counts->{$r->{region}}++;
                    
                    if ($r->{region} =~ /^(Mountain|Lake|River|Town|Castle|Moat)$/ || $r->{impassable}) {
                        $suitable = 0;
                        last;
                    }
                }
                last unless $suitable;
            }
            
            if ($suitable) {
                my $castle_name = $shuffled_castle_names[$castles_placed % @shuffled_castle_names];
                
                # Place castle and moat
                for my $dy (-1..$ch) {
                    for my $dx (-1..$cw) {
                        my $x = $cx + $dx;
                        my $y = $cy + $dy;
                        my $key = "$x,$y,0";
                        next unless exists $rooms{$key};
                        
                        if ($dx >= 0 && $dx < $cw && $dy >= 0 && $dy < $ch) {
                            $rooms{$key}->{region} = "Castle";
                            $rooms{$key}->{feature} = "CastleRoom";
                            $rooms{$key}->{castle_name} = $castle_name;
                            $rooms{$key}->{impassable} = 0;
                        } else {
                            $rooms{$key}->{region} = "Moat";
                            $rooms{$key}->{feature} = "Moat";
                            $rooms{$key}->{impassable} = 1;
                            $rooms{$key}->{exits} = {};
                        }
                    }
                }
                
                # Place drawbridge on random side
                my @sides = (
                    ['S', sub { int($cx + $cw/2) }, sub { $cy + $ch }],
                    ['N', sub { int($cx + $cw/2) }, sub { $cy - 1 }],
                    ['E', sub { $cx + $cw }, sub { int($cy + $ch/2) }],
                    ['W', sub { $cx - 1 }, sub { int($cy + $ch/2) }]
                );
                
                @sides = sort { rand() <=> rand() } @sides;
                
                for my $side (@sides) {
                    my ($dir, $get_x, $get_y) = @$side;
                    my $x = $get_x->();
                    my $y = $get_y->();
                    my $key = "$x,$y,0";
                    
                    next unless exists $rooms{$key};
                    next unless $rooms{$key}->{region} eq "Moat";
                    
                    $rooms{$key}->{region} = "Castle";
                    $rooms{$key}->{feature} = "Drawbridge";
                    $rooms{$key}->{castle_name} = $castle_name;
                    $rooms{$key}->{impassable} = 0;
                    last;
                }
                
                push @castles, [$cx, $cy, $cw, $ch, $castle_name];
                $castles_placed++;
                $used_zones[$zone_idx] = 1;
                $placed = 1;
                
                last;
            }
        }
        last if $castles_placed >= $castle_count;
    }
    
    return $castles_placed;
}

sub place_castle {
    my ($cx, $cy, $cw, $ch) = @_;
    
    # Place castle rooms and moat
    my $drawbridge_placed = 0;
    my $drawbridge_x = 0;
    my $drawbridge_y = 0;
    
    # First pass - place castle and moat
    for my $dy (-1..$ch) {
        for my $dx (-1..$cw) {
            my $x = $cx + $dx;
            my $y = $cy + $dy;
            my $key = "$x,$y,0";
            next unless exists $rooms{$key};
            
            if ($dx >= 0 && $dx < $cw && $dy >= 0 && $dy < $ch) {
                $rooms{$key}->{region} = "Castle";
                $rooms{$key}->{feature} = "CastleRoom";
                $rooms{$key}->{impassable} = 0;
            } else {
                $rooms{$key}->{region} = "Moat";
                $rooms{$key}->{feature} = "Moat";
                $rooms{$key}->{impassable} = 1;
                $rooms{$key}->{exits} = {};
            }
        }
    }
    
    # Second pass - place drawbridge
    # Try each side of the castle in random order
    my @sides = (
        ['S', sub { int($cx + $cw/2) }, sub { $cy + $ch }],
        ['N', sub { int($cx + $cw/2) }, sub { $cy - 1 }],
        ['E', sub { $cx + $cw }, sub { int($cy + $ch/2) }],
        ['W', sub { $cx - 1 }, sub { int($cy + $ch/2) }]
    );
    
    @sides = sort { rand() <=> rand() } @sides;
    
    for my $side (@sides) {
        my ($dir, $get_x, $get_y) = @$side;
        my $x = $get_x->();
        my $y = $get_y->();
        my $key = "$x,$y,0";
        
        next unless exists $rooms{$key};
        next unless $rooms{$key}->{region} eq "Moat";
        
        # Check if there's walkable terrain beyond the drawbridge
        my ($nx, $ny);
        if ($dir eq 'N') { $nx = $x; $ny = $y - 1; }
        elsif ($dir eq 'S') { $nx = $x; $ny = $y + 1; }
        elsif ($dir eq 'E') { $nx = $x + 1; $ny = $y; }
        elsif ($dir eq 'W') { $nx = $x - 1; $ny = $y; }
        
        my $next_key = "$nx,$ny,0";
        next unless exists $rooms{$next_key};
        next if $rooms{$next_key}->{impassable};
        
        # Place drawbridge
        $rooms{$key}->{region} = "Castle";
        $rooms{$key}->{feature} = "Drawbridge";
        $rooms{$key}->{impassable} = 0;
        $drawbridge_placed = 1;
        $drawbridge_x = $x;
        $drawbridge_y = $y;
        last;
    }
    
    # Add castle to the list
    my $castle_name = $shuffled_castle_names[$castles_placed % @shuffled_castle_names];
    push @castles, [$cx, $cy, $cw, $ch, $castle_name];
    
    # Set castle name for all castle rooms
    for my $dy (0..$ch-1) {
        for my $dx (0..$cw-1) {
            my $x = $cx + $dx;
            my $y = $cy + $dy;
            my $key = "$x,$y,0";
            next unless exists $rooms{$key};
            $rooms{$key}->{castle_name} = $castle_name;
        }
    }
    
    print $drawbridge_placed ? ", drawbridge at ($drawbridge_x,$drawbridge_y)\n" : " (no drawbridge placed)\n";
}

my $min_town_area = 60; 
my $max_town_area = 120; 

sub place_towns {
    my ($rooms_ref, $room_keys_ref, $towns_ref) = @_;
    my $tries_per_town = 1000;
    
    print "Generating $town_count towns...\n" if $ENV{DEBUG};
    my @placed_towns;
    my $towns_near_castles = int($town_count * 0.6);
    my $towns_spread = $town_count - $towns_near_castles;
    
    print "  Planning $towns_near_castles towns near castles, $towns_spread elsewhere\n" if $ENV{DEBUG};

    TOWN: for (my $t = 0; $t < $town_count; $t++) {
        my $try = 0;
        my ($center_x, $center_y, $area, $near_castle);

        $near_castle = ($t < $towns_near_castles && @castles);
        
        while ($try++ < $tries_per_town) {
            $area = $min_town_area + int(rand($max_town_area - $min_town_area + 1));
            
            if ($near_castle) {
                my $castle = $castles[int(rand(@castles))];
                my ($cx, $cy, $cw, $ch) = @$castle;
                my $radius = 10 + int(rand(10));
                $center_x = $cx + int(rand($cw)) + int(rand(2*$radius+1)) - $radius;
                $center_y = $cy + int(rand($ch)) + int(rand(2*$radius+1)) - $radius;
                $center_x = max(0, min($center_x, $WIDTH-1));
                $center_y = max(0, min($center_y, $HEIGHT-1));
                
                print "  Town #$t: Trying position near castle at ($center_x,$center_y)\n" if $ENV{DEBUG};
            } else {
                $center_x = int(rand($WIDTH));
                $center_y = int(rand($HEIGHT));
                
                print "  Town #$t: Trying position at ($center_x,$center_y)\n" if $ENV{DEBUG};
            }

            # Improved blob growth for more natural town shapes
            my %town_tiles;
            my @frontier = ("$center_x,$center_y,0");
            $town_tiles{"$center_x,$center_y,0"} = 1;
            my $filled = 1;
            my $blob_iters = 0;
            my $max_blob_iters = $area * 30; # Increased iterations for better coverage

            # Growth parameters
            my $center_bias = 0.7;  # Tendency to grow near center
            my $road_bias = 0.3;    # Tendency to grow along roads
            my $house_density = 0.45; # Increased from 0.3

            while (@frontier && $filled < $area && $blob_iters++ < $max_blob_iters) {
                my $idx = int(rand(@frontier));
                my $k = splice(@frontier, $idx, 1);
                my ($x, $y, $z) = split /,/, $k;

                for my $d ([0,1],[1,0],[0,-1],[-1,0],[1,1],[-1,1],[1,-1],[-1,-1]) {
                    my ($dx, $dy) = @$d;
                    my ($nx, $ny) = ($x+$dx, $y+$dy);
                    
                    next if $nx < 2 || $nx >= $WIDTH-2 || $ny < 2 || $ny >= $HEIGHT-2;
                    next if $town_tiles{$nx,$ny,0};
                    
                    my $nkey = "$nx,$ny,0";
                    next unless exists $rooms_ref->{$nkey};
                    my $r = $rooms_ref->{$nkey};
                    next if $r->{impassable} || $r->{region} =~ /^(Lake|Mountain|Moat|River|Castle|Town)$/;
                    
                    # Calculate growth probability based on position and surroundings
                    my $dist_from_center = sqrt(($nx - $center_x)**2 + ($ny - $center_y)**2);
                    my $center_factor = exp(-$dist_from_center * $center_bias / sqrt($area));

                    # Check for adjacent roads or houses
                    my $adjacent_road = 0;
                    my $adjacent_house = 0;
                    for my $nd ([0,1],[1,0],[0,-1],[-1,0]) {
                        my $ax = $nx + $nd->[0];
                        my $ay = $ny + $nd->[1];
                        my $akey = "$ax,$ay,0";
                        if (exists $town_tiles{$akey} && exists $rooms_ref->{$akey}) {
                            if ($rooms_ref->{$akey}->{region} eq "Road") {
                                $adjacent_road = 1;
                            } elsif ($rooms_ref->{$akey}->{feature} eq "House") {
                                $adjacent_house = 1;
                            }
                        }
                    }

                    my $growth_prob = $center_factor;
                    $growth_prob *= 1.2 if $adjacent_road;
                    $growth_prob *= 0.8 if $adjacent_house; # Slight spacing between houses
                    
                    next if rand() > $growth_prob;
                    
                    $town_tiles{"$nx,$ny,0"} = 1;
                    push @frontier, "$nx,$ny,0";
                    $filled++;
                }
            }

            # Place town features with improved distribution
            if ($filled >= $min_town_area) {
                my $town_name = $shuffled_town_names[$t % @shuffled_town_names];
                $town_name_map{$t} = $town_name;
                
                print "  Town #$t: Successfully placed $town_name with $filled tiles\n" if $ENV{DEBUG};

                # Place plaza first
                my $plaza_key = "$center_x,$center_y,0";
                if (exists $rooms_ref->{$plaza_key}) {
                    $rooms_ref->{$plaza_key}->{feature} = "Plaza";
                    $rooms_ref->{$plaza_key}->{town_name} = $town_name;
                    
                    # Apply feature-based description
                    update_room_description_from_feature($rooms_ref->{$plaza_key});
                    
                    print "    Placed central plaza at ($center_x,$center_y)\n" if $ENV{DEBUG};
                }

                # Calculate house positions with better spacing
                my @potential_house_spots;
                for my $k (keys %town_tiles) {
                    my ($x, $y, $z) = split /,/, $k;
                    next if abs($x - $center_x) < 2 && abs($y - $center_y) < 2; # Keep center clear
                    push @potential_house_spots, [$x, $y, $k];
                }

                # Place houses with improved spacing
                my $house_count = 0;
                while (@potential_house_spots && $house_count < ($filled * $house_density)) {
                    my $idx = int(rand(@potential_house_spots));
                    my ($x, $y, $k) = @{splice(@potential_house_spots, $idx, 1)};

                    # Check spacing from other houses
                    my $too_close = 0;
                    for my $dx (-1..1) {
                        for my $dy (-1..1) {
                            next if $dx == 0 && $dy == 0;
                            my $nkey = ($x+$dx).",".($y+$dy).",0";
                            if (exists $rooms_ref->{$nkey} &&
                                $rooms_ref->{$nkey}->{feature} &&
                                $rooms_ref->{$nkey}->{feature} =~ /^(House|Shop|Inn|Temple|Tavern|Bank)$/) {
                                $too_close = 1;
                                last;
                            }
                        }
                    }

                    next if $too_close;

                    $rooms_ref->{$k}->{feature} = "House";
                    $rooms_ref->{$k}->{town_name} = $town_name;
                    
                    # Apply feature-based description
                    update_room_description_from_feature($rooms_ref->{$k});
                    
                    # Give each house a unique name
                    my $house_name = $house_names[$house_count % @house_names];
                    $rooms_ref->{$k}->{house_name} = $house_name;
                    
                    $house_count++;
                }
                
                print "    Placed $house_count houses\n" if $ENV{DEBUG};

                # Track shop locations for specialized shops
                my %town_shops;

                # Place special buildings near plaza
                my @special_buildings = (
                    ["Shop", 2],
                    ["Inn", 1],
                    ["Temple", 1],
                    ["Tavern", 1],
                    ["Bank", 1]
                );

                for my $special (@special_buildings) {
                    my ($type, $count) = @$special;
                    for (1..$count) {
                        my $dist = 2;
                        my $placed = 0;
                        while ($dist < 6 && !$placed) {
                            my @candidates = grep {
                                my ($x, $y) = (split /,/, $_)[0,1];
                                abs($x - $center_x) + abs($y - $center_y) == $dist
                            } keys %town_tiles;

                            for my $k (@candidates) {
                                next unless exists $rooms_ref->{$k};
                                next if $rooms_ref->{$k}->{feature} &&
                                       $rooms_ref->{$k}->{feature} ne "House";
                                
                                $rooms_ref->{$k}->{feature} = $type;
                                $rooms_ref->{$k}->{town_name} = $town_name;
                                
                                # Apply feature-based description
                                update_room_description_from_feature($rooms_ref->{$k});
                                
                                # Track shop locations for later specialization
                                if ($type eq "Shop") {
                                    $town_shops{$k} = 1;
                                }
                                
                                $placed = 1;
                                print "    Placed $type at distance $dist\n" if $ENV{DEBUG};
                                last;
                            }
                            $dist++;
                        }
                    }
                }

                # Mark remaining tiles as part of town
                for my $k (keys %town_tiles) {
                    next unless exists $rooms_ref->{$k};
                    $rooms_ref->{$k}->{region} = "Town";
                    $rooms_ref->{$k}->{town_name} = $town_name;
                    $rooms_ref->{$k}->{feature} ||= "Yard";
                    
                    # Apply feature-based description if not already set
                    if ($rooms_ref->{$k}->{feature} && !$rooms_ref->{$k}->{shortdesc}) {
                        update_room_description_from_feature($rooms_ref->{$k});
                    }
                }

                # Calculate town bounds
                my ($minx, $maxx, $miny, $maxy) = ($WIDTH, 0, $HEIGHT, 0);
                for my $k (keys %town_tiles) {
                    my ($x, $y) = split /,/, $k;
                    $minx = $x if $x < $minx;
                    $maxx = $x if $x > $maxx;
                    $miny = $y if $y < $miny;
                    $maxy = $y if $y > $maxy;
                }

                # Determine predominant biome for town specialization
                my %biome_counts;
                for my $k (keys %town_tiles) {
                    my ($x, $y) = split /,/, $k;
                    my $biome_type = get_biome_at($x, $y);
                    $biome_counts{$biome_type}++;
                }
                
                my $predominant_biome = 'grass';
                my $max_count = 0;
                for my $biome_type (keys %biome_counts) {
                    if ($biome_counts{$biome_type} > $max_count) {
                        $max_count = $biome_counts{$biome_type};
                        $predominant_biome = $biome_type;
                    }
                }
                
                # Generate specialized shops based on town size and biome
                if (%town_shops) {
                    my $town_size = scalar(keys %town_tiles);
                    generate_town_shops($town_name, $predominant_biome, $town_size, \%town_shops, $rooms_ref);
                    print "    Generated specialized shops based on $predominant_biome biome\n" if $ENV{DEBUG};
                }

                # Create and populate shops with inventory
                for my $shop_key (keys %town_shops) {
                    my $shop = $rooms_ref->{$shop_key};
                    next unless $shop && $shop->{shop_type};
                    
                    my $inventory_size = 5 + int(rand(6)); # 5-10 items
                    my $added_items = add_shop_inventory($town_name . " " . $shop->{shop_type}, 
                                                        $shop->{shop_type}, $inventory_size);
                    
                    print "    Added $added_items items to " . $shop->{shop_type} . "\n" if $ENV{DEBUG};
                }

                # Create road network within town
                lay_town_roads_blob(\%town_tiles, $center_x, $center_y, $rooms_ref);
                
                # After laying roads, update the road descriptions too
                for my $k (keys %town_tiles) {
                    next unless exists $rooms_ref->{$k} && $rooms_ref->{$k}->{region} eq "Road";
                    $rooms_ref->{$k}->{shortdesc} = "Town Road";
                    $rooms_ref->{$k}->{longdesc} = "You are on a cobblestone road in $town_name. The town bustles with activity around you.";
                }
                
                # Store town data and continue to next town
                push @$towns_ref, [$minx, $miny, $maxx-$minx+1, $maxy-$miny+1, $town_name];
                push @placed_towns, [$minx, $miny, \%town_tiles];
                last;
            }
        }
        
        if ($try >= $tries_per_town) {
            print "  Warning: Failed to place town #$t after $tries_per_town attempts\n" if $ENV{DEBUG};
        }
    }
    
    print "Successfully placed " . scalar(@placed_towns) . " towns\n" if $ENV{DEBUG};
    return scalar(@placed_towns);
}

# Helper function to generate specialized shops
sub generate_town_shops {
    my ($town_name, $region, $town_size, $town_shops, $rooms_ref) = @_;
    
    print "  Specializing shops for $town_name (region: $region, size: $town_size)\n" if $ENV{DEBUG};
    
    # Normalize region for consistency
    $region = "Grass" unless $region =~ /^(Grass|Forest|Hill|Swamp)$/;
    
    # Define shop type weighting based on town size with safety defaults
    my %shop_weights = (
        'General Store' => 3,  # Default, always available
        'Blacksmith'    => 2   # Common in all towns
    );
    
    # Add specialized shops based on town size
    if ($town_size >= 30) {
        # Large town - wide variety of shops
        $shop_weights{'Armory'} = 2;
        $shop_weights{'Magic Shop'} = 1;
        $shop_weights{'Potion Shop'} = 1;
        $shop_weights{'Tailor'} = 1;
        $shop_weights{'Adventurer\'s Outfitter'} = 1;
        $shop_weights{'Rare Goods Emporium'} = 1;
    } elsif ($town_size >= 15) {
        # Medium town - moderate variety
        $shop_weights{'Armory'} = 1;
        $shop_weights{'Tailor'} = 1;
    }
    
    # Region-specific specializations for accessible regions only
    if ($region eq 'Forest') {
        $shop_weights{'Herbalist'} = 2;
        $shop_weights{'Bowyer'} = 2;
        $shop_weights{'Fletcher'} = 1;
        $shop_weights{'Woodworker'} = 1;
    } elsif ($region eq 'Hill') {
        $shop_weights{'Miner\'s Supply'} = 1;
        $shop_weights{'Stoneworker'} = 1;
        $shop_weights{'Hunter\'s Lodge'} = 2;
    } elsif ($region eq 'Swamp') {
        $shop_weights{'Alchemist'} = 2;
        $shop_weights{'Potion Shop'} = 2;
        $shop_weights{'Herbalist'} = 1;
    } elsif ($region eq 'Grass') {
        # Default region gets farming/agriculture related shops
        $shop_weights{'Farmer\'s Market'} = 2;
        $shop_weights{'Leatherworker'} = 1;
    }
    
    # For towns near water (river or lake), add appropriate shops
    # Note: This would require checking nearby tiles, but for simplicity
    # we'll use a random chance to simulate this
    if (rand() < 0.25) {
        $shop_weights{'Fishing Supply'} = 2;
        $shop_weights{'Boat Builder'} = 1;
    }
    
    print "  Shop weights for $town_name: " . join(", ", map { "$_ => $shop_weights{$_}" } sort keys %shop_weights) . "\n" if $ENV{DEBUG};
    
    # Weighted shop selection - build the pool of available types
    my @shop_types = ();
    foreach my $shop_type (keys %shop_weights) {
        for (1..$shop_weights{$shop_type}) {
            push @shop_types, $shop_type;
        }
    }
    
    # Safety check - ensure we have shop types
    if (!@shop_types) {
        print "  WARNING: No shop types available for $town_name, adding default\n" if $ENV{DEBUG};
        push @shop_types, "General Store";
    }
    
    print "  Available shop types: " . join(", ", @shop_types) . "\n" if $ENV{DEBUG};
    
    # Collect shop room IDs
    my @shop_rooms = keys %$town_shops;
    
    # Track already used shop types to prevent duplicates
    my %used_types;
    
    # Prioritize more interesting shops first
    my @priority_shops = sort { 
        # General Store gets lowest priority
        return 1 if $a eq 'General Store';
        return -1 if $b eq 'General Store';
        # Specialized shops get higher priority
        return -1 if $a =~ /Magic|Rare|Alchemist/;
        return 1 if $b =~ /Magic|Rare|Alchemist/;
        # Default alphabetical
        return $a cmp $b;
    } @shop_types;
    
    # Ensure we have at least one General Store if there are multiple shops
    my $has_general_store = 0;
    
    # Assign shop types, prioritizing unique types
    foreach my $shop_room_id (@shop_rooms) {
        my $shop_type;
        
        # Force at least one General Store if we have multiple shops
        if (@shop_rooms > 1 && !$has_general_store && scalar(keys %used_types) == scalar(@shop_rooms) - 1) {
            $shop_type = "General Store";
            $has_general_store = 1;
        }
        # Otherwise, try to find an unused type
        else {
            # First try to pick from unused types
            my @available_types = grep { !$used_types{$_} } @priority_shops;
            
            # If all types are used or we're down to just General Store, allow reuse
            if (!@available_types) {
                @available_types = @priority_shops;
            }
            
            # Choose a type
            $shop_type = $available_types[int(rand(@available_types))];
            
            # Mark as General Store if it's the last shop and we don't have one yet
            if (scalar(keys %used_types) == scalar(@shop_rooms) - 1 && !$has_general_store) {
                $shop_type = "General Store";
                $has_general_store = 1;
            }
        }
        
        # Mark this type as used
        $used_types{$shop_type}++;
        
        # Safety check - skip if room doesn't exist
        next unless exists $rooms_ref->{$shop_room_id};
        
        my $room = $rooms_ref->{$shop_room_id};
        
        # Store shop type for later market generation
        $room->{shop_type} = $shop_type;
        
        # Format shop description with consistent naming
        $room->{shortdesc} = "$town_name $shop_type";
        $room->{longdesc} = "You are in the $town_name $shop_type. Various goods are displayed for sale.";
        
        print "  Assigned shop type '$shop_type' to shop at $shop_room_id\n" if $ENV{DEBUG};
    }
    
    # Print final shop distribution
    if ($ENV{DEBUG}) {
        print "  Final shop distribution in $town_name:\n";
        foreach my $type (sort keys %used_types) {
            print "    $type: $used_types{$type}\n";
        }
    }
    
    return 1;
}

sub update_room_description_from_feature {
    my ($room) = @_;
    
    # Skip if no feature is set or room is invalid
    return 0 unless $room && ref($room) eq 'HASH' && $room->{feature} && $room->{feature} ne '';
    
    # Get town/castle name for contextual descriptions
    my $town_name = $room->{town_name} || 'the town';
    my $castle_name = $room->{castle_name} || 'the castle';
    
    # Define appropriate descriptions based on feature type
    my %feature_descriptions = (
        # Town Features
        'Bank' => {
            short => "Town Bank",
            long => "You are inside the bank of $town_name. A clerk stands behind a counter, ready to handle your transactions."
        },
        'Shop' => {
            short => "General Store",
            long => "You are in a small shop in $town_name. Shelves are lined with wares and trinkets."
        },
        'Temple' => {
            short => "Temple",
            long => "You are in the temple of $town_name. The air is heavy with incense and the sound of soft prayers."
        },
        'Tavern' => {
            short => "Tavern",
            long => "You are in the local tavern of $town_name. The smell of ale and sound of laughter fill the air."
        },
        'Inn' => {
            short => "Inn",
            long => "You are in the inn of $town_name. A warm fire burns in the hearth and comfortable beds await weary travelers."
        },
        'Guild' => {
            short => "Adventurer's Guild",
            long => "You are in the Adventurer's Guild of $town_name. Maps and notices adorn the walls."
        },
        'Market' => {
            short => "Town Market",
            long => "You are in the bustling market of $town_name. Merchants hawk their wares from colorful stalls."
        },
        'Plaza' => {
            short => "Town Plaza",
            long => "You are in the central plaza of $town_name. People gather here to socialize and conduct business."
        },
        'House' => {
            short => "Village House",
            long => "You are outside a villager's house in $town_name. Smoke rises from the chimney."
        },
        'Yard' => {
            short => "Village Yard",
            long => "You are in an open space within $town_name. The area is grassy and quiet, with houses nearby."
        },
        
        # Castle Features
        'CastleRoom' => {
            short => "$castle_name Hall",
            long => "You are in a stone hall within $castle_name. The air is cool and echoes with distant footsteps."
        },
        'Keep' => {
            short => "$castle_name Keep",
            long => "You are in the central keep of $castle_name. The walls are thick stone, adorned with tapestries and weapons."
        },
        'Tower' => {
            short => "$castle_name Tower",
            long => "You are in one of ${castle_name}'s towers. Narrow windows offer a sweeping view of the lands below."
        },
        'ThroneRoom' => {
            short => "$castle_name Throne Room",
            long => "You stand in the grand throne room of $castle_name. Banners hang from the walls and a majestic throne sits at the far end."
        },
        'Drawbridge' => {
            short => "Castle Drawbridge",
            long => "A sturdy drawbridge spans the moat, leading to the gates of $castle_name."
        },
        
        # Cave/Dungeon Features
        'CaveMouth' => {
            short => "Cave Entrance",
            long => "A dark cave entrance gapes at the base of the mountain. The air is cool and musty."
        },
        'CaveEntrance' => {
            short => "Cave Entrance Chamber",
            long => "You stand in a natural chamber just inside the cave. Dim light filters in from the surface above."
        },
        'CaveTunnel' => {
            short => "Cave Tunnel",
            long => "You are in a winding cave tunnel. The walls glisten with moisture and strange fungi."
        },
        'CaveJunction' => {
            short => "Cave Junction",
            long => "Several cave passages meet here in a small chamber. Water drips from the ceiling."
        },
        'CaveCavern' => {
            short => "Underground Cavern",
            long => "You stand in a vast underground cavern. Stalactites hang from the ceiling like stone teeth."
        },
        'CaveShaft' => {
            short => "Cave Shaft",
            long => "A natural shaft plunges deeper into the earth. Rough handholds offer a way down."
        },
        'CaveDeadend' => {
            short => "Dead End",
            long => "The tunnel ends here at a solid rock wall. Ancient mineral deposits streak the stone."
        },
        'CaveLake' => {
            short => "Underground Lake",
            long => "You are at the edge of a still, underground lake. The water glows faintly in the darkness."
        },
        'DungeonEntrance' => {
            short => "Dungeon Entrance",
            long => "A heavy trapdoor in the ground leads down into darkness. The dungeon awaits below."
        },
        'DungeonChamber' => {
            short => "Dungeon Chamber",
            long => "You are in a stone chamber within the dungeon. Ancient torches flicker on the walls."
        },
        'DungeonCorridor' => {
            short => "Dungeon Corridor",
            long => "You are in a dank, narrow corridor deep beneath the earth. The air is thick and stale."
        },
        'DungeonCell' => {
            short => "Dungeon Cell",
            long => "A small cell branches off from the corridor. Rusty chains hang from the walls."
        },
        'DungeonGuardroom' => {
            short => "Guardroom",
            long => "This room once housed the dungeon guards. A broken table and chairs remain."
        },
        'DungeonPrison' => {
            short => "Prison Block",
            long => "Iron bars line the walls of this grim prison block. The cells are empty now."
        },
        'DungeonStairs' => {
            short => "Dungeon Stairs",
            long => "Stone steps spiral downward into deeper darkness. The air grows colder below."
        },
        'DungeonLanding' => {
            short => "Stair Landing",
            long => "You stand on a landing between dungeon levels. Passages lead in several directions."
        },
        'DungeonVault' => {
            short => "Dungeon Vault",
            long => "You have found the dungeon's vault. Ancient treasures and bones lie scattered about."
        },
        
        # Terrain Features
        'Road' => {
            short => "Country Road",
            long => "A well-traveled road stretches across the land, connecting distant towns and castles."
        },
        'Bridge' => {
            short => "Stone Bridge",
            long => "A sturdy stone bridge crosses the river here, allowing safe passage."
        },
        'MountainPass' => {
            short => "Mountain Pass",
            long => "A narrow path winds through the mountains, offering passage through the otherwise impassable terrain."
        },
        'Forest' => {
            short => "Dense Forest",
            long => "You are in a dense forest. Tall trees tower overhead, blocking most of the sunlight."
        },
        'Hill' => {
            short => "Rolling Hills",
            long => "You are on rolling hills. The landscape rises and falls gently around you."
        },
        'Swamp' => {
            short => "Murky Swamp",
            long => "You are in a murky swamp. The ground is soggy underfoot and mist limits visibility."
        },
        'Mountain' => {
            short => "Mountain Range",
            long => "Steep, rocky mountains rise up around you. The terrain is rugged and imposing."
        },
        'Grass' => {
            short => "Open Grassland",
            long => "You are in open grassland. The wind rustles through the tall grass."
        }
    );
    
    # Special case for shop types - use the specific shop type in the description if available
    if ($room->{feature} eq 'Shop' && $room->{shop_type}) {
        $room->{shortdesc} = "$town_name $room->{shop_type}";
        $room->{longdesc} = "You are in the $town_name $room->{shop_type}. Various goods are displayed for sale.";
        return 1;
    }
    
    # Update room description if we have a template for this feature
    if (exists $feature_descriptions{$room->{feature}}) {
        $room->{shortdesc} = $feature_descriptions{$room->{feature}}{short};
        $room->{longdesc} = $feature_descriptions{$room->{feature}}{long};
        return 1;
    }
    
    # Handle custom naming for house features if a house_name is set
    if ($room->{feature} eq 'House' && $room->{house_name}) {
        $room->{shortdesc} = $room->{house_name};
        $room->{longdesc} = "You are outside $room->{house_name} in $town_name. Smoke rises from the chimney.";
        return 1;
    }
    
    # If we're in a town but the feature isn't recognized, provide a default town description
    if ($room->{region} eq 'Town' && $room->{town_name}) {
        $room->{shortdesc} = "Village Street";
        $room->{longdesc} = "You are on a quiet street in $town_name. Thatched houses line the path.";
        return 1;
    }
    
    # No matching description found
    return 0;
}

sub find_nearest_landmark {
    my ($x, $y, $z) = @_;
    my @landmarks;
    for my $castle (@castles) {
        my ($cx, $cy, $cw, $ch, $cname) = @$castle;
        push @landmarks, [$cx+int($cw/2), $cy+int($ch/2), 0, "Castle", $cname];
    }
    for my $town (@towns) {
        my ($tx, $ty, $tw, $th, $tname) = @$town;
        push @landmarks, [$tx+int($tw/2), $ty+int($th/2), 0, "Town", $tname];
    }
    for my $key (keys %rooms) {
        my $r = $rooms{$key};
        if ($r->{region} eq "Lake" && $r->{lake_name} && $r->{lake_name} ne "") {
            push @landmarks, [$r->{x}, $r->{y}, $r->{z}, "Lake", $r->{lake_name}];
        }
        if ($r->{region} eq "River" && $r->{river_name} && $r->{river_name} ne "") {
            push @landmarks, [$r->{x}, $r->{y}, $r->{z}, "River", $r->{river_name}];
        }
    }
    for my $mc (@mountain_clusters) {
        my ($mx, $my, $mw, $mh, $mname) = @$mc;
        push @landmarks, [$mx+int($mw/2), $my+int($mh/2), 0, "Mountain", $mname];
    }
    my $min_dist = 1e9;
    my $best;
    for my $lm (@landmarks) {
        my ($lx, $ly, $lz, $type, $name) = @$lm;
        next unless defined $name && $name ne "";
        my $dist = abs($x - $lx) + abs($y - $ly);
        if ($dist < $min_dist) {
            $min_dist = $dist;
            $best = $lm;
        }
    }
    return $best;
}

sub lay_town_roads_blob {
    my ($town_tiles, $center_x, $center_y, $rooms_ref) = @_;

   
    my ($minx, $maxx, $miny, $maxy) = (1e9, -1e9, 1e9, -1e9);
    for my $k (keys %$town_tiles) {
        my ($x, $y, $z) = split /,/, $k;
        $minx = $x if $x < $minx;
        $maxx = $x if $x > $maxx;
        $miny = $y if $y < $miny;
        $maxy = $y if $y > $maxy;
    }

   
    my $road_count = 0;
    for my $k (keys %$town_tiles) {
        my ($x, $y, $z) = split /,/, $k;
        if ($y == $center_y || $x == $center_x) {
            next unless exists $rooms_ref->{$k};
            next if $rooms_ref->{$k}->{region} eq "Road";
            $rooms_ref->{$k}->{region} = "Road";
            $rooms_ref->{$k}->{feature} = "Road";
            $rooms_ref->{$k}->{impassable} = 0;
            $road_count++;
        }
    }

   
    my @edges = (
        [N => [map { [$_, $miny] } $minx..$maxx]],
        [S => [map { [$_, $maxy] } $minx..$maxx]],
        [W => [map { [$minx, $_] } $miny..$maxy]],
        [E => [map { [$maxx, $_] } $miny..$maxy]],
    );
    for my $edge (@edges) {
        my ($dir, $coords) = @$edge;
        my $has_road = 0;
        for my $c (@$coords) {
            my ($x, $y) = @$c;
            my $k = "$x,$y,0";
            if (exists $rooms_ref->{$k} && $rooms_ref->{$k}->{region} eq "Road") {
                $has_road = 1;
                last;
            }
        }
        unless ($has_road) {
           
            my $c = $coords->[int(rand(@$coords))];
            my ($x, $y) = @$c;
            my $k = "$x,$y,0";
            if (exists $rooms_ref->{$k}) {
                $rooms_ref->{$k}->{region} = "Road";
                $rooms_ref->{$k}->{feature} = "Road";
                $rooms_ref->{$k}->{impassable} = 0;
            }
        }
    }

   
    my $house_road_count = 0;
    my $house_count = 0;
    for my $k (keys %$town_tiles) {
        next unless exists $rooms_ref->{$k};
        my $room = $rooms_ref->{$k};
        next unless $room->{feature} eq "House";
        my ($x, $y, $z) = split /,/, $k;
        my $exit_count = scalar grep { defined $room->{exits}{$_} } qw(N S E W);
        next unless $exit_count > 0 && $exit_count <= 4;

       
        my @candidates = ([$x, $center_y], [$center_x, $y]);
        my ($best_x, $best_y, $best_dist) = ($x, $center_y, abs($y-$center_y));
        foreach my $c (@candidates) {
            my ($cx, $cy) = @$c;
            my $ckey = "$cx,$cy,$z";
            next unless $town_tiles->{$ckey};
            my $dist = abs($x-$cx) + abs($y-$cy);
            if ($dist < $best_dist) {
                $best_x = $cx; $best_y = $cy; $best_dist = $dist;
            }
        }
       
        my ($hx, $hy) = ($x, $y);
        my $road_iters = 0;
        my $max_road_iters = 100;
        while ($hx != $best_x && $road_iters++ < $max_road_iters) {
            $hx += ($best_x > $hx) ? 1 : -1;
            my $hkey = "$hx,$hy,$z";
            last if $rooms_ref->{$hkey}->{region} eq "Road";
            $rooms_ref->{$hkey}->{region} = "Road";
            $rooms_ref->{$hkey}->{feature} = "Road";
            $rooms_ref->{$hkey}->{impassable} = 0;
            $house_road_count++;
        }
        $road_iters = 0;
        while ($hy != $best_y && $road_iters++ < $max_road_iters) {
            $hy += ($best_y > $hy) ? 1 : -1;
            my $hkey = "$hx,$hy,$z";
            last if $rooms_ref->{$hkey}->{region} eq "Road";
            $rooms_ref->{$hkey}->{region} = "Road";
            $rooms_ref->{$hkey}->{feature} = "Road";
            $rooms_ref->{$hkey}->{impassable} = 0;
            $house_road_count++;
        }
        $house_count++;
    }
}

sub find_nearest_road_edge {
    my ($tx, $ty, $tw, $th, $rooms_ref, $dir) = @_;
    my @candidates;
    if ($dir eq 'N') {
        for my $x ($tx .. $tx+$tw-1) {
            my $key = "$x,$ty,0";
            push @candidates, [$x, $ty] if exists $rooms_ref->{$key} && $rooms_ref->{$key}->{region} eq "Road";
        }
    } elsif ($dir eq 'S') {
        for my $x ($tx .. $tx+$tw-1) {
            my $key = "$x,".($ty+$th-1).",0";
            push @candidates, [$x, $ty+$th-1] if exists $rooms_ref->{$key} && $rooms_ref->{$key}->{region} eq "Road";
        }
    } elsif ($dir eq 'W') {
        for my $y ($ty .. $ty+$th-1) {
            my $key = "$tx,$y,0";
            push @candidates, [$tx, $y] if exists $rooms_ref->{$key} && $rooms_ref->{$key}->{region} eq "Road";
        }
    } elsif ($dir eq 'E') {
        for my $y ($ty .. $ty+$th-1) {
            my $key = "".($tx+$tw-1).",$y,0";
            push @candidates, [$tx+$tw-1, $y] if exists $rooms_ref->{$key} && $rooms_ref->{$key}->{region} eq "Road";
        }
    }
    return @candidates ? @candidates[int(rand(@candidates))] : ();
}

sub connect_town_edges {
    my ($towns_ref, $rooms_ref) = @_;
    my @landmarks;
    
    # Track used connection points for each landmark
    my %used_connections;
    
    # Collect all landmarks with their center points
    for my $i (0..$#$towns_ref) {
        my ($tx, $ty, $tw, $th, $town_name) = @{$towns_ref->[$i]};
        # Add connection points for each side of the town
        push @landmarks, {
            type => 'Town',
            name => $town_name,
            x => $tx + int($tw/2),
            y => $ty + int($th/2),
            width => $tw,
            height => $th,
            left => $tx,
            right => $tx + $tw,
            top => $ty,
            bottom => $ty + $th,
            connected => 0
        };
    }
    
    for my $castle (@castles) {
        my ($cx, $cy, $cw, $ch, $castle_name) = @$castle;
        push @landmarks, {
            type => 'Castle',
            name => $castle_name,
            x => $cx + int($cw/2),
            y => $cy + int($ch/2),
            width => $cw,
            height => $ch,
            left => $cx,
            right => $cx + $cw,
            top => $cy,
            bottom => $cy + $ch,
            connected => 0
        };
    }
    
    # Build Minimum Spanning Tree using Prim's algorithm
    my @mst;
    my $first = $landmarks[0];
    $first->{connected} = 1;
    
    while (1) {
        my $best_dist = 1e9;
        my ($best_from, $best_to);
        my $best_side_from;
        my $best_side_to;
        
        # Find closest pair of landmarks where one is connected and one isn't
        for my $from (@landmarks) {
            next unless $from->{connected};
            for my $to (@landmarks) {
                next if $to->{connected};
                
                # Check each possible connection side pair
                my @from_sides = (
                    ['left',   $from->{left},  $from->{y}],
                    ['right',  $from->{right}, $from->{y}],
                    ['top',    $from->{x},     $from->{top}],
                    ['bottom', $from->{x},     $from->{bottom}]
                );
                
                my @to_sides = (
                    ['left',   $to->{left},  $to->{y}],
                    ['right',  $to->{right}, $to->{y}],
                    ['top',    $to->{x},     $to->{top}],
                    ['bottom', $to->{x},     $to->{bottom}]
                );
                
                for my $from_side (@from_sides) {
                    next if $used_connections{"$from->{name}|$from_side->[0]"};
                    for my $to_side (@to_sides) {
                        next if $used_connections{"$to->{name}|$to_side->[0]"};
                        
                        my $dist = abs($from_side->[1] - $to_side->[1]) + 
                                 abs($from_side->[2] - $to_side->[2]);
                        
                        if ($dist < $best_dist) {
                            $best_dist = $dist;
                            $best_from = $from;
                            $best_to = $to;
                            $best_side_from = $from_side->[0];
                            $best_side_to = $to_side->[0];
                        }
                    }
                }
            }
        }
        
        last unless $best_from && $best_to;
        
        # Mark connection points as used
        $used_connections{"$best_from->{name}|$best_side_from"} = 1;
        $used_connections{"$best_to->{name}|$best_side_to"} = 1;
        
        # Add the road connection
        push @mst, [$best_from, $best_to];
        $best_to->{connected} = 1;
        
        
        # Get connection coordinates based on sides
        my ($x1, $y1) = get_connection_point($best_from, $best_side_from);
        my ($x2, $y2) = get_connection_point($best_to, $best_side_to);
        
        # Add some natural variation to avoid straight lines
        my $dx = $x2 - $x1;
        my $dy = $y2 - $y1;
        my $dist = sqrt($dx*$dx + $dy*$dy);
        
        # Create waypoints for a more natural path
        my @waypoints = ([$x1, $y1]);
        
        # Add 1-3 waypoints for longer roads
        if ($dist > 20) {
            my $num_points = 1 + int(rand(3));
            for (1..$num_points) {
                my $progress = $_ / ($num_points + 1);
                my $base_x = $x1 + $dx * $progress;
                my $base_y = $y1 + $dy * $progress;
                
                # Add random offset perpendicular to road direction
                my $perpendicular_dist = (rand() - 0.5) * min(10, $dist * 0.2);
                my $nx = $base_x + $perpendicular_dist * (-$dy/$dist);
                my $ny = $base_y + $perpendicular_dist * ($dx/$dist);
                
                push @waypoints, [$nx, $ny];
            }
        }
        
        push @waypoints, [$x2, $y2];
        
        # Connect waypoints
        for my $i (0..$#waypoints-1) {
            draw_road($waypoints[$i]->[0], $waypoints[$i]->[1], 
                     $waypoints[$i+1]->[0], $waypoints[$i+1]->[1]);
        }
    }
}

# Helper function to get connection point coordinates
sub get_connection_point {
    my ($landmark, $side) = @_;
    
    if ($side eq 'left') {
        return ($landmark->{left}, $landmark->{y});
    }
    elsif ($side eq 'right') {
        return ($landmark->{right}, $landmark->{y});
    }
    elsif ($side eq 'top') {
        return ($landmark->{x}, $landmark->{top});
    }
    elsif ($side eq 'bottom') {
        return ($landmark->{x}, $landmark->{bottom});
    }
}

sub perlin_value_noise {
    my ($x, $y, $seed) = @_;
   
    my $n = int($x*73856093) ^ int($y*19349663) ^ int($seed);
    $n = ($n << 13) ^ $n;
    return 1.0 - (($n * ($n * $n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0;
}

sub smooth_noise {
    my ($x, $y, $seed) = @_;
    my $ix = int($x);
    my $iy = int($y);
    my $fx = $x - $ix;
    my $fy = $y - $iy;

   
    my $v00 = perlin_value_noise($ix,     $iy,     $seed);
    my $v10 = perlin_value_noise($ix + 1, $iy,     $seed);
    my $v01 = perlin_value_noise($ix,     $iy + 1, $seed);
    my $v11 = perlin_value_noise($ix + 1, $iy + 1, $seed);

    my $i1 = $v00 * (1 - $fx) + $v10 * $fx;
    my $i2 = $v01 * (1 - $fx) + $v11 * $fx;
    return $i1 * (1 - $fy) + $i2 * $fy;
}

sub generate_mountains {
    my $seed = int(rand(1000000));
    my $mountain_area_left = $mountain_area;
    my $max_ranges = $mountain_clusters_count;
    my $min_length = int(min($WIDTH, $HEIGHT) * 0.7);
    my $max_length = int(max($WIDTH, $HEIGHT) * 1.5);
    my $max_width = int(max($WIDTH, $HEIGHT) * 0.10);
    $max_width = 2 if $max_width < 2;
    my $min_width = 2;
    @mountain_clusters = ();
    $mountain_rooms = 0;

    my @range_centers;
    my @shuffled_mountain_names = @mountain_names;
    @shuffled_mountain_names = sort { rand() <=> rand() } @shuffled_mountain_names;
    my $mountain_name_idx = 0;

    RANGE: for (1..$max_ranges) {
        last if $mountain_area_left <= 0;
        my $tries = 0;
        my ($start_x, $start_y, $ok);
        do {
            $start_x = int(rand($WIDTH * 0.8)) + int($WIDTH * 0.1);
            $start_y = int(rand($HEIGHT * 0.8)) + int($HEIGHT * 0.1);
            $ok = 1;
            for my $c (@range_centers) {
                my ($cx, $cy) = @$c;
                my $dist = sqrt(($start_x-$cx)**2 + ($start_y-$cy)**2);
                if ($dist < $WIDTH/2.5) { $ok = 0; last; }
            }
            $tries++;
        } while (!$ok && $tries < 30);
        next unless $ok;
        push @range_centers, [$start_x, $start_y];

        my $length = $min_length + int(rand($max_length - $min_length + 1));
        my $width = $max_width;
        my $angle = rand() * 2 * pi;
        my $scale = 0.07 + rand(0.04);

        my @ridge;
        my ($x, $y) = ($start_x, $start_y);

        my $gap_every = 8 + int(rand(8));

        for (my $i = 0; $i < $length; $i++) {
            last if $x < 0 || $x >= $WIDTH || $y < 0 || $y >= $HEIGHT;
           
            if ($i % $gap_every == 0 && $i > 0) {
                $x += cos($angle) * 1.5;
                $y += sin($angle) * 1.5;
                next;
            }
           
            my $w_noise = 0.6 + 0.4 * simple_noise($x*$scale, $y*$scale, $seed+$i);
            my $w = int($width * $w_noise);
            $w = $min_width if $w < $min_width;
            $w = $max_width if $w > $max_width;
            push @ridge, [int($x+0.5), int($y+0.5), $w, $angle];

           
            my $n = simple_noise($x*$scale, $y*$scale, $seed+$i*2);
            $angle += $n * 1.2 + (rand()-0.5)*0.2;

           
            $x += cos($angle) * (1 + rand()*0.5);
            $y += sin($angle) * (1 + rand()*0.5);

           
            if (rand() < 0.03 && $i > $length/3 && $max_ranges > 1) {
                my $branch_angle = $angle + (rand() < 0.5 ? pi/3 : -pi/3);
                my $branch_len = int($length * (0.15 + rand()*0.15));
                my $branch_x = $x;
                my $branch_y = $y;
                my @branch_ridge;
                for (my $j = 0; $j < $branch_len; $j++) {
                    last if $branch_x < 0 || $branch_x >= $WIDTH || $branch_y < 0 || $branch_y >= $HEIGHT;
                    my $bw_noise = 0.6 + 0.4 * simple_noise($branch_x*$scale, $branch_y*$scale, $seed+$i*100+$j);
                    my $bw = int($width * $bw_noise * 0.7);
                    $bw = $min_width if $bw < $min_width;
                    $bw = $max_width if $bw > $max_width;
                    push @branch_ridge, [int($branch_x+0.5), int($branch_y+0.5), $bw, $branch_angle];
                    my $bn = simple_noise($branch_x*$scale, $branch_y*$scale, $seed+$i*200+$j*2);
                    $branch_angle += $bn * 1.0 + (rand()-0.5)*0.2;
                    $branch_x += cos($branch_angle) * (1 + rand()*0.5);
                    $branch_y += sin($branch_angle) * (1 + rand()*0.5);
                }
                push @ridge, @branch_ridge;
            }
            last if $mountain_area_left <= 0;
        }

       
        my ($ex, $ey) = @{$ridge[-1]}[0,1];
        my ($dx, $dy) = (0, 0);
        if ($ex < $WIDTH/2) { $dx = -1; }
        else { $dx = 1; }
        if ($ey < $HEIGHT/2) { $dy = -1; }
        else { $dy = 1; }
        for (1..int($WIDTH/10)) {
            $ex += $dx;
            $ey += $dy;
            last if $ex < 0 || $ex >= $WIDTH || $ey < 0 || $ey >= $HEIGHT;
            push @ridge, [$ex, $ey, $min_width, $angle];
        }

       
        my $mountain_range_name = $shuffled_mountain_names[$mountain_name_idx++ % @shuffled_mountain_names];

       
        my $cluster_rooms = 0;
        my ($minx, $maxx, $miny, $maxy) = ($WIDTH, 0, $HEIGHT, 0);

        for my $i (0..$#ridge) {
            my ($sx, $sy, $w, $angle) = @{ $ridge[$i] };
            my $half_width = int($w/2);
            for my $offset (-$half_width..$half_width) {
                my $wx = int($sx + cos($angle + pi/2) * $offset + 0.5);
                my $wy = int($sy + sin($angle + pi/2) * $offset + 0.5);
                next if $wx < 0 || $wx >= $WIDTH || $wy < 0 || $wy >= $HEIGHT;
                my $key = "$wx,$wy,0";
                next unless exists $rooms{$key};
                next if $rooms{$key}->{impassable};
                $rooms{$key}->{region} = "Mountain";
                $rooms{$key}->{feature} = "Mountain";
                $rooms{$key}->{impassable} = 1;
                $rooms{$key}->{exits} = {};
                $rooms{$key}->{mountain_name} = $mountain_range_name;
                my $dist_from_center = abs($offset) / ($half_width+1);
                $elevation{"$wx,$wy"} = 1.5 + (1.0 - $dist_from_center) * 0.7 + rand()*0.2;
                $biome{"$wx,$wy"} = 'mountain';
                $mountain_area_left--;
                $mountain_rooms++;
                $cluster_rooms++;
                $minx = $wx if $wx < $minx;
                $maxx = $wx if $wx > $maxx;
                $miny = $wy if $wy < $miny;
                $maxy = $wy if $wy > $maxy;
                last if $mountain_area_left <= 0;
            }
        }

        if ($cluster_rooms > 0) {
            push @mountain_clusters, [$minx, $miny, $maxx-$minx+1, $maxy-$miny+1, $mountain_range_name];
        }
    }
    $mountain_clusters_count = scalar(@mountain_clusters);
}

sub generate_lakes {
    my $lake_area_left = $lake_area;
    my $target_clusters = $lake_clusters_count;
    @lake_clusters = ();
    my $placed = 0;
    $lake_rooms = 0;  # Reset global counter

    # Calculate constraints based on map dimensions
    my $min_lake_size = max(15, int($WIDTH * $HEIGHT * 0.0005));
    my $max_lake_size = max(40, int($WIDTH * $HEIGHT * 0.002));
    my $min_lake_dist = max(8, int(min($WIDTH, $HEIGHT) / 15));

    # First try placing lakes near mountains for realism
    for my $mc (@mountain_clusters) {
        last if $placed >= $target_clusters || $lake_area_left <= 0;
        my ($mx, $my, $mw, $mh, $mname) = @$mc;
        
        # Try each cardinal direction from mountain range
        for my $attempt (0..3) {
            my ($x0, $y0);
            if ($attempt == 0) {    # North
                $x0 = $mx + int(rand($mw));
                $y0 = $my - int(rand(4)) - 2;
            } elsif ($attempt == 1) { # South 
                $x0 = $mx + int(rand($mw));
                $y0 = $my + $mh + int(rand(4));
            } elsif ($attempt == 2) { # West
                $x0 = $mx - int(rand(4)) - 2;
                $y0 = $my + int(rand($mh));
            } else {                # East
                $x0 = $mx + $mw + int(rand(4));
                $y0 = $my + int(rand($mh));
            }
            
            next if $x0 < 3 || $x0 >= $WIDTH-3 || $y0 < 3 || $y0 >= $HEIGHT-3;
            
            # Check minimum distance from other lakes
            my $too_close = 0;
            for my $lc (@lake_clusters) {
                my ($lx, $ly, $lw, $lh) = @$lc;
                my $dist = sqrt(($x0-$lx)**2 + ($y0-$ly)**2);
                if ($dist < $min_lake_dist) {
                    $too_close = 1;
                    last;
                }
            }
            next if $too_close;

            # Generate lake using cellular automata
            my %lake_points;
            my @frontier = ([$x0, $y0]);
            $lake_points{"$x0,$y0"} = 1;
            my $filled = 1;
            my $iterations = 0;
            my $max_iterations = $max_lake_size * 10;
            
            while (@frontier && $filled < $max_lake_size && $lake_area_left > 0 && $iterations++ < $max_iterations) {
                my $idx = int(rand(@frontier));
                my ($x, $y) = @{splice(@frontier, $idx, 1)};
                
                for my $d ([0,1],[1,0],[0,-1],[-1,0],[1,1],[-1,1],[1,-1],[-1,-1]) {
                    my ($dx, $dy) = @$d;
                    my ($nx, $ny) = ($x+$dx, $y+$dy);
                    
                    next if $nx < 2 || $nx >= $WIDTH-2 || $ny < 2 || $ny >= $HEIGHT-2;
                    next if $lake_points{"$nx,$ny"};
                    
                    my $dist_from_center = sqrt(($nx-$x0)**2 + ($ny-$y0)**2);
                    next if $dist_from_center > sqrt($max_lake_size);
                    
                    my $key = "$nx,$ny,0";
                    next unless exists $rooms{$key};
                    next unless $rooms{$key}->{region} eq "Grass";
                    
                    my $water_adj = 0;
                    my $mountain_adj = 0;
                    
                    for my $cd ([-1,0],[1,0],[0,-1],[0,1]) {
                        my $cx = $nx + $cd->[0];
                        my $cy = $ny + $cd->[1];
                        my $ckey = "$cx,$cy,0";
                        next unless exists $rooms{$ckey};
                        
                        if ($rooms{$ckey}->{region} eq "Mountain") {
                            $mountain_adj++;
                        } elsif ($rooms{$ckey}->{region} =~ /^(Lake|River)$/) {
                            $water_adj++;
                        }
                    }
                    
                    next if $water_adj > 1;
                    next if $mountain_adj > 2;
                    
                    my $prob = (abs($dx) + abs($dy) == 1) ? 0.85 : 0.65;
                    $prob *= 1.2 if $mountain_adj > 0;
                    
                    next if rand() > $prob;
                    
                    $lake_points{"$nx,$ny"} = 1;
                    push @frontier, [$nx, $ny];
                    $filled++;
                    last if $filled >= $max_lake_size;
                }
            }
            
            next unless $filled >= $min_lake_size;
            
            # Assign lake properties
            my $lake_name = $lake_names[$placed % @lake_names];
            my ($minx, $maxx, $miny, $maxy) = ($WIDTH, 0, $HEIGHT, 0);
            my $cluster_rooms = 0;
            
            for my $k (keys %lake_points) {
                my ($lx, $ly) = split /,/, $k;
                my $key = "$lx,$ly,0";
                next unless exists $rooms{$key};
                next unless $rooms{$key}->{region} eq "Grass";
                
                $rooms{$key}->{region} = "Lake";
                $rooms{$key}->{feature} = "Lake";
                $rooms{$key}->{lake_name} = $lake_name;
                $rooms{$key}->{impassable} = 1;
                $rooms{$key}->{exits} = {};
                
                $minx = $lx if $lx < $minx;
                $maxx = $lx if $lx > $maxx;
                $miny = $ly if $ly < $miny;
                $maxy = $ly if $ly > $maxy;
                
                $lake_area_left--;
                $lake_rooms++;
                $cluster_rooms++;
            }
            
            if ($cluster_rooms > 0) {
                push @lake_clusters, [$minx, $miny, $maxx-$minx+1, $maxy-$miny+1, $lake_name];
                $placed++;
                last;
            }
        }
    }
    
    # Fill remaining lake quota with standalone lakes
    my $max_attempts = ($target_clusters - $placed) * 10;
    my $attempts = 0;
    
    while ($placed < $target_clusters && $lake_area_left > 0 && $attempts++ < $max_attempts) {
        my $x0 = int(rand($WIDTH-10)) + 5;
        my $y0 = int(rand($HEIGHT-10)) + 5;
        
        # Check minimum distance from other lakes
        my $too_close = 0;
        for my $lc (@lake_clusters) {
            my ($lx, $ly, $lw, $lh) = @$lc;
            my $dist = sqrt(($x0-$lx)**2 + ($y0-$ly)**2);
            if ($dist < $min_lake_dist) {
                $too_close = 1;
                last;
            }
        }
        next if $too_close;
        
        my %lake_points;
        my @frontier = ([$x0, $y0]);
        $lake_points{"$x0,$y0"} = 1;
        my $filled = 1;
        
        my $iterations = 0;
        my $max_iterations = $max_lake_size * 10;
        
        while (@frontier && $filled < $max_lake_size && $lake_area_left > 0 && $iterations++ < $max_iterations) {
            my $idx = int(rand(@frontier));
            my ($x, $y) = @{splice(@frontier, $idx, 1)};
            
            for my $d ([0,1],[1,0],[0,-1],[-1,0],[1,1],[-1,1],[1,-1],[-1,-1]) {
                my ($dx, $dy) = @$d;
                my ($nx, $ny) = ($x+$dx, $y+$dy);
                
                next if $nx < 2 || $nx >= $WIDTH-2 || $ny < 2 || $ny >= $HEIGHT-2;
                next if $lake_points{"$nx,$ny"};
                
                my $dist_from_center = sqrt(($nx-$x0)**2 + ($ny-$y0)**2);
                next if $dist_from_center > sqrt($max_lake_size);
                
                my $key = "$nx,$ny,0";
                next unless exists $rooms{$key};
                next unless $rooms{$key}->{region} eq "Grass";
                
                my $prob = (abs($dx) + abs($dy) == 1) ? 0.85 : 0.65;
                next if rand() > $prob;
                
                $lake_points{"$nx,$ny"} = 1;
                push @frontier, [$nx, $ny];
                $filled++;
                last if $filled >= $max_lake_size;
            }
        }
        
        next unless $filled >= $min_lake_size;
        
        my $lake_name = $lake_names[$placed % @lake_names];
        my ($minx, $maxx, $miny, $maxy) = ($WIDTH, 0, $HEIGHT, 0);
        my $cluster_rooms = 0;
        
        for my $k (keys %lake_points) {
            my ($lx, $ly) = split /,/, $k;
            my $key = "$lx,$ly,0";
            next unless exists $rooms{$key};
            next unless $rooms{$key}->{region} eq "Grass";
            
            $rooms{$key}->{region} = "Lake";
            $rooms{$key}->{feature} = "Lake";
            $rooms{$key}->{lake_name} = $lake_name;
            $rooms{$key}->{impassable} = 1;
            $rooms{$key}->{exits} = {};
            
            $minx = $lx if $lx < $minx;
            $maxx = $lx if $lx > $maxx;
            $miny = $ly if $ly < $miny;
            $maxy = $ly if $ly > $maxy;
            
            $lake_area_left--;
            $lake_rooms++;
            $cluster_rooms++;
        }
        
        if ($cluster_rooms > 0) {
            push @lake_clusters, [$minx, $miny, $maxx-$minx+1, $maxy-$miny+1, $lake_name];
            $placed++;
        }
    }
    
    $lake_clusters_count = $placed;
}

sub clamp {
    my ($v, $min, $max) = @_;
    $v = $min if $v < $min;
    $v = $max if $v > $max;
    return $v;
}

sub draw_river {
    my ($x1, $y1, $x2, $y2) = @_;
    my ($x, $y) = ($x1, $y1);
    my $steps = 0;
    while ($x != $x2 || $y != $y2) {
        my $key = "$x,$y,0";
        if (exists $rooms{$key} && $rooms{$key}->{region} eq "Grass") {
            $rooms{$key}->{region} = "River";
            $rooms{$key}->{feature} = "River";
            $rooms{$key}->{impassable} = 1;
            $rooms{$key}->{exits} = {};
        }
       
        if (abs($x2-$x) > abs($y2-$y)) {
            $x += $x2 > $x ? 1 : -1;
        } elsif ($y != $y2) {
            $y += $y2 > $y ? 1 : -1;
        }
       
        $x += int(rand(3))-1 if rand() < 0.3;
        $y += int(rand(3))-1 if rand() < 0.3;
        $x = clamp($x,0,$WIDTH-1);
        $y = clamp($y,0,$HEIGHT-1);
        last if ++$steps > $WIDTH + $HEIGHT;
    }
}

sub draw_river_named {
    my ($x1, $y1, $x2, $y2, $river_name) = @_;
    my ($x, $y) = ($x1, $y1);
    my $steps = 0;
    while ($x != $x2 || $y != $y2) {
        my $key = "$x,$y,0";
        if (exists $rooms{$key} && $rooms{$key}->{region} eq "Grass") {
            $rooms{$key}->{region} = "River";
            $rooms{$key}->{feature} = "River";
            $rooms{$key}->{impassable} = 1;
            $rooms{$key}->{exits} = {};
            $rooms{$key}->{river_name} = $river_name;
        }
       
        if (abs($x2-$x) > abs($y2-$y)) {
            $x += $x2 > $x ? 1 : -1;
        } elsif ($y != $y2) {
            $y += $y2 > $y ? 1 : -1;
        }
       
        $x += int(rand(3))-1 if rand() < 0.3;
        $y += int(rand(3))-1 if rand() < 0.3;
        $x = clamp($x,0,$WIDTH-1);
        $y = clamp($y,0,$HEIGHT-1);
        last if ++$steps > $WIDTH + $HEIGHT;
    }
}

sub is_empty_for_town {
    my ($room) = @_;
    return $room->{region} eq "Grass" || $room->{region} eq "Yard";
}
sub is_empty_for_castle {
    my ($room) = @_;
    return $room->{region} eq "Grass";
}

sub get_elevation_at {
    my ($x, $y) = @_;
    return $elevation{"$x,$y"} // 0.0;
}

sub get_biome_at {
    my ($x, $y) = @_;
    return $biome{"$x,$y"} // 'grass';
}

sub get_biome_properties {
    my ($biome_type) = @_;
    return $BIOME_TYPES{$biome_type} // $BIOME_TYPES{'grass'};
}

sub generate_elevation_and_biome {
    my ($width, $height, $elev_seed, $biome_seed, $elevation_ref, $biome_ref) = @_;

    # Normalize seeds
    my $norm_elev_seed = ($elev_seed // 0) % (2 * pi);
    my $norm_biome_seed = ($biome_seed // 0) % (2 * pi);
    
    # Generate base elevation with multiple octaves of noise
    for my $y (0..$height-1) {
        for my $x (0..$width-1) {
            # Use multiple octaves with different frequencies for more natural terrain
            my $elev = 0.0;
            $elev += 1.0 * simple_noise($x/50, $y/50, $norm_elev_seed);      # Large features
            $elev += 0.5 * simple_noise($x/25, $y/25, $norm_elev_seed + 1);  # Medium features
            $elev += 0.25 * simple_noise($x/12.5, $y/12.5, $norm_elev_seed + 2); # Small features
            
            # Normalize to [-1,1] range
            $elev = ($elev / 1.75);
            
            $elevation_ref->{"$x,$y"} = $elev;
        }
    }

    # Process existing terrain features to adjust elevation
    for my $y (0..$height-1) {
        for my $x (0..$width-1) {
            my $key = "$x,$y,0";
            if (exists $rooms{$key}) {
                if ($rooms{$key}->{region} eq "Mountain") {
                    $elevation_ref->{"$x,$y"} += 1.5;  # Mountains are high
                } elsif ($rooms{$key}->{region} eq "Lake") {
                    $elevation_ref->{"$x,$y"} -= 1.2;  # Lakes are low
                } elsif ($rooms{$key}->{region} eq "River") {
                    $elevation_ref->{"$x,$y"} -= 0.8;  # Rivers are in valleys
                } elsif ($rooms{$key}->{region} eq "Hill") {
                    $elevation_ref->{"$x,$y"} += 0.5;  # Hills are moderate height
                }
            }
        }
    }

    # Generate environmental factors for biome determination
    my %temperature;
    my %moisture;
    
    for my $y (0..$height-1) {
        for my $x (0..$width-1) {
            # Temperature varies with latitude (y) and elevation
            my $temp = 1.0 - (abs($y - $height/2) / ($height/2));  # Base on latitude
            $temp -= $elevation_ref->{"$x,$y"} * 0.3;  # Higher is colder
            
            # Add some noise
            $temp += 0.2 * simple_noise($x/30, $y/30, $norm_biome_seed);
            
            # Moisture based on noise and elevation
            my $moist = 0.5 + 0.5 * simple_noise($x/40, $y/40, $norm_biome_seed + 1);
            $moist *= (1.0 - abs($elevation_ref->{"$x,$y"}));  # Extremes are drier
            
            $temperature{"$x,$y"} = $temp;
            $moisture{"$x,$y"} = $moist;
        }
    }

    # Determine biomes based on elevation, temperature, and moisture
    for my $y (0..$height-1) {
        for my $x (0..$width-1) {
            my $elev = $elevation_ref->{"$x,$y"};
            my $temp = $temperature{"$x,$y"};
            my $moist = $moisture{"$x,$y"};
            
            my $key = "$x,$y,0";
            my $region = exists $rooms{$key} ? $rooms{$key}->{region} : '';
            
            # Set biome based on existing region first
            my $biome = 
                $region eq "Mountain" ? 'mountain' :
                $region eq "Lake" ? 'lake' :
                $region eq "River" ? 'river' :
                $region eq "Forest" ? 'forest' :
                $region eq "Hill" ? 'hill' :
                $region eq "Swamp" ? 'swamp' :
                undef;
            
            # If no specific region, determine biome from environmental factors
            unless ($biome) {
                $biome = 
                    ($elev > 0.6) ? 'mountain' :
                    ($elev < -0.3) ? 'lake' :
                    ($moist > 0.7 && $temp > 0.4) ? 'forest' :
                    ($elev > 0.2 && $moist < 0.6) ? 'hill' :
                    ($moist > 0.8 && $elev < 0.0) ? 'swamp' :
                    'grass';
            }
            
            $biome_ref->{"$x,$y"} = $biome;
            
            # Store the biome data in the room structure
            if (exists $rooms{$key}) {
                $rooms{$key}->{elevation} = $elev;
                $rooms{$key}->{biome_data} = substr($biome . (' ' x 8), 0, 8);
            }
        }
    }
}

sub place_biomes {
    my $preset = $biome_presets{$biome_balance} // $biome_presets{default};

    my $total_grass = scalar(grep { $rooms{$_}->{region} eq "Grass" } keys %rooms);
    my $target_forest = int($total_grass * 0.30);
    my $target_hill = int($total_grass * 0.25);
    my $target_swamp = int($total_grass * 0.15);

    my %visited;
    my @biome_types = (
        { type => 'forest', region => 'Forest', feature => 'Forest', target => $target_forest },
        { type => 'hill',   region => 'Hill',   feature => 'Hill',   target => $target_hill },
        { type => 'swamp',  region => 'Swamp',  feature => 'Swamp',  target => $target_swamp }
    );

    my %biome_stats;
    
    for my $biome (@biome_types) {
        my $type = $biome->{type};
        my $region = $biome->{region};
        my $feature = $biome->{feature};
        my $target = $biome->{target};
        my $patches = 0;
        my $total_placed = 0;
        
        while ($total_placed < $target) {
            my @candidates;
            for my $key (@room_keys) {
                next if $visited{$key};
                my $room = $rooms{$key};
                next unless $room->{region} eq "Grass";
                my $bio = $biome{"$room->{x},$room->{y}"};
                next unless defined $bio && $bio eq $type;
                push @candidates, $key;
            }
            
            last unless @candidates;
            
            my $start = $candidates[int(rand(@candidates))];
            next if $visited{$start};
            
            my $patch_size = $preset->{patch_min} + 
                           int(rand($preset->{patch_max} - $preset->{patch_min} + 1));
            $patch_size = min($patch_size, $target - $total_placed);
            
            my @frontier = ($start);
            my $grown = 0;
            my %patch_visited;
            
            while (@frontier && $grown < $patch_size) {
                my $idx = int(rand(@frontier));
                my $cur = splice(@frontier, $idx, 1);
                next if $patch_visited{$cur}++;
                
                my $r = $rooms{$cur};
                next unless $r->{region} eq "Grass";
                
                $r->{region} = $region;
                $r->{feature} = $feature;
                $visited{$cur} = 1;
                $grown++;
                $total_placed++;

                my ($x, $y, $z) = ($r->{x}, $r->{y}, $r->{z});
                
                for my $d ([0,1],[1,0],[0,-1],[-1,0],[1,1],[-1,1],[1,-1],[-1,-1]) {
                    my ($nx, $ny) = ($x+$d->[0], $y+$d->[1]);
                    my $nkey = "$nx,$ny,$z";
                    next if $patch_visited{$nkey};
                    next unless exists $rooms{$nkey};
                    my $nr = $rooms{$nkey};
                    next unless $nr->{region} eq "Grass";
                    my $nbio = $biome{"$nx,$ny"};
                    next unless defined $nbio && $nbio eq $type;
                    
                    push @frontier, $nkey if rand() < 0.85;
                }
            }
            $patches++ if $grown > 0;
        }
        
        $biome_stats{$region} = {
            patches => $patches,
            rooms => $total_placed,
            target => $target
        };
        
    }
}

sub simple_noise {
    my ($x, $y, $seed) = @_;
    
    # Get integer coordinates and fractional parts
    my $x0 = int($x);
    my $y0 = int($y);
    my $x1 = $x0 + 1;
    my $y1 = $y0 + 1;
    
    # Get fractional parts
    my $sx = $x - $x0;
    my $sy = $y - $y0;
    
    # Improved smoothing using cubic function
    $sx = $sx * $sx * (3 - 2 * $sx);
    $sy = $sy * $sy * (3 - 2 * $sy);
    
    # Generate pseudo-random gradients for each corner using hash function
    sub get_gradient {
        my ($x, $y, $seed) = @_;
        my $hash = ($x * $HASH_PRIME) ^ ($y * $HASH_PRIME) ^ int($seed * $HASH_PRIME);
        $hash = ($hash * $hash * $hash) % $mod_prime;
        my $angle = ($hash / $mod_prime) * 2 * pi;
        return (cos($angle), sin($angle));
    }
    
    # Get gradients for each corner
    my ($gx00, $gy00) = get_gradient($x0, $y0, $seed);
    my ($gx10, $gy10) = get_gradient($x1, $y0, $seed);
    my ($gx01, $gy01) = get_gradient($x0, $y1, $seed);
    my ($gx11, $gy11) = get_gradient($x1, $y1, $seed);
    
    # Calculate dot products
    my $n00 = $gx00 * ($x - $x0) + $gy00 * ($y - $y0);
    my $n10 = $gx10 * ($x - $x1) + $gy10 * ($y - $y0);
    my $n01 = $gx01 * ($x - $x0) + $gy01 * ($y - $y1);
    my $n11 = $gx11 * ($x - $x1) + $gy11 * ($y - $y1);
    
    # Interpolate along x
    my $nx0 = $n00 * (1 - $sx) + $n10 * $sx;
    my $nx1 = $n01 * (1 - $sx) + $n11 * $sx;
    
    # Interpolate along y
    my $result = $nx0 * (1 - $sy) + $nx1 * $sy;
    
    # Normalize to [-1,1] range
    $result = $result * 1.5;  # Amplify slightly for more variation
    $result = -1 if $result < -1;
    $result = 1 if $result > 1;
    
    return $result;
}

sub find_river_sources {
    my ($count) = @_;
    my @sources;
    my $candidates = 0;
    
    # Look for high points that could be river sources
    for my $y (1..$HEIGHT-2) {
        for my $x (1..$WIDTH-2) {
            my $e = $elevation{"$x,$y"};
            next unless defined $e;
            
            # More lenient elevation threshold
            next unless $e > 0.0; # Changed from 0.2
            
            my $key = "$x,$y,0";
            next unless exists $rooms{$key};
            next if $rooms{$key}->{impassable};
            next if $rooms{$key}->{region} =~ /^(Lake|River)$/;
            
            $candidates++;
            
            # Check surroundings for suitable terrain - more lenient
            my $suitable = 0;
            my $adjacent_water = 0;
            
            for my $d ([0,1],[1,0],[0,-1],[-1,0]) {
                my ($dx, $dy) = @$d;
                my $nkey = "$x+$dx,$y+$dy,0";
                next unless exists $rooms{$nkey};
                if ($rooms{$nkey}->{region} =~ /^(Mountain|Hill)$/) {
                    $suitable = 1;
                } elsif ($rooms{$nkey}->{region} =~ /^(Lake|River)$/) {
                    $adjacent_water = 1;
                    last;
                }
            }
            
            next if $adjacent_water;
            # Don't require mountain/hill adjacency
            #next unless $suitable;
            
            # Score based on elevation and terrain
            my $edge_dist = min($x, $y, $WIDTH-$x, $HEIGHT-$y);
            my $score = $e * 2.0 + ($edge_dist / max($WIDTH, $HEIGHT)) * 0.5;
            
            push @sources, [$x, $y, $score];
        }
    }
    
    # Sort by score and return best ones
    @sources = sort { $b->[2] <=> $a->[2] } @sources;
    my @selected = map { [$_->[0], $_->[1]] } @sources[0..min($count-1, $#sources)];
    
    return @selected;
}
sub lowest_neighbor {
    my ($x, $y, $visited_ref) = @_;
    my $curr_elev = $elevation{"$x,$y"};
    my @neighbors;
    
    # Check all 8 directions with weights
    my @dirs = (
        [0,1,1.0],   # N
        [1,0,1.0],   # E 
        [0,-1,1.0],  # S
        [-1,0,1.0],  # W
        [1,1,1.4],   # NE
        [1,-1,1.4],  # SE
        [-1,1,1.4],  # SW
        [-1,-1,1.4]  # NW
    );

    for my $d (@dirs) {
        my ($dx, $dy, $weight) = @$d;
        my $nx = $x + $dx;
        my $ny = $y + $dy;
        
        next if $nx < 0 || $nx >= $WIDTH || $ny < 0 || $ny >= $HEIGHT;
        
        my $nkey = "$nx,$ny,0";
        next unless exists $rooms{$nkey};
        
        my $neighbor = $rooms{$nkey};
        my $ne = $elevation{"$nx,$ny"};
        next unless defined $ne;

        # Allow flow into water features but not other impassable terrain
        next if $neighbor->{impassable} && 
                $neighbor->{region} ne 'Lake' && 
                $neighbor->{region} ne 'River';

        # Calculate flow score based on multiple factors
        my $elev_diff = $curr_elev - $ne;
        my $dist_to_edge = min($nx, $ny, $WIDTH-$nx, $HEIGHT-$ny);
        
        # Enhanced scoring system:
        my $score = ($elev_diff / $weight) * 1.0 +               # Primary elevation factor (reduced weight)
                   ($dist_to_edge / $WIDTH) * 0.1 +              # Edge bias
                   ($neighbor->{region} =~ /^(Lake|River)$/ ? 0.4 : 0) -  # Water bonus
                   (exists $visited_ref->{"$nx,$ny"} ? 0.6 : 0) + # Stronger penalty for visited tiles
                   (rand() * 0.3);                               # More randomization for meandering

        push @neighbors, [$nx, $ny, $score];
    }

    # Sort by score and return best option
    @neighbors = sort { $b->[2] <=> $a->[2] } @neighbors;
    return @neighbors ? [$neighbors[0]->[0], $neighbors[0]->[1]] : undef;
}

sub draw_realistic_rivers {
    my $river_num = shift || $river_count;
    
    my @sources = find_river_sources($river_num * 2);
    
    if (!@sources) {
        return;
    }
    
    my @successful_rivers;
    my $river_id = 1;
    my $attempts = 0;
    my $max_attempts = scalar(@sources) * 4;
    my $min_river_length = int($WIDTH * 0.40);

    while ($river_id <= $river_num && $attempts < $max_attempts) {
        my ($x, $y) = @{$sources[$attempts % scalar(@sources)]};
        $attempts++;
        
        my $river_name = $river_names[($river_id-1) % @river_names];
        
        my %visited;
        my $steps = 0;
        my $river_tiles = 0;
        my $start_e = $elevation{"$x,$y"};
        my ($cx, $cy) = ($x, $y);
        my @path;
        
        my $success = 0;
        my $min_steps = $min_river_length;
        
        # Track fork points
        my @forks;
        my $last_fork = 0;
        
        while (!$success && $steps < $WIDTH + $HEIGHT) {
            my $key = "$cx,$cy,0";
            $visited{$key} = ($visited{$key} // 0) + 1;
            push @path, [$cx, $cy];
            
            # Check for fork opportunities
            if ($steps > $min_steps * 0.3 && # After some initial flow
                $steps - $last_fork > 10 &&   # Not too close to last fork
                rand() < 0.15) {              # Random chance to fork
                push @forks, {
                    x => $cx,
                    y => $cy,
                    steps => $steps,
                    elevation => $elevation{"$cx,$cy"}
                };
                $last_fork = $steps;
            }
            
            # Success conditions
            if ($steps >= $min_steps) {
                if ($cx == 0 || $cx == $WIDTH-1 || $cy == 0 || $cy == $HEIGHT-1) {
                    $success = "map edge";
                }
                elsif (exists $rooms{"$cx,$cy,0"} && $rooms{"$cx,$cy,0"}->{region} eq "Lake") {
                    $success = "lake";
                }
                elsif ($elevation{"$cx,$cy"} < -0.5) {
                    $success = "lowland";
                }
            }
            
            last if $success;
            
            # Find next downhill step
            my $next = lowest_neighbor($cx, $cy, \%visited);
            unless ($next) {
                last;
            }
            
            ($cx, $cy) = @$next;
            $steps++;
        }
        
        # Only consider it successful if we met minimum length
        if ($success && $steps >= $min_steps) {
            # Place the main river
            for my $p (@path) {
                my ($rx, $ry) = @$p;
                my $key = "$rx,$ry,0";
                next unless exists $rooms{$key};
                $rooms{$key}->{region} = "River";
                $rooms{$key}->{feature} = "River";
                $rooms{$key}->{river_name} = $river_name;
                $rooms{$key}->{impassable} = 1;
                $rooms{$key}->{exits} = {};
                $river_tiles++;
            }
            
            # Generate forks
            for my $fork (@forks) {
                my ($fx, $fy) = ($fork->{x}, $fork->{y});
                my %fork_visited = %visited;
                my $fork_steps = 0;
                my $fork_tiles = 0;
                my $max_fork_steps = int($steps * 0.6); # Fork can be up to 60% of main river length
                
                # Bias the fork to flow away from mountains
                my $mountain_dx = 0;
                my $mountain_dy = 0;
                for my $d ([-2..2]) {
                    for my $dy (-2..2) {
                        my $nx = $fx + $d;
                        my $ny = $fy + $dy;
                        my $nkey = "$nx,$ny,0";
                        if (exists $rooms{$nkey} && $rooms{$nkey}->{region} eq "Mountain") {
                            $mountain_dx -= $d;
                            $mountain_dy -= $dy;
                        }
                    }
                }
                
                while ($fork_steps < $max_fork_steps) {
                    my $fkey = "$fx,$fy,0";
                    $fork_visited{$fkey}++;
                    
                    # Try to flow away from mountains with some randomness
                    my @neighbors;
                    for my $d (@river_dirs) {
                        my ($dx, $dy, $weight) = @$d;
                        my $nx = $fx + $dx;
                        my $ny = $fy + $dy;
                        next if $nx < 0 || $nx >= $WIDTH || $ny < 0 || $ny >= $HEIGHT;
                        my $nkey = "$nx,$ny,0";
                        next unless exists $rooms{$nkey};
                        my $ne = $elevation{"$nx,$ny"};
                        next unless defined $ne;
                        
                        # Enhanced scoring for forks
                        my $away_from_mountain = ($dx * $mountain_dx + $dy * $mountain_dy) / 
                                               (sqrt($mountain_dx**2 + $mountain_dy**2) || 1);
                        my $score = ($fork->{elevation} - $ne) * 1.2 +    # Downhill bias
                                  ($away_from_mountain + 1) * 0.5 +       # Away from mountains
                                  (rand() * 0.4);                         # Randomness
                        
                        push @neighbors, [$nx, $ny, $score];
                    }
                    
                    last unless @neighbors;
                    @neighbors = sort { $b->[2] <=> $a->[2] } @neighbors;
                    ($fx, $fy) = @{$neighbors[0]}[0,1];
                    
                    # Place the fork
                    my $fork_key = "$fx,$fy,0";
                    next unless exists $rooms{$fork_key};
                    $rooms{$fork_key}->{region} = "River";
                    $rooms{$fork_key}->{feature} = "River";
                    $rooms{$fork_key}->{river_name} = $river_name;
                    $rooms{$fork_key}->{impassable} = 1;
                    $rooms{$fork_key}->{exits} = {};
                    $fork_tiles++;
                    
                    $fork_steps++;
                }
                
                $river_tiles += $fork_tiles;
            }
            
            push @successful_rivers, {
                name => $river_name,
                start => [$x, $y],
                end => [$cx, $cy],
                length => $river_tiles,
                forks => scalar(@forks),
                endpoint => $success
            };
            $river_id++;
        } else {
        }
    }
    
    for my $river (@successful_rivers) {
    }
}

sub find_river_exit_from_mountain {
    my ($mx, $my) = @_;
    my $e = $elevation{"$mx,$my"};
    my $best;
    my $best_elev = $e;
    my $best_score = -999;
    
    # First expand search outward to find potential exits
    my @potential_exits;
    
    for my $r (1..5) { # Search up to 5 tiles away (increased from 3)
        for my $dx (-$r..$r) {
            for my $dy (-$r..$r) {
                # Only consider the perimeter of the search radius
                next unless abs($dx) == $r || abs($dy) == $r;
                
                my $nx = $mx + $dx;
                my $ny = $my + $dy;
                next if $nx < 0 || $nx >= $WIDTH || $ny < 0 || $ny >= $HEIGHT;
                
                my $nkey = "$nx,$ny,0";
                next unless exists $rooms{$nkey};
                my $nregion = $rooms{$nkey}->{region};
                my $nfeature = $rooms{$nkey}->{feature} // '';
                
                # Skip unsuitable terrain
                next if $nregion eq "Mountain" || $nregion eq "Lake" || $nregion eq "River";
                next if $nfeature eq "MountainPass"; # Avoid mountain passes
                
                my $ne = $elevation{"$nx,$ny"};
                next unless defined $ne;
                
                # Score based on elevation drop and distance
                my $distance = sqrt($dx*$dx + $dy*$dy);
                my $drop = $e - $ne;
                my $score = $drop * 2 - $distance * 0.1; # Prefer bigger drops, less affected by distance
                
                push @potential_exits, [$nx, $ny, $ne, $score];
            }
        }
        
        # If we found any exits at this radius, stop searching farther
        last if @potential_exits;
    }
    
    # Return the best exit based on score
    if (@potential_exits) {
        @potential_exits = sort { $b->[3] <=> $a->[3] } @potential_exits;
        return [$potential_exits[0]->[0], $potential_exits[0]->[1]];
    }
    
    # More aggressive fallback search if we didn't find any good exits
    for my $r (1..3) {
        for my $dx (-$r..$r) {
            for my $dy (-$r..$r) {
                next if $dx == 0 && $dy == 0;
                my $nx = $mx + $dx;
                my $ny = $my + $dy;
                next if $nx < 0 || $nx >= $WIDTH || $ny < 0 || $ny >= $HEIGHT;
                
                my $nkey = "$nx,$ny,0";
                next unless exists $rooms{$nkey};
                my $nregion = $rooms{$nkey}->{region};
                next if $nregion eq "Mountain";
                
                # Accept any non-mountain tile as a potential exit
                return [$nx, $ny];
            }
        }
    }
    
    return $best;
}

sub manhattan_dist {
    my ($x1, $y1, $x2, $y2) = @_;
    return abs($x1 - $x2) + abs($y1 - $y2);
}

sub shuffle {
    my $array = shift;
    for (my $i = @$array - 1; $i > 0; $i--) {
        my $j = int(rand($i+1));
        @$array[$i,$j] = @$array[$j,$i];
    }
}

sub is_adjacent_to_mountain {
    my ($x, $y) = @_;
    for my $dx (-1..1) {
        for my $dy (-1..1) {
            next if $dx == 0 && $dy == 0;
            my $nx = $x + $dx;
            my $ny = $y + $dy;
            my $nkey = "$nx,$ny,0";
            next unless exists $rooms{$nkey};
            my $nregion = $rooms{$nkey}->{region};
            return 1 if $nregion && $nregion eq "Mountain";
        }
    }
    return 0;
}

sub place_caves {
   
    my @landmarks = (
        (map { [$_->[0] + int($_->[2]/2), $_->[1] + int($_->[3]/2), "Castle", $_->[4]] } @castles),
        (map { [$_->[0] + int($_->[2]/2), $_->[1] + int($_->[3]/2), "Town", $_->[4]] } @towns),
        (map { [$_->[0] + int($_->[2]/2), $_->[1] + int($_->[3]/2), "Mountain", $_->[4]] } @mountain_clusters),
    );
    shuffle(\@landmarks);
    my $placed = 0;
    my @all_entrances = ();
    my %used_landmark;

    my $min_entrance_dist = int(min($WIDTH, $HEIGHT) / 5);

    for my $lm (@landmarks) {
        last if $placed >= $cave_count;
        my ($ex, $ey, $type, $name) = @$lm;
        next if $used_landmark{$name}++;
        my @candidates;
        for my $dx (-8..8) {
            for my $dy (-8..8) {
                my $x = $ex + $dx;
                my $y = $ey + $dy;
                my $key = "$x,$y,0";
                next unless exists $rooms{$key};
                my $r = $rooms{$key};
                next unless $r->{region} eq "Mountain" || $r->{region} eq "Hill";
                my $min_dist = @all_entrances ? min(map { manhattan_dist($x, $y, $_->[0], $_->[1]) } @all_entrances) : 1e9;
                next if $min_dist < $min_entrance_dist;
                push @candidates, [$x, $y, $key, $name];
            }
        }
        if (!@candidates && $min_entrance_dist > 6) {
            $min_entrance_dist = 6;
            for my $dx (-8..8) {
                for my $dy (-8..8) {
                    my $x = $ex + $dx;
                    my $y = $ey + $dy;
                    my $key = "$x,$y,0";
                    next unless exists $rooms{$key};
                    my $r = $rooms{$key};
                    next unless $r->{region} eq "Mountain" || $r->{region} eq "Hill";
                    my $min_dist = @all_entrances ? min(map { manhattan_dist($x, $y, $_->[0], $_->[1]) } @all_entrances) : 1e9;
                    next if $min_dist < $min_entrance_dist;
                    push @candidates, [$x, $y, $key, $name];
                }
            }
        }
        if (@candidates) {
            my ($x, $y, $key, $nearest_name) = @{ $candidates[int(rand(@candidates))] };
            $rooms{$key}->{feature} = "CaveMouth";
            $rooms{$key}->{region} = "CaveMouth";
            $rooms{$key}->{impassable} = 0;
            $rooms{$key}->{entrance_landmark_type} = $type;
            $rooms{$key}->{entrance_landmark_name} = $name;
            push @cave_entrance_keys, $key;
            push @all_entrances, [$x, $y, $nearest_name];
            $placed++;
        }
    }
    $main::ALL_ENTRANCES = \@all_entrances;
}

sub place_dungeons {
   
    my @landmarks = (
        (map { [$_->[0] + int($_->[2]/2), $_->[1] + int($_->[3]/2), "Castle", $_->[4]] } @castles),
        (map { [$_->[0] + int($_->[2]/2), $_->[1] + int($_->[3]/2), "Town", $_->[4]] } @towns),
        (map { [$_->[0] + int($_->[2]/2), $_->[1] + int($_->[3]/2), "Mountain", $_->[4]] } @mountain_clusters),
    );
    shuffle(\@landmarks);
    my $placed = 0;
    @dungeon_entrance_keys = ();
    my @all_entrances = @{ $main::ALL_ENTRANCES // [] };
    my %used_landmark;

    my $min_entrance_dist = int(min($WIDTH, $HEIGHT) / 3);

    for my $lm (@landmarks) {
        last if $placed >= $dungeon_count;
        my ($lx, $ly, $type, $name) = @$lm;
       
        my $too_close = 0;
        for my $other (@landmarks) {
            next if $other == $lm;
            my ($ox, $oy, $otype, $oname) = @$other;
            my $dist = abs($lx - $ox) + abs($ly - $oy);
           
            if ($dist < 8) {
                $too_close = 1;
                last;
            }
        }
        next if $too_close;
        next if $used_landmark{$name}++;
        my @candidates;
        for my $dx (-10..10) {
            for my $dy (-10..10) {
                my $x = $lx + $dx;
                my $y = $ly + $dy;
                my $key = "$x,$y,0";
                next unless exists $rooms{$key};
                my $r = $rooms{$key};
               
                next if $r->{impassable};
                next if $r->{region} =~ /^(Lake|River|Mountain)$/;
                next if $r->{region} =~ /^(Town|Castle)$/;
                next if is_adjacent_to_mountain($x, $y);
                my $min_dist = @all_entrances ? min(map { manhattan_dist($x, $y, $_->[0], $_->[1]) } @all_entrances) : 1e9;
                next if $min_dist < $min_entrance_dist;
                push @candidates, [$x, $y, $key, $name];
            }
        }
        if (!@candidates && $min_entrance_dist > 8) {
            $min_entrance_dist = 8;
            for my $dx (-10..10) {
                for my $dy (-10..10) {
                    my $x = $lx + $dx;
                    my $y = $ly + $dy;
                    my $key = "$x,$y,0";
                    next unless exists $rooms{$key};
                    my $r = $rooms{$key};
                    next if $r->{impassable};
                    next if $r->{region} =~ /^(Lake|River|Mountain)$/;
                    next if $r->{region} =~ /^(Town|Castle)$/;
                    next if is_adjacent_to_mountain($x, $y);
                    my $min_dist = @all_entrances ? min(map { manhattan_dist($x, $y, $_->[0], $_->[1]) } @all_entrances) : 1e9;
                    next if $min_dist < $min_entrance_dist;
                    push @candidates, [$x, $y, $key, $name];
                }
            }
        }
        if (@candidates) {
            my ($x, $y, $key, $nearest_name) = @{ $candidates[int(rand(@candidates))] };
            $rooms{$key}->{feature} = "DungeonEntrance";
            $rooms{$key}->{region} = "DungeonEntrance";
            $rooms{$key}->{impassable} = 0;
            $rooms{$key}->{entrance_landmark_type} = $type;
            $rooms{$key}->{entrance_landmark_name} = $name;
            push @dungeon_entrance_keys, $key;
            push @all_entrances, [$x, $y, $nearest_name];
            $placed++;
        }
    }
}

sub lay_town_roads {
    my ($tx, $ty, $tw, $th, $rooms_ref) = @_;

   
    my $center_x = $tx + int($tw/2);
    my $center_y = $ty + int($th/2);

   
    for my $x ($tx .. $tx+$tw-1) {
        my $key = "$x,$center_y,0";
        next unless exists $rooms_ref->{$key};
        next if $rooms_ref->{$key}->{region} eq "Road";
        $rooms_ref->{$key}->{region} = "Road";
        $rooms_ref->{$key}->{feature} = "Road";
        $rooms_ref->{$key}->{impassable} = 0;
    }
   
    for my $y ($ty .. $ty+$th-1) {
        my $key = "$center_x,$y,0";
        next unless exists $rooms_ref->{$key};
        next if $rooms_ref->{$key}->{region} eq "Road";
        $rooms_ref->{$key}->{region} = "Road";
        $rooms_ref->{$key}->{feature} = "Road";
        $rooms_ref->{$key}->{impassable} = 0;
    }

   
    for my $y ($ty .. $ty+$th-1) {
        for my $x ($tx .. $tx+$tw-1) {
            my $key = "$x,$y,0";
            next unless exists $rooms_ref->{$key};
            my $room = $rooms_ref->{$key};
            next unless $room->{feature} eq "House";
            my $exit_count = scalar grep { defined $room->{exits}{$_} } qw(N S E W);
            next unless $exit_count > 0 && $exit_count <= 4;

           
            my @candidates = ([$x, $center_y], [$center_x, $y]);
            my ($best_x, $best_y, $best_dist) = ($x, $center_y, abs($y-$center_y));
            foreach my $c (@candidates) {
                my ($cx, $cy) = @$c;
                my $dist = abs($x-$cx) + abs($y-$cy);
                if ($dist < $best_dist) {
                    $best_x = $cx; $best_y = $cy; $best_dist = $dist;
                }
            }
           
            my ($hx, $hy) = ($x, $y);
            while ($hx != $best_x) {
                $hx += ($best_x > $hx) ? 1 : -1;
                my $hkey = "$hx,$hy,0";
                last if $rooms_ref->{$hkey}->{region} eq "Road";
                $rooms_ref->{$hkey}->{region} = "Road";
                $rooms_ref->{$hkey}->{feature} = "Road";
                $rooms_ref->{$hkey}->{impassable} = 0;
            }
            while ($hy != $best_y) {
                $hy += ($best_y > $hy) ? 1 : -1;
                my $hkey = "$hx,$hy,0";
                last if $rooms_ref->{$hkey}->{region} eq "Road";
                $rooms_ref->{$hkey}->{region} = "Road";
                $rooms_ref->{$hkey}->{feature} = "Road";
                $rooms_ref->{$hkey}->{impassable} = 0;
            }
        }
    }
}

sub find_outside_of_drawbridge {
    my ($rooms_ref, $drawbridge_key) = @_;
    my ($x, $y, $z) = split /,/, $drawbridge_key;
    my @dirs = ([0,-1], [0,1], [-1,0], [1,0]);
    for my $d (@dirs) {
        my ($dx, $dy) = @$d;
        my $nx = $x + $dx;
        my $ny = $y + $dy;
        my $nkey = "$nx,$ny,$z";
        next unless exists $rooms_ref->{$nkey};
        my $r = $rooms_ref->{$nkey};
       
        if ($r->{region} ne "Castle" && $r->{region} ne "Moat" && $r->{feature} ne "Drawbridge" && !$r->{impassable}) {
            return ($nx, $ny);
        }
    }
    return;
}

sub draw_road {
    my ($x1, $y1, $x2, $y2) = @_;
    
    my %open;
    my %closed;
    my %came_from;
    my %g_score;
    my %f_score;
    my %terrain_cost;  # Track terrain costs for each node
    
    my $start = "$x1,$y1";
    my $goal  = "$x2,$y2";
    
    $g_score{$start} = 0;
    $f_score{$start} = abs($x2-$x1) + abs($y2-$y1);
    $open{$start} = 1;
    
    my @dirs = (
        [0, -1], [0, 1], [1, 0], [-1, 0],   # Cardinal directions first
        [1, -1], [-1, -1], [1, 1], [-1, 1]  # Diagonals second
    );
    
    my $steps = 0;
    my $max_steps = $WIDTH * $HEIGHT * 2;
    
    while (%open) {
        $steps++;
        if ($steps > $max_steps) {
            return 0;
        }
        
        my $current = (sort { $f_score{$a} <=> $f_score{$b} } keys %open)[0];
        my ($cx, $cy) = split /,/, $current;
        
        if ($current eq $goal) {
            my @path = ($current);
            while (exists $came_from{$current}) {
                $current = $came_from{$current};
                unshift @path, $current;
            }
            
            # Place the road
            my $stopped = 0;
            for my $p (@path) {
                my ($px, $py) = split /,/, $p;
                my $key = "$px,$py,0";
                next unless exists $rooms{$key};
                my $r = $rooms{$key};
                
                if ($r->{region} eq "Castle" || $r->{region} eq "Moat" || 
                    ($r->{feature} && $r->{feature} =~ /^(Drawbridge|Bridge)$/)) {
                    $stopped = 1;
                    last;
                }
                
                if ((!$r->{impassable} || $r->{region} eq "Road") && $r->{region} ne "Moat") {
                    $r->{feature} = "Road";
                    $r->{region} = "Road";
                    $r->{impassable} = 0;
                }
            }
            return 1;
        }
        
        delete $open{$current};
        $closed{$current} = 1;
        
        for my $d (@dirs) {
            my ($dx, $dy) = @$d;
            my ($nx, $ny) = ($cx + $dx, $cy + $dy);
            next if $nx < 0 || $nx >= $WIDTH || $ny < 0 || $ny >= $HEIGHT;
            
            my $neighbor = "$nx,$ny";
            next if $closed{$neighbor};
            
            my $nkey = "$nx,$ny,0";
            next unless exists $rooms{$nkey};
            my $nr = $rooms{$nkey};
            
            next if $neighbor ne $goal && (
                $nr->{region} eq "Castle" || 
                $nr->{region} eq "Moat" || 
                ($nr->{feature} && $nr->{feature} =~ /^(Drawbridge|Bridge)$/)
            );
            
            next if $nr->{region} eq "Moat";
            next if $nr->{impassable} && $neighbor ne $goal && $nr->{region} ne "Bridge" && $nr->{feature} ne "Drawbridge";
            
            # Calculate terrain cost
            my $terrain_cost = 1;
            if ($nr->{region} eq "Road") {
                # Prefer following existing roads slightly
                $terrain_cost = 0.9;
            } elsif ($nr->{region} =~ /Forest|Hill|Swamp/) {
                # Avoid these terrains somewhat
                $terrain_cost = 1.5;
            } elsif ($nr->{region} eq "Mountain") {
                # Strongly avoid mountains
                $terrain_cost = 3.0;
            }
            
            # Check for nearby parallel roads to avoid
            my $parallel_road_penalty = 0;
            for my $rd ([-2,0], [2,0], [0,-2], [0,2]) {
                my $rx = $nx + $rd->[0];
                my $ry = $ny + $rd->[1];
                my $rkey = "$rx,$ry,0";
                if (exists $rooms{$rkey} && $rooms{$rkey}->{region} eq "Road") {
                    $parallel_road_penalty += 0.5;
                }
            }
            
            # Calculate movement cost
            my $move_cost = sqrt($dx*$dx + $dy*$dy) * $terrain_cost * (1 + $parallel_road_penalty);
            
            my $tentative_g = $g_score{$current} + $move_cost;
            
            if (!exists $open{$neighbor} || $tentative_g < ($g_score{$neighbor} // 1e9)) {
                $came_from{$neighbor} = $current;
                $g_score{$neighbor} = $tentative_g;
                $f_score{$neighbor} = $tentative_g + abs($x2-$nx) + abs($y2-$ny);
                $open{$neighbor} = 1;
            }
        }
    }
    return 0;
}

sub connect_roads_to_castle_drawbridges {
    my ($rooms_ref, $castles_ref) = @_;
    
    # First find all road endpoints (towns and other castles)
    my %road_endpoints;
    for my $key (keys %$rooms_ref) {
        my $room = $rooms_ref->{$key};
        next unless $room->{region} eq "Road";
        my $has_road_neighbor = 0;
        my ($x, $y, $z) = ($room->{x}, $room->{y}, $room->{z});
        
        for my $d ([-1,0],[1,0],[0,-1],[0,1]) {
            my $nkey = ($x+$d->[0]).",".($y+$d->[1]).",0";
            next unless exists $rooms_ref->{$nkey};
            my $nr = $rooms_ref->{$nkey};
            if ($nr->{region} =~ /^(Town|Castle|Road)$/) {
                $has_road_neighbor = 1;
                last;
            }
        }
        
        if (!$has_road_neighbor) {
            $road_endpoints{"$x,$y"} = [$x, $y];
        }
    }

    # Then process each castle
    for my $castle (@$castles_ref) {
        my ($cx, $cy, $cw, $ch, $castle_name) = @$castle;
        my $drawbridge_key;
        my $drawbridge_found = 0;

        # Find the drawbridge
        OUTER: for my $dx (-1..$cw) {
            for my $dy (-1..$ch) {
                next if ($dx >= 0 && $dx < $cw && $dy >= 0 && $dy < $ch);
                my $x = $cx + $dx;
                my $y = $cy + $dy;
                my $key = "$x,$y,0";
                if (exists $rooms_ref->{$key} && $rooms_ref->{$key}->{feature} eq "Drawbridge") {
                    $drawbridge_key = $key;
                    $drawbridge_found = 1;
                    last OUTER;
                }
            }
        }
        next unless $drawbridge_found;

        # Find road start point outside drawbridge
        my ($road_x, $road_y) = find_outside_of_drawbridge($rooms_ref, $drawbridge_key);
        next unless defined $road_x && defined $road_y;

        # Find closest existing road or town
        my $min_dist = 1e9;
        my ($nearest_x, $nearest_y);
        my $found_connection = 0;

        # First try to connect to another road
        for my $key (keys %$rooms_ref) {
            my $room = $rooms_ref->{$key};
            next unless $room->{region} eq "Road";
            next if $room->{castle_name} && $room->{castle_name} eq $castle_name;
            
            my $dist = sqrt(($road_x - $room->{x})**2 + ($road_y - $room->{y})**2);
            if ($dist < $min_dist) {
                $min_dist = $dist;
                ($nearest_x, $nearest_y) = ($room->{x}, $room->{y});
                $found_connection = 1;
            }
        }

        # If no road found, try to connect to a town
        if (!$found_connection) {
            for my $town (@towns) {
                my ($tx, $ty, $tw, $th) = @$town;
                my $center_x = $tx + int($tw/2);
                my $center_y = $ty + int($th/2);
                my $dist = sqrt(($road_x - $center_x)**2 + ($road_y - $center_y)**2);
                if ($dist < $min_dist) {
                    $min_dist = $dist;
                    ($nearest_x, $nearest_y) = ($center_x, $center_y);
                    $found_connection = 1;
                }
            }
        }

        # If still no connection, try to connect to a road endpoint
        if (!$found_connection && %road_endpoints) {
            for my $endpoint (values %road_endpoints) {
                my ($ex, $ey) = @$endpoint;
                my $dist = sqrt(($road_x - $ex)**2 + ($road_y - $ey)**2);
                if ($dist < $min_dist) {
                    $min_dist = $dist;
                    ($nearest_x, $nearest_y) = ($ex, $ey);
                    $found_connection = 1;
                }
            }
        }

        # Draw the road if we found a connection point
        if ($found_connection) {
            draw_road($road_x, $road_y, $nearest_x, $nearest_y);
            
            # Add the new road's endpoints to our endpoint collection for future connections
            $road_endpoints{"$road_x,$road_y"} = [$road_x, $road_y] unless exists $rooms_ref->{"$road_x,$road_y,0"};
        } else {
        }
    }
    
    # Finally, ensure all road endpoints connect to something
    my @unconnected = keys %road_endpoints;
    while (@unconnected > 1) {
        my $start = shift @unconnected;
        my ($sx, $sy) = @{$road_endpoints{$start}};
        
        # Find closest remaining endpoint
        my $min_dist = 1e9;
        my $best_endpoint;
        for my $end (@unconnected) {
            my ($ex, $ey) = @{$road_endpoints{$end}};
            my $dist = sqrt(($sx - $ex)**2 + ($sy - $ey)**2);
            if ($dist < $min_dist) {
                $min_dist = $dist;
                $best_endpoint = $end;
            }
        }
        
        if ($best_endpoint) {
            my ($ex, $ey) = @{$road_endpoints{$best_endpoint}};
            draw_road($sx, $sy, $ex, $ey);
        }
    }
}

sub break_mountains_and_connect_islands {
    my ($rooms_ref, $width, $height) = @_;

    my $iteration = 0;
    my $total_passes = 0;

   
    my %mainland;
    my @frontier;
    for my $x (0..$width-1) {
        for my $y (0, $height-1) {
            my $key = "$x,$y,0";
            next unless exists $rooms_ref->{$key};
            my $r = $rooms_ref->{$key};
            next if $r->{impassable};
            $mainland{$key} = 1;
            push @frontier, [$x, $y];
        }
    }
    for my $y (0..$height-1) {
        for my $x (0, $width-1) {
            my $key = "$x,$y,0";
            next unless exists $rooms_ref->{$key};
            my $r = $rooms_ref->{$key};
            next if $r->{impassable};
            $mainland{$key} = 1;
            push @frontier, [$x, $y];
        }
    }

   
    my %visited = %mainland;
    while (@frontier) {
        my ($x, $y) = @{shift @frontier};
        for my $d ([0,1],[1,0],[0,-1],[-1,0]) {
            my ($nx, $ny) = ($x+$d->[0], $y+$d->[1]);
            next if $nx < 0 || $nx >= $width || $ny < 0 || $ny >= $height;
            my $nkey = "$nx,$ny,0";
            next if $visited{$nkey};
            next unless exists $rooms_ref->{$nkey};
            my $nr = $rooms_ref->{$nkey};
            next if $nr->{impassable};
            $visited{$nkey} = 1;
            push @frontier, [$nx, $ny];
        }
    }

      while (1) {
        $iteration++;
       
        my %island;
        for my $key (keys %$rooms_ref) {
            my $r = $rooms_ref->{$key};
            next if $r->{impassable};
            next if $visited{$key};
            $island{$key} = 1;
        }
        my $island_count = scalar(keys %island);
        last unless $island_count;

       
        my @regions;
        my %already_in_region;
        for my $iso_key (keys %island) {
            next if $already_in_region{$iso_key};
            my %region;
            my @queue = ($iso_key);
            while (@queue) {
                my $cur = shift @queue;
                next if $region{$cur}++;
                next unless $island{$cur};
                my ($x, $y, $z) = split /,/, $cur;
                for my $d ([0,1],[1,0],[0,-1],[-1,0]) {
                    my ($nx, $ny) = ($x+$d->[0], $y+$d->[1]);
                    my $nkey = "$nx,$ny,$z";
                    next unless exists $rooms_ref->{$nkey};
                    next unless $island{$nkey};
                    push @queue, $nkey unless $region{$nkey};
                }
            }
            $already_in_region{$_} = 1 for keys %region;
            push @regions, [keys %region];
        }

        my $passes_carved = 0;

       
        for my $region (@regions) {
           
            my @border;
            for my $key (@$region) {
                my ($x, $y, $z) = split /,/, $key;
                for my $d ([0,1],[1,0],[0,-1],[-1,0]) {
                    my ($nx, $ny) = ($x+$d->[0], $y+$d->[1]);
                    my $nkey = "$nx,$ny,$z";
                    next unless exists $rooms_ref->{$nkey};
                    my $nr = $rooms_ref->{$nkey};
                    if ($nr->{impassable} && $nr->{region} eq "Mountain") {
                        push @border, [$x, $y, $nx, $ny];
                    }
                }
            }

           
            my $min_path;
            my $min_len = 1e9;
            for my $b (@border) {
                my ($bx, $by, $mx, $my) = @$b;
               
                my %seen = ();
                my @q = ( [ [$mx, $my], [] ] );
                $seen{"$mx,$my"} = 1;
                my $found;
                while (@q && !$found) {
                    my ($cur, $path) = @{shift @q};
                    my ($cx, $cy) = @$cur;
                    my $ckey = "$cx,$cy,0";
                    my $r = $rooms_ref->{$ckey};
                    if (!$r->{impassable} && $visited{$ckey}) {
                        $found = [@$path, [$cx, $cy]];
                        last;
                    }
                    next unless $r->{impassable} && $r->{region} eq "Mountain";
                    for my $d ([0,1],[1,0],[0,-1],[-1,0]) {
                        my ($nx, $ny) = ($cx+$d->[0], $cy+$d->[1]);
                        my $nkey = "$nx,$ny,0";
                        next if $seen{$nkey}++;
                        next unless exists $rooms_ref->{$nkey};
                        my $nr = $rooms_ref->{$nkey};
                        push @q, [ [$nx, $ny], [@$path, [$cx, $cy]] ];
                    }
                }
                if ($found && @$found < $min_len) {
                    $min_len = @$found;
                    $min_path = $found;
                }
            }
            if ($min_path && @$min_path) {
               
                for my $pt (@$min_path) {
                    my ($px, $py) = @$pt;
                    my $pkey = "$px,$py,0";
                    next unless exists $rooms_ref->{$pkey};
                    my $pr = $rooms_ref->{$pkey};
                    $pr->{region} = "MountainPass";
                    $pr->{feature} = "MountainPass";
                    $pr->{impassable} = 0;
                }
                $passes_carved++;
                $total_passes++;
               
                $mainland{$_} = 1 for @$region;
                $visited{$_} = 1 for @$region;
            }
        }

       
        @frontier = map { [ (split /,/, $_)[0,1] ] } keys %mainland;
        while (@frontier) {
            my ($x, $y) = @{shift @frontier};
            for my $d ([0,1],[1,0],[0,-1],[-1,0]) {
                my ($nx, $ny) = ($x+$d->[0], $y+$d->[1]);
                next if $nx < 0 || $nx >= $width || $ny < 0 || $ny >= $height;
                my $nkey = "$nx,$ny,0";
                next if $visited{$nkey};
                next unless exists $rooms_ref->{$nkey};
                my $nr = $rooms_ref->{$nkey};
                next if $nr->{impassable};
                $visited{$nkey} = 1;
                $mainland{$nkey} = 1;
                push @frontier, [$nx, $ny];
            }
        }
    }
}

sub fix_isolated_mountains {
    my ($rooms_ref, $width, $height) = @_;
    my $fixed = 0;
    for my $key (keys %$rooms_ref) {
        my $room = $rooms_ref->{$key};
        next unless $room->{region} eq "Mountain" && $room->{impassable};
        my ($x, $y, $z) = ($room->{x}, $room->{y}, $room->{z});
        my $isolated = 1;
        for my $d ([0,1],[1,0],[0,-1],[-1,0],[1,1],[-1,1],[1,-1],[-1,-1]) {
            my ($nx, $ny) = ($x+$d->[0], $y+$d->[1]);
            my $nkey = "$nx,$ny,$z";
            next unless exists $rooms_ref->{$nkey};
            my $neighbor = $rooms_ref->{$nkey};
            if ($neighbor->{region} eq "Mountain" && $neighbor->{impassable}) {
                $isolated = 0;
                last;
            }
        }
        if ($isolated) {
            $room->{region} = "MountainPass";
            $room->{feature} = "MountainPass";
            $room->{impassable} = 0;
            $fixed++;
        }
    }
}

sub connect_small_isolated_passable_islands {
    my ($rooms_ref, $width, $height, $max_size) = @_;
    $max_size //= 5;
    my $total_connected = 0;
    my $pass = 0;

   
    my %mainland;
    my @frontier;
    for my $x (0..$width-1) {
        for my $y (0, $height-1) {
            my $key = "$x,$y,0";
            next unless exists $rooms_ref->{$key};
            my $r = $rooms_ref->{$key};
            next if $r->{impassable};
            $mainland{$key} = 1;
            push @frontier, [$x, $y];
        }
    }
    for my $y (0..$height-1) {
        for my $x (0, $width-1) {
            my $key = "$x,$y,0";
            next unless exists $rooms_ref->{$key};
            my $r = $rooms_ref->{$key};
            next if $r->{impassable};
            $mainland{$key} = 1;
            push @frontier, [$x, $y];
        }
    }
    my %visited = %mainland;
    while (@frontier) {
        my ($x, $y) = @{shift @frontier};
        for my $d ([0,1],[1,0],[0,-1],[-1,0]) {
            my ($nx, $ny) = ($x+$d->[0], $y+$d->[1]);
            next if $nx < 0 || $nx >= $width || $ny < 0 || $ny >= $height;
            my $nkey = "$nx,$ny,0";
            next if $visited{$nkey};
            next unless exists $rooms_ref->{$nkey};
            my $nr = $rooms_ref->{$nkey};
            next if $nr->{impassable};
            $visited{$nkey} = 1;
            push @frontier, [$nx, $ny];
        }
    }

   
    my %already_in_region;
    for my $key (keys %$rooms_ref) {
        next if $already_in_region{$key};
        my $room = $rooms_ref->{$key};
        next if $room->{impassable};
        next if $visited{$key};
       
        my @region;
        my @queue = ($key);
        my %region_visited;
        while (@queue) {
            my $cur = shift @queue;
            next if $region_visited{$cur}++;
            my $r = $rooms_ref->{$cur};
            next if $r->{impassable};
            push @region, $cur;
            my ($x, $y, $z) = ($r->{x}, $r->{y}, $r->{z});
            for my $d ([0,1],[1,0],[0,-1],[-1,0],[1,1],[-1,1],[1,-1],[-1,-1]) {
                my ($nx, $ny) = ($x+$d->[0], $y+$d->[1]);
                my $nkey = "$nx,$ny,$z";
                next unless exists $rooms_ref->{$nkey};
                my $nr = $rooms_ref->{$nkey};
                next if $nr->{impassable};
                next if $region_visited{$nkey};
                push @queue, $nkey;
            }
        }
        next unless @region;
        next if @region > $max_size;

       
        my @border;
        for my $cur (@region) {
            my ($x, $y, $z) = split /,/, $cur;
            for my $d ([0,1],[1,0],[0,-1],[-1,0]) {
                my ($nx, $ny) = ($x+$d->[0], $y+$d->[1]);
                my $nkey = "$nx,$ny,$z";
                next unless exists $rooms_ref->{$nkey};
                my $neighbor = $rooms_ref->{$nkey};
                if ($neighbor->{impassable} && $neighbor->{region} eq "Mountain") {
                    push @border, [$x, $y, $nx, $ny];
                }
            }
        }
       
        my $min_path;
        my $min_len = 1e9;
        for my $b (@border) {
            my ($bx, $by, $mx, $my) = @$b;
           
            my %seen = ();
            my @q = ( [ [$mx, $my], [] ] );
            $seen{"$mx,$my"} = 1;
            my $found;
            while (@q && !$found) {
                my ($cur, $path) = @{shift @q};
                my ($cx, $cy) = @$cur;
                my $ckey = "$cx,$cy,0";
                my $r = $rooms_ref->{$ckey};
                if (!$r->{impassable} && $visited{$ckey}) {
                    $found = [@$path, [$cx, $cy]];
                    last;
                }
                next unless $r->{impassable} && $r->{region} eq "Mountain";
                for my $d ([0,1],[1,0],[0,-1],[-1,0]) {
                    my ($nx, $ny) = ($cx+$d->[0], $cy+$d->[1]);
                    my $nkey = "$nx,$ny,0";
                    next if $seen{$nkey}++;
                    next unless exists $rooms_ref->{$nkey};
                    my $nr = $rooms_ref->{$nkey};
                    push @q, [ [$nx, $ny], [@$path, [$cx, $cy]] ];
                }
            }
            if ($found && @$found < $min_len) {
                $min_len = @$found;
                $min_path = $found;
            }
        }
        if ($min_path && @$min_path) {
           
            for my $pt (@$min_path) {
                my ($px, $py) = @$pt;
                my $pkey = "$px,$py,0";
                next unless exists $rooms_ref->{$pkey};
                my $pr = $rooms_ref->{$pkey};
                $pr->{region} = "MountainPass";
                $pr->{feature} = "MountainPass";
                $pr->{impassable} = 0;
            }
            $total_connected++;
           
            $mainland{$_} = 1 for @region;
            $visited{$_} = 1 for @region;
        }
    }
}

sub convert_small_isolated_passable_islands_to_neighbor_type {
    my ($rooms_ref, $width, $height, $max_size) = @_;
    $max_size //= 5;
    my $total_converted_clusters = 0;
    my $total_converted_tiles = 0;
    my $pass = 0;

    while (1) {
        $pass++;
        my %visited;
        my $converted_clusters = 0;
        my $converted_tiles = 0;
        for my $key (keys %$rooms_ref) {
            next if $visited{$key};
            my $room = $rooms_ref->{$key};
            next if $room->{impassable};
           
            my @region;
            my @queue = ($key);
            while (@queue) {
                my $cur = shift @queue;
                next if $visited{$cur}++;
                my $r = $rooms_ref->{$cur};
                next if $r->{impassable};
                push @region, $cur;
                my ($x, $y, $z) = ($r->{x}, $r->{y}, $r->{z});
                for my $d ([0,1],[1,0],[0,-1],[-1,0],[1,1],[-1,1],[1,-1],[-1,-1]) {
                    my ($nx, $ny) = ($x+$d->[0], $y+$d->[1]);
                    my $nkey = "$nx,$ny,$z";
                    next unless exists $rooms_ref->{$nkey};
                    my $nr = $rooms_ref->{$nkey};
                    next if $nr->{impassable};
                    next if $visited{$nkey};
                    push @queue, $nkey;
                }
            }
            next unless @region;
            next if @region > $max_size;

           
            my %neighbor_types;
            my $all_neighbors_impassable = 1;
            REGION: for my $cur (@region) {
                my ($x, $y, $z) = split /,/, $cur;
                for my $d ([0,1],[1,0],[0,-1],[-1,0],[1,1],[-1,1],[1,-1],[-1,-1]) {
                    my ($nx, $ny) = ($x+$d->[0], $y+$d->[1]);
                   
                    if ($nx < 0 || $nx >= $width || $ny < 0 || $ny >= $height) {
                        next;
                    }
                    my $nkey = "$nx,$ny,$z";
                    next unless exists $rooms_ref->{$nkey};
                    my $neighbor = $rooms_ref->{$nkey};
                    if ($neighbor->{impassable}) {
                        my $type = $neighbor->{region} . "|" . ($neighbor->{feature} // '');
                        $neighbor_types{$type}++;
                    } else {
                        $all_neighbors_impassable = 0;
                        last REGION;
                    }
                }
            }
            next unless $all_neighbors_impassable && %neighbor_types;
           
            my ($type) = sort { $neighbor_types{$b} <=> $neighbor_types{$a} } keys %neighbor_types;
            my ($new_region, $new_feature) = split /\|/, $type, 2;
            $new_feature //= $new_region;

            for my $cur (@region) {
                my $r = $rooms_ref->{$cur};
                $r->{region} = $new_region;
                $r->{feature} = $new_feature;
                $r->{impassable} = 1;
                $r->{exits} = {};
                $converted_tiles++;
            }
            $converted_clusters++;
        }
        $total_converted_clusters += $converted_clusters;
        $total_converted_tiles += $converted_tiles;
        last if $converted_clusters == 0;
    }
}

sub convert_all_single_tile_passable_islands {
    my ($rooms_ref, $width, $height) = @_;
    my $total_converted = 0;
    my $pass = 0;
    while (1) {
        $pass++;
        my $converted = 0;
        for my $key (keys %$rooms_ref) {
            my $room = $rooms_ref->{$key};
            next if $room->{impassable};
            my ($x, $y, $z) = ($room->{x}, $room->{y}, $room->{z});
            my $surrounded = 1;
            for my $d ([0,1],[1,0],[0,-1],[-1,0],[1,1],[-1,1],[1,-1],[-1,-1]) {
                my ($nx, $ny) = ($x+$d->[0], $y+$d->[1]);
                my $nkey = "$nx,$ny,$z";
                if (!exists $rooms_ref->{$nkey}) { $surrounded = 0; last; }
                my $neighbor = $rooms_ref->{$nkey};
                if ($neighbor->{region} ne "Mountain" || !$neighbor->{impassable}) {
                    $surrounded = 0; last;
                }
            }
            if ($surrounded) {
                $room->{region} = "Mountain";
                $room->{feature} = "Mountain";
                $room->{impassable} = 1;
                $room->{exits} = {};
                $converted++;
            }
        }
        $total_converted += $converted;
        last if $converted == 0;
    }
}

generate_elevation_and_biome($WIDTH, $HEIGHT, $ELEV_SEED, $BIOME_SEED, \%elevation, \%biome);
place_grass();

generate_mountains();
print "Generated mountain ranges:\n";
for my $mc (@mountain_clusters) {
    my ($x, $y, $w, $h, $name) = @$mc;
    print "  $name at ($x,$y), size ${w}x${h}\n";
}
print "\n";

break_mountains_and_connect_islands(\%rooms, $WIDTH, $HEIGHT);
connect_small_isolated_passable_islands(\%rooms, $WIDTH, $HEIGHT, 5);
convert_all_single_tile_passable_islands(\%rooms, $WIDTH, $HEIGHT);

generate_lakes();

print "Generated lakes:\n";
for my $lc (@lake_clusters) {
    my ($x, $y, $w, $h, $name) = @$lc;
    print "  $name at ($x,$y), size ${w}x${h}\n";
}
print "\n";

place_biomes();
draw_realistic_rivers();
print "Generated rivers:\n";
my %seen_rivers;
for my $room (values %rooms) {
    next unless $room->{region} eq 'River' && $room->{river_name};
    next if $seen_rivers{$room->{river_name}}++;
    print "  $room->{river_name}\n";
}
print "\n";

place_castles();
print "Generated castles:\n";
for my $castle (@castles) {
    my ($x, $y, $w, $h, $name) = @$castle;
    print "  $name at ($x,$y), size ${w}x${h}\n";
}
print "\n";

place_towns(\%rooms, \@room_keys, \@towns);
print "Generated towns:\n";
for my $town (@towns) {
    my ($x, $y, $w, $h, $name) = @$town;
    print "  $name at ($x,$y), size ${w}x${h}\n";
}
print "\n";

connect_town_edges(\@towns, \%rooms);
connect_roads_to_castle_drawbridges(\%rooms, \@castles);
place_caves();
place_dungeons();
print "Generated special locations:\n";
print "  Caves: ", scalar(@cave_entrance_keys), "\n";
print "  Dungeons: ", scalar(@dungeon_entrance_keys), "\n\n";

for my $entrance_key (@cave_entrance_keys) {
    generate_cave_map($entrance_key, \$next_idx, \%rooms, \@room_keys);
}

for my $entrance_key (@dungeon_entrance_keys) {
    generate_dungeon_map($entrance_key, \$next_idx, \%rooms, \@room_keys);
}

my %idx_to_key = map { $rooms{$_}->{idx} => $_ } keys %rooms;

my $cave_linked_ok = 0;
my $cave_linked_fail = 0;
for my $entrance_key (@cave_entrance_keys) {
    my $entrance_room = $rooms{$entrance_key};
    my $down_idx = $entrance_room->{exits}{'DOWN'} // 0;
    if (!$down_idx) {
        $cave_linked_fail++;
        next;
    }
    my $found = 0;
    for my $key (keys %rooms) {
        my $r = $rooms{$key};
        next unless ref($r) eq 'HASH' && defined($r->{idx}) && defined($r->{region}) && $r->{region} eq "Cave";
        if ($r->{idx} == $down_idx) {
            $found = 1;
            if (!defined($r->{exits}{'UP'}) || $r->{exits}{'UP'} != $entrance_room->{idx}) {
                $cave_linked_fail++;
            } else {
                $cave_linked_ok++;
            }
            last;
        }
    }
    unless ($found) {
        $cave_linked_fail++;
    }
}

my $dungeon_linked_ok = 0;
my $dungeon_linked_fail = 0;
for my $entrance_key (@dungeon_entrance_keys) {
    my $entrance_room = $rooms{$entrance_key};
    my $down_idx = $entrance_room->{exits}{'DOWN'} // 0;
    if (!$down_idx) {
        $dungeon_linked_fail++;
        next;
    }
    my $found = 0;
    for my $key (keys %rooms) {
        my $r = $rooms{$key};
        next unless ref($r) eq 'HASH' && defined($r->{idx}) && defined($r->{region}) && $r->{region} eq "Dungeon";
        if ($r->{idx} == $down_idx) {
            $found = 1;
            if (!defined($r->{exits}{'UP'}) || $r->{exits}{'UP'} != $entrance_room->{idx}) {
                $dungeon_linked_fail++;
            } else {
                $dungeon_linked_ok++;
            }
            last;
        }
    }
    unless ($found) {
        $dungeon_linked_fail++;
    }
}


# Optionally, exit nonzero if any linkage failed
if ($cave_linked_fail || $dungeon_linked_fail) {
    exit 1;
}

for my $room (values %rooms) {
    $room->{object}    //= '';
    $room->{hiddenobj} //= '';
    $room->{treasure}  //= '';
    $room->{trecharges} //= '';
}

for my $room (values %rooms) {
    my $feature = $room->{feature} // '';
    my $region  = $room->{region}  // '';

   
    if ($feature eq "LockedHouse" && exists $object_by_name{"Locked Door"}) {
        add_object_to_room($room, "Locked Door", 0);
    }
    if ($feature eq "Drawbridge" && exists $object_by_name{"Drawbridge"}) {
        add_object_to_room($room, "Drawbridge", 0);
    }
    if ($feature eq "GateTower" && exists $object_by_name{"Gate"}) {
        add_object_to_room($room, "Gate", 0);
    }
    if ($feature eq "Tower" && exists $object_by_name{"Staircase"}) {
        add_object_to_room($room, "Staircase", 0);
    }
    if ($feature eq "Keep" && exists $object_by_name{"Throne"}) {
        add_object_to_room($room, "Throne", 0);
    }
    if ($feature eq "DungeonVault" && exists $object_by_name{"Chest"}) {
        add_object_to_room($room, "Chest", 0);
    }
    if ($feature eq "CaveLake" && exists $object_by_name{"Boat"}) {
        add_object_to_room($room, "Boat", 0);
    }

   
    if ($feature eq "Shop" && @treasures) {
        my $tidx = int(rand(@treasures));
        my $tname = $treasures[$tidx]{name};
        add_treasure_to_room($room, $tname, 1);
    }
    if ($feature eq "DungeonVault" && @treasures) {
        my $tidx = int(rand(@treasures));
        my $tname = $treasures[$tidx]{name};
        add_treasure_to_room($room, $tname, 1 + int(rand(5)));
    }
    if ($feature eq "Keep" && @treasures) {
        my $tidx = int(rand(@treasures));
        my $tname = $treasures[$tidx]{name};
        add_treasure_to_room($room, $tname, 1 + int(rand(3)));
    }
    if ($feature eq "CaveLake" && @treasures) {
        my $tidx = int(rand(@treasures));
        my $tname = $treasures[$tidx]{name};
        add_treasure_to_room($room, $tname, 1 + int(rand(2)));
    }
   
    if (($feature eq "DungeonCorridor" || $feature eq "CaveTunnel") && @treasures && rand() < 0.15) {
        my $tidx = int(rand(@treasures));
        my $tname = $treasures[$tidx]{name};
        add_treasure_to_room($room, $tname, 1 + int(rand(3)));
    }
   
    if (($region eq "Castle" || $feature eq "House") && @treasures && rand() < 0.05) {
        my $tidx = int(rand(@treasures));
        my $tname = $treasures[$tidx]{name};
        add_treasure_to_room($room, $tname, 1);
    }
   
    if (($feature eq "DungeonCorridor" || $feature eq "CaveTunnel") && @objects && rand() < 0.10) {
        my $oidx = int(rand(@objects));
        my $oname = $objects[$oidx]{name};
        add_object_to_room($room, $oname, 0);
    }
   
    if (($region eq "Castle" || $feature eq "House") && @objects && rand() < 0.03) {
        my $oidx = int(rand(@objects));
        my $oname = $objects[$oidx]{name};
        add_object_to_room($room, $oname, 0);
    }
}

@centers = (map { [$_->[0]+int($_->[2]/2), $_->[1]+int($_->[3]/2)] } @towns, @castles);
my $road_count = 0;
for my $i (0..$#centers-1) {
    my ($x1,$y1) = @{$centers[$i]};
    my ($x2,$y2) = @{$centers[$i+1]};
    draw_road($x1, $y1, $x2, $y2);
    $road_count++;
}

# 1. Define destination object types (connectors)
my %DEST_OBJECT_TYPES = map { $_ => 1 } qw(
    DOOR PORTAL GATE LADDER TRAPDOOR WINDOW BACKDOOR EXIT PATH ROAD BRIDGE WALKBRIDGE STREAM
    TUNNEL SHAFT STAIRS STAIRWAY STAIRCASE SLIDE CHUTE SAFE VAULT CRACK HATCHWAY SPLIT
);

# 2. Helper: Add exit to room based on object type and context
sub add_exit_for_object {
    my ($room, $object, $rooms_ref) = @_;
    my $type = uc($object->{shortname} // '');
    my $feature = $room->{feature} // '';
    my $region  = $room->{region}  // '';
    my ($x, $y, $z) = ($room->{x}, $room->{y}, $room->{z});

   
    my $dir;
    my $target_key;
    if ($type eq 'DOOR' || $type eq 'BACKDOOR' || $type eq 'EXIT' || $type eq 'GATE' || $type eq 'PORTAL') {
       
        my @dirs = qw(N S E W);
        $dir = $dirs[int(rand(@dirs))];
        my %dir_delta = (N=>[0,-1], S=>[0,1], E=>[1,0], W=>[-1,0]);
        my ($dx, $dy) = @{$dir_delta{$dir}};
        my $nx = $x + $dx;
        my $ny = $y + $dy;
        $target_key = "$nx,$ny,$z";
    } elsif ($type eq 'TRAPDOOR' || $type eq 'HATCHWAY' || $type eq 'CHUTE' || $type eq 'SLIDE' || $type eq 'SHAFT' || $type eq 'CRACK' || $type eq 'SPLIT') {
       
        $dir = 'DOWN';
        $target_key = "$x,$y,".($z+1);
    } elsif ($type eq 'LADDER' || $type eq 'STAIRS' || $type eq 'STAIRWAY' || $type eq 'STAIRCASE') {
       
        $dir = 'UP';
        $target_key = "$x,$y,".($z-1);
    } elsif ($type eq 'WINDOW') {
       
        $dir = (rand() < 0.5) ? 'E' : 'W';
        my %dir_delta = (E=>[1,0], W=>[-1,0]);
        my ($dx, $dy) = @{$dir_delta{$dir}};
        my $nx = $x + $dx;
        my $ny = $y + $dy;
        $target_key = "$nx,$ny,$z";
    } elsif ($type eq 'PATH' || $type eq 'ROAD' || $type eq 'BRIDGE' || $type eq 'WALKBRIDGE' || $type eq 'STREAM' || $type eq 'TUNNEL') {
       
        my @dirs = qw(N S E W NE NW SE SW);
        $dir = $dirs[int(rand(@dirs))];
        my %dir_delta = (N=>[0,-1], S=>[0,1], E=>[1,0], W=>[-1,0], NE=>[1,-1], NW=>[-1,-1], SE=>[1,1], SW=>[-1,1]);
        my ($dx, $dy) = @{$dir_delta{$dir}};
        my $nx = $x + $dx;
        my $ny = $y + $dy;
        $target_key = "$nx,$ny,$z";
    } elsif ($type eq 'SAFE' || $type eq 'VAULT') {
       
        $dir = 'DOWN';
        $target_key = "$x,$y,".($z+1);
    } else {
        return;
    }

   
    if ($target_key && exists $rooms_ref->{$target_key} && !$rooms_ref->{$target_key}->{impassable}) {
        $room->{exits}{$dir} = $rooms_ref->{$target_key}->{idx};
    }
}

# 3. Patch object/treasure placement loop to skip destination objects as room objects, and add as exits instead
for my $room (values %rooms) {
    my $feature = $room->{feature} // '';
    my $region  = $room->{region}  // '';

   
    if ($feature eq "LockedHouse" && exists $object_by_name{"Locked Door"}) {
        my $obj = $objects[$object_by_name{"Locked Door"}];
        add_exit_for_object($room, $obj, \%rooms) if $DEST_OBJECT_TYPES{uc($obj->{shortname})};
       
    }
    if ($feature eq "Drawbridge" && exists $object_by_name{"Drawbridge"}) {
        my $obj = $objects[$object_by_name{"Drawbridge"}];
        add_exit_for_object($room, $obj, \%rooms) if $DEST_OBJECT_TYPES{uc($obj->{shortname})};
    }
    if ($feature eq "GateTower" && exists $object_by_name{"Gate"}) {
        my $obj = $objects[$object_by_name{"Gate"}];
        add_exit_for_object($room, $obj, \%rooms) if $DEST_OBJECT_TYPES{uc($obj->{shortname})};
    }
    if ($feature eq "Tower" && exists $object_by_name{"Staircase"}) {
        my $obj = $objects[$object_by_name{"Staircase"}];
        add_exit_for_object($room, $obj, \%rooms) if $DEST_OBJECT_TYPES{uc($obj->{shortname})};
    }
    if ($feature eq "Keep" && exists $object_by_name{"Throne"}) {
       
        add_object_to_room($room, "Throne", 0);
    }
    if ($feature eq "DungeonVault" && exists $object_by_name{"Chest"}) {
        add_object_to_room($room, "Chest", 0);
    }
    if ($feature eq "CaveLake" && exists $object_by_name{"Boat"}) {
        add_object_to_room($room, "Boat", 0);
    }

   
    if ($feature eq "Shop" && @treasures) {
        my $tidx = int(rand(@treasures));
        my $tname = $treasures[$tidx]{name};
        add_treasure_to_room($room, $tname, 1);
    }
    if ($feature eq "DungeonVault" && @treasures) {
        my $tidx = int(rand(@treasures));
        my $tname = $treasures[$tidx]{name};
        add_treasure_to_room($room, $tname, 1 + int(rand(5)));
    }
    if ($feature eq "Keep" && @treasures) {
        my $tidx = int(rand(@treasures));
        my $tname = $treasures[$tidx]{name};
        add_treasure_to_room($room, $tname, 1 + int(rand(3)));
    }
    if ($feature eq "CaveLake" && @treasures) {
        my $tidx = int(rand(@treasures));
        my $tname = $treasures[$tidx]{name};
        add_treasure_to_room($room, $tname, 1 + int(rand(2)));
    }
   
    if (($feature eq "DungeonCorridor" || $feature eq "CaveTunnel") && @treasures && rand() < 0.15) {
        my $tidx = int(rand(@treasures));
        my $tname = $treasures[$tidx]{name};
        add_treasure_to_room($room, $tname, 1 + int(rand(3)));
    }
   
    if (($region eq "Castle" || $feature eq "House") && @treasures && rand() < 0.05) {
        my $tidx = int(rand(@treasures));
        my $tname = $treasures[$tidx]{name};
        add_treasure_to_room($room, $tname, 1);
    }
   
    if (($feature eq "DungeonCorridor" || $feature eq "CaveTunnel") && @objects && rand() < 0.10) {
        my $oidx = int(rand(@objects));
        my $o = $objects[$oidx];
       
        add_object_to_room($room, $o->{name}, 0) unless $DEST_OBJECT_TYPES{uc($o->{shortname})};
    }
   
    if (($region eq "Castle" || $feature eq "House") && @objects && rand() < 0.03) {
        my $oidx = int(rand(@objects));
        my $o = $objects[$oidx];
        add_object_to_room($room, $o->{name}, 0) unless $DEST_OBJECT_TYPES{uc($o->{shortname})};
    }
}

# Replace the relevant part of the describe_room function:

# Default grassland (or other outdoor area with potential visible landmarks)
sub describe_room {
    my ($room) = @_;

    if (update_room_description_from_feature($room)) {
        # If update_room_description_from_feature returns true, it set the descriptions
        return;
    }

    my ($x, $y, $z) = ($room->{x}, $room->{y}, $room->{z});
    my $region = $room->{region};
    my $feature = $room->{feature};

   
    if ($region eq "Town") {
        my $name = $room->{town_name} // "the town";
        if ($feature eq "Plaza") {
            $room->{shortdesc} = titlecase("$name Plaza");
            $room->{longdesc} = "You are in the bustling plaza of $name. Merchants and villagers gather around a central fountain.";
        } elsif ($feature eq "Inn") {
            $room->{shortdesc} = titlecase("$name Inn");
            $room->{longdesc} = "You are inside the inn at $name. The scent of stew and sound of laughter fill the air.";
        } elsif ($feature eq "Shop") {
            $room->{shortdesc} = titlecase("$name Shop");
            $room->{longdesc} = "You are in a small shop in $name. Shelves are lined with wares and trinkets.";
        } elsif ($feature eq "Temple") {
            $room->{shortdesc} = titlecase("$name Temple");
            $room->{longdesc} = "You are in a quiet temple in $name. Candles flicker and prayers echo softly.";
        } elsif ($feature eq "Tavern") {
            $room->{shortdesc} = titlecase("$name Tavern");
            $room->{longdesc} = "You are in the lively tavern of $name. Patrons share tales over mugs of ale.";
        } elsif ($feature eq "LockedHouse") {
            $room->{shortdesc} = titlecase("Locked House");
            $room->{longdesc} = "This house in $name is locked tight. You cannot enter.";
        } elsif ($feature eq "Yard") {
            $room->{shortdesc} = titlecase("Village Yard");
            $room->{longdesc} = "You are in an open space within $name. The area is grassy and quiet, with houses scattered nearby.";
        } elsif ($feature eq "House") {
            if (int(($room->{idx} + $room->{x} + $room->{y}) % 2) == 0) {
                my $house_name = $house_names[ ($room->{idx} + $room->{x} + $room->{y}) % @house_names ];
                $room->{shortdesc} = titlecase($house_name);
                $room->{longdesc} = "You are outside $house_name in $name. Smoke rises from the chimney.";
            } else {
                my $villager = $villager_names[ ($room->{idx} * 7 + $room->{x} * 13 + $room->{y}) % @villager_names ];
                my $title    = $villager_titles[ ($room->{idx} * 11 + $room->{y} * 17 + $room->{x}) % @villager_titles ];
                my $possessive = (defined $villager && $villager =~ /s$/i) ? "'" : "'s";
                $room->{shortdesc} = titlecase("$villager $title$possessive House");
                $room->{longdesc} = "You are outside $villager $title$possessive house in $name. Smoke rises from the chimney.";
            }
        } elsif ($feature eq "Castle") {
            $room->{shortdesc} = titlecase("$name Castle");
            $room->{longdesc} = "You are outside the castle in $name. The stone walls loom high above.";
        } elsif ($feature eq "Farm") {
            $room->{shortdesc} = titlecase("Village Farm");
            $room->{longdesc} = "You are at a farm in $name. Fields of crops stretch out before you.";    
        } else {
            $room->{shortdesc} = titlecase("Village House");
            $room->{longdesc} = "You are outside a villager's house in $name. Smoke rises from the chimney.";
        }
        return;
    }

    if ($feature eq "HouseInterior") {
        $room->{shortdesc} = titlecase("Inside House");
        $room->{longdesc} = "You are inside a cozy village house. The scent of woodsmoke and bread fills the air.";
        return;
    }
    if ($feature eq "ShopInterior") {
        $room->{shortdesc} = titlecase("Inside Shop");
        $room->{longdesc} = "You are inside a small shop. Shelves are lined with wares and trinkets.";
        return;
    }

   
    if ($region eq "Castle") {
        my $name = $room->{castle_name} // "the castle";
        if ($feature eq "ThroneRoom") {
            $room->{shortdesc} = titlecase("$name Throne Room");
            $room->{longdesc} = "You stand in the grand throne room of $name. Banners hang from the walls and a majestic throne sits at the far end.";
        } elsif ($feature eq "Tower") {
            $room->{shortdesc} = titlecase("$name Tower");
            $room->{longdesc} = "You are in one of ${name}'s towers. Narrow windows offer a sweeping view of the lands below.";
        } else {
            $room->{shortdesc} = titlecase("$name Hall");
            $room->{longdesc} = "You are in a stone hall within $name. The air is cool and echoes with distant footsteps.";
        }
        return;
    }
    if ($region eq "Moat") {
        $room->{shortdesc} = titlecase("Castle Moat");
        $room->{longdesc} = "A deep moat filled with water surrounds the castle. The only way across is the drawbridge.";
        return;
    }
    if ($feature eq "Drawbridge") {
        $room->{shortdesc} = titlecase("Castle Drawbridge");
        $room->{longdesc} = "A sturdy drawbridge spans the moat, leading to the castle gates.";
        return;
    }

   
    if ($feature eq "CaveMouth") {
        $room->{shortdesc} = titlecase("Cave Entrance");
        $room->{longdesc} = "A dark cave entrance gapes at the base of the mountain. The air is cool and musty.";
        return;
    }
    if ($region eq "Cave") {
        if ($feature eq "CaveLake") {
            $room->{shortdesc} = titlecase("Underground Lake");
            $room->{longdesc} = "You are at the edge of a still, underground lake. The water glows faintly in the darkness.";
        } else {
            $room->{shortdesc} = titlecase("Cave Tunnel");
            $room->{longdesc} = "You are in a winding cave tunnel. The walls glisten with moisture and strange fungi.";
        }
        return;
    }
    if ($feature eq "DungeonEntrance") {
        $room->{shortdesc} = titlecase("Dungeon Entrance");
        $room->{longdesc} = "A heavy trapdoor in the ground leads down into darkness. The dungeon awaits below.";
        return;
    }
    if ($region eq "Dungeon") {
        if ($feature eq "DungeonVault") {
            $room->{shortdesc} = titlecase("Dungeon Vault");
            $room->{longdesc} = "You have found the dungeon's vault. Ancient treasures and bones lie scattered about.";
        } else {
            $room->{shortdesc} = titlecase("Dungeon Corridor");
            $room->{longdesc} = "You are in a dank, narrow corridor deep beneath the earth. The air is thick and stale.";
        }
        return;
    }

   
    if ($region eq "River") {
        my $river_name = $room->{river_name} // "The river";
        $room->{shortdesc} = titlecase("River Crossing");
        $room->{longdesc} = "$river_name flows swiftly here, its waters cold and deep. The banks are muddy and lush.";
        return;
    }
    if ($region eq "Lake") {
        $room->{shortdesc} = titlecase("Lakeshore");
        $room->{longdesc} = "You stand at the edge of a tranquil lake. The water stretches out, reflecting the sky.";
        return;
    }
    if ($region eq "Mountain") {
        $room->{shortdesc} = titlecase("Mountain Range");
        $room->{longdesc} = "Steep, rocky mountains rise up around you. The terrain is impassable and forbidding.";
        return;
    }
    if ($region eq "Road") {
        $room->{shortdesc} = titlecase("Country Road");
        $room->{longdesc} = "A well-traveled road stretches across the land, connecting distant towns and castles.";
        return;
    }
    if ($feature eq "Bridge") {
        $room->{shortdesc} = titlecase("Stone Bridge");
        $room->{longdesc} = "A sturdy stone bridge crosses the river here, allowing safe passage.";
        return;
    }

   
    my %feature_dirs;
    my %feature_desc;
    my %feature_distance;
    
   
    my $MAX_VIEW_DISTANCE = 5;
    
    unless ($region eq "Town" || $region eq "Castle") {
        for my $dx (-$MAX_VIEW_DISTANCE..$MAX_VIEW_DISTANCE) {
            for my $dy (-$MAX_VIEW_DISTANCE..$MAX_VIEW_DISTANCE) {
                next if $dx == 0 && $dy == 0;
                
               
                my $distance = sqrt($dx*$dx + $dy*$dy);
                next if $distance > $MAX_VIEW_DISTANCE;
                
                my $k = ($x+$dx).",".($y+$dy).",$z";
                next unless exists $rooms{$k};
                my $r = $rooms{$k}->{region};
                my ($feature_id, $desc_base);
                
                if ($r eq "Town" && $rooms{$k}->{town_name}) {
                    $feature_id = "Town:" . $rooms{$k}->{town_name};
                    $desc_base = "the town of $rooms{$k}->{town_name}";
                } elsif ($r eq "Castle" && $rooms{$k}->{castle_name}) {
                    $feature_id = "Castle:" . $rooms{$k}->{castle_name};
                    $desc_base = "$rooms{$k}->{castle_name} Castle";
                } elsif ($r eq "Mountain") {
                    $feature_id = "Mountain";
                    $desc_base = "mountains";
                } elsif ($r eq "Lake") {
                    $feature_id = "Lake";
                    $desc_base = "a lake";
                } elsif ($r eq "River") {
                    $feature_id = "River";
                    $desc_base = $rooms{$k}->{river_name} ? $rooms{$k}->{river_name} : "a river";
                }
                
                if ($feature_id) {
                    my $dir = direction_from($dx, $dy);
                    push @{ $feature_dirs{$feature_id} }, $dir;
                    $feature_desc{$feature_id} = $desc_base;
                    
                   
                    if (!defined($feature_distance{$feature_id}) || $distance < $feature_distance{$feature_id}) {
                        $feature_distance{$feature_id} = $distance;
                    }
                }
            }
        }
    }

    my @dir_order = qw(north south east west northeast northwest southeast southwest nearby);

    my @visible;
    for my $feature_id (keys %feature_dirs) {
        my %dir_count;
        $dir_count{$_}++ for @{ $feature_dirs{$feature_id} };
        my $chosen_dir = '';
        foreach my $dir (@dir_order) {
            if ($dir_count{$dir}) {
                $chosen_dir = $dir;
                last;
            }
        }
        
        if ($chosen_dir) {
            my $desc_base = $feature_desc{$feature_id};
            my $distance = $feature_distance{$feature_id};
            
           
            my $distance_desc = 
                $distance <= 1 ? "very close to the $chosen_dir" :
                $distance <= 2 ? "to the $chosen_dir" :
                $distance <= 3 ? "in the $chosen_dir distance" :
                $distance <= 4 ? "far to the $chosen_dir" :
                "very far to the $chosen_dir";
            
            push @visible, "$desc_base $distance_desc";
        }
    }

    if (@visible) {
        if ($region eq "Grass") {
            $room->{shortdesc} = titlecase("Open Grassland");
            $room->{longdesc} = "You are in open grassland. " . 
                (@visible > 1 ? "You can see " : "You can see ") . 
                join(", ", @visible) . ".";
        } elsif ($region eq "Forest") {
            $room->{shortdesc} = titlecase("Dense Forest");
            $room->{longdesc} = "You are in a dense forest. Tall trees tower overhead, but " . 
                (@visible > 1 ? "through gaps in the canopy you can see " : "through a gap in the canopy you can see ") . 
                join(", ", @visible) . ".";
        } elsif ($region eq "Hill") {
            $room->{shortdesc} = titlecase("Rolling Hills");
            $room->{longdesc} = "You are on rolling hills. From this vantage point, you can see " . 
                join(", ", @visible) . ".";
        } elsif ($region eq "Swamp") {
            $room->{shortdesc} = titlecase("Murky Swamp");
            $room->{longdesc} = "You are in a murky swamp. The ground is soggy underfoot. Beyond the mist, you can see " . 
                join(", ", @visible) . ".";
        } else {
            $room->{shortdesc} = titlecase("Open Land");
            $room->{longdesc} = "You are in open countryside. You can see " . 
                join(", ", @visible) . ".";
        }
    } else {
        if ($region eq "Grass") {
            $room->{shortdesc} = titlecase("Open Grassland");
            $room->{longdesc} = "You are in open grassland. The wind rustles through the tall grass.";
        } elsif ($region eq "Forest") {
            $room->{shortdesc} = titlecase("Dense Forest");
            $room->{longdesc} = "You are in a dense forest. Tall trees tower overhead, blocking most of the sunlight.";
        } elsif ($region eq "Hill") {
            $room->{shortdesc} = titlecase("Rolling Hills");
            $room->{longdesc} = "You are on rolling hills. The view offers mostly more hills in all directions.";
        } elsif ($region eq "Swamp") {
            $room->{shortdesc} = titlecase("Murky Swamp");
            $room->{longdesc} = "You are in a murky swamp. The ground is soggy underfoot and mist limits visibility.";
        } else {
            $room->{shortdesc} = titlecase("Open Land");
            $room->{longdesc} = "You are in open countryside. Nothing remarkable is visible in any direction.";
        }
    }
}

# Helper to get compass direction from dx/dy
sub direction_from {
    my ($dx, $dy) = @_;
    return "north"     if $dx == 0  && $dy < 0;
    return "south"     if $dx == 0  && $dy > 0;
    return "east"      if $dx > 0   && $dy == 0;
    return "west"      if $dx < 0   && $dy == 0;
    return "northeast" if $dx > 0   && $dy < 0;
    return "northwest" if $dx < 0   && $dy < 0;
    return "southeast" if $dx > 0   && $dy > 0;
    return "southwest" if $dx < 0   && $dy > 0;
    return "nearby";
}

# Helper to check overlap between clusters (bounding box)
sub clusters_overlap {
    my ($x1, $y1, $w1, $h1, $x2, $y2, $w2, $h2) = @_;
    return !($x1+$w1 < $x2 || $x2+$w2 < $x1 || $y1+$h1 < $y2 || $y2+$h2 < $y1);
}

for my $entrance_key (@dungeon_entrance_keys) {
    generate_dungeon_map($entrance_key, \$next_idx, \%rooms, \@room_keys);
}

sub assign_monsterclass {
    my ($room) = @_;
    my $region  = $room->{region}   // '';
    my $feature = $room->{feature}  // '';
    my $sd      = lc($room->{shortdesc} // '');
    my $ld      = lc($room->{longdesc} // '');

   
    $region  //= '';
    $feature //= '';
    $sd      //= '';
    $ld      //= '';

   
    if ($feature eq "Plaza" || $sd =~ /town square/ || $sd =~ /plaza/) {
        $room->{monsterclass} = 51;
        return;
    }

   
    if ($feature =~ /Guild|Shop|Temple|Inn|Tavern|LockedHouse|Vault|DungeonVault|CaveLake|Drawbridge|Keep|ThroneRoom|Court|Sanctuary|Armory|Prison|Catacomb|Lounge|Pawn|Smith|Slum|Cafe|Hall|Arena|Lookout|Training|Resurrection|Laborator|Chamber|Cell|Jail|Quarters|Storage|Balcony|Library|Back Room|Alchemist|Pipe|Lair|Nest|Shack|Hidden|Back Alley|Park|Courthouse|Torture|Pit|Hole|Tree|Trunk|Meeting|Workshop/) {
        $room->{monsterclass} = 0;
        return;
    }

   
    if ($feature =~ /Tower|Spiral|Barracks|Arena|Catacomb|Lookout/ || $sd =~ /spiral steps|arena|catacomb|barracks|tower|lookout/) {
        $room->{monsterclass} = 5;
        return;
    }

   
    if ($feature =~ /Court|GateTower|Stone|Pavement|Wall|Road|Bridge/ || ($region eq "Castle" && $feature eq "CastleRoom") || $sd =~ /castle wall|stone pavement|cobble|road|path|bridge/) {
        $room->{monsterclass} = 2;
        return;
    }

   
    if ($feature =~ /Stream|Dirt|Tunnel|CaveTunnel|Cave|Pit/ || $sd =~ /stream|dirt road|tunnel|pit|cave/) {
        $room->{monsterclass} = 4;
        return;
    }

   
    if ($feature =~ /DungeonCorridor|DungeonVault/) {
        $room->{monsterclass} = ($feature eq "DungeonVault" ? 3 : 2);
        return;
    }

   
    if ($region eq "Grass" || $feature eq "House" || $feature eq "Wharf" || $feature eq "Field" || $feature eq "Road" || $feature eq "Bridge" || $feature eq "Lake" || $feature eq "Swamp" || $feature eq "Forest" || $feature eq "Hill" || $feature eq "Moat") {
        $room->{monsterclass} = 1;
        return;
    }

   
    $room->{monsterclass} = ($region =~ /Town|Castle|Dungeon|Cave/ || $feature =~ /Room|Chamber|Cell|Hall|Quarters|Storage|Balcony|Library|Back Room|Alchemist|Pipe|Lair|Nest|Shack|Hidden|Back Alley|Park|Courthouse|Torture|Pit|Hole|Tree|Trunk|Meeting|Workshop/) ? 0 : 1;

    if ($feature =~ /DungeonCorridor|DungeonVault/) {
       
        $room->{monsterclass} = ($feature eq "DungeonVault") ? 3 : 
                                ($room->{z} && $room->{z} > 3) ? 3 : 
                                ($room->{z} && $room->{z} > 1) ? 2 : 1;
        return;
    }
}

my $monster_count = scalar(@monsters);
my $npc_count = scalar(@npcs);

for my $room (values %rooms) {
    assign_monsterclass($room);
    my $feature = $room->{feature} // '';
    my $region  = $room->{region}  // '';
   
    next if $room->{monsterclass} && $room->{monsterclass} > 0;
   
    if ($feature eq "Shop" && $npc_count > 0) {
       
        my $npc_idx = 0;
        $room->{monsterclass} = $monster_count + $npc_idx + 1;
    }
   
    if ($feature eq "Temple" && $npc_count > 1) {
        my $npc_idx = 1;
        $room->{monsterclass} = $monster_count + $npc_idx + 1;
    }
   
    if ($feature eq "Tavern" && $npc_count > 2) {
        my $npc_idx = 2;
        $room->{monsterclass} = $monster_count + $npc_idx + 1;
    }
   
}

my $fixed_exits = 0;
for my $key (@room_keys) {
    my $room = $rooms{$key};
    my ($x, $y, $z) = ($room->{x}, $room->{y}, $room->{z});
    my $region = $room->{region} // '';
   
    next if $region eq "Cave" || $region eq "Dungeon";
    next if $room->{impassable};
    my %dir_delta = (
        N  => [ 0, -1], S  => [ 0,  1], E  => [ 1,  0], W  => [-1,  0],
        NE => [ 1, -1], SE => [ 1,  1], SW => [-1,  1], NW => [-1, -1],
    );
    for my $dir (keys %dir_delta) {
        my ($dx, $dy) = @{$dir_delta{$dir}};
        my $nx = $x + $dx;
        my $ny = $y + $dy;
        my $nkey = "$nx,$ny,$z";
        next if $nx < 0 || $nx >= $WIDTH || $ny < 0 || $ny >= $HEIGHT;
        next unless exists $rooms{$nkey};
        my $neighbor = $rooms{$nkey};
        next if $neighbor->{impassable};
        next if $neighbor->{region} eq "Cave" || $neighbor->{region} eq "Dungeon";
       
        if (!$room->{exits}{$dir}) {
            $room->{exits}{$dir} = $neighbor->{idx};
            $fixed_exits++;
        }
    }
}

my %reverse_dir = (N=>'S', S=>'N', E=>'W', W=>'E', NE=>'SW', NW=>'SE', SE=>'NW', SW=>'NE');
my $impassable_adjusted = 0;

for my $key (@room_keys) {
    my $room = $rooms{$key};
    next unless $room->{impassable};
   
    $room->{exits} = {};
    my ($x, $y, $z) = ($room->{x}, $room->{y}, $room->{z});
    my %dir_delta = (
        N  => [ 0, -1], S  => [ 0,  1], E  => [ 1,  0], W  => [-1,  0],
        NE => [ 1, -1], SE => [ 1,  1], SW => [-1,  1], NW => [-1, -1],
    );
   
    for my $dir (keys %dir_delta) {
        my ($dx, $dy) = @{$dir_delta{$dir}};
        my $nx = $x + $dx;
        my $ny = $y + $dy;
        my $nkey = "$nx,$ny,$z";
        next unless exists $rooms{$nkey};
        my $neighbor = $rooms{$nkey};
        next if $neighbor->{impassable};
       
        $room->{exits}{$dir} = $neighbor->{idx};
        $impassable_adjusted++;
       
        my $rev = $reverse_dir{$dir};
        if ($neighbor->{feature} !~ /Bridge|Drawbridge/) {
            if (exists $neighbor->{exits}{$rev} && $neighbor->{exits}{$rev} == $room->{idx}) {
                delete $neighbor->{exits}{$rev};
            }
        }
    }
}

my $rooms_with_objects   = scalar grep { my $r = $rooms{$_}; defined($r->{object})    && $r->{object}    =~ /\S/ } keys %rooms;
my $rooms_with_hiddenobj = scalar grep { my $r = $rooms{$_}; defined($r->{hiddenobj}) && $r->{hiddenobj} =~ /\S/ } keys %rooms;
my $rooms_with_treasure  = scalar grep { my $r = $rooms{$_}; defined($r->{treasure})  && $r->{treasure}  =~ /\S/ } keys %rooms;

my %object_ids;
my %treasure_ids;
my %monster_classes;

for my $room (values %rooms) {
    $object_ids{$_}++   for grep { $_ > 0 } split(/\s+/, $room->{object}    // '');
    $object_ids{$_}++   for grep { $_ > 0 } split(/\s+/, $room->{hiddenobj} // '');
    $treasure_ids{$_}++ for grep { $_ > 0 } split(/\s+/, $room->{treasure}  // '');
    $monster_classes{$room->{monsterclass}}++ if defined $room->{monsterclass};
}

# Remove exits from passable rooms into impassable rooms
my $exits_removed = 0;

# Build a fast lookup: idx => $room
my %idx_to_room = map { $rooms{$_}->{idx} => $rooms{$_} } @room_keys;

for my $key (@room_keys) {
    my $room = $rooms{$key};
    next if $room->{impassable};
   
    for my $dir (keys %{ $room->{exits} }) {
        my $dest_idx = $room->{exits}{$dir};
        my $dest_room = $idx_to_room{$dest_idx};
        if ($dest_room && $dest_room->{impassable}) {
            delete $room->{exits}{$dir};
            $exits_removed++;
        }
    }
}

# Helper to robustly check a DOWN/UP linkage for a given entrance
sub verify_vertical_linkage {
    my ($entrance_key, $expected_region, $label) = @_;
    my $entrance_room = $rooms{$entrance_key};
    my $down_idx = $entrance_room->{exits}{'DOWN'} // 0;
    if (!$down_idx) {
        return;
    }
    my $found = 0;
    for my $key (keys %rooms) {
        my $r = $rooms{$key};
       
        unless (
            ref($r) eq 'HASH'
            && defined($r->{idx})
            && defined($r->{region})
            && !ref($r->{region})
            && $r->{region} ne ''
        ) {
            next;
        }
       
        next unless $r->{region} eq $expected_region;
       
       
        if ($r->{idx} == $down_idx) {
            $found = 1;
           
            if (!defined($r->{exits}{'UP'}) || $r->{exits}{'UP'} != $entrance_room->{idx}) {
            }
            last;
        }
    }
}

# Check cave entrances
for my $entrance_key (@cave_entrance_keys) {
    verify_vertical_linkage($entrance_key, "Cave", "Cave");
}

# Check dungeon entrances
for my $entrance_key (@dungeon_entrance_keys) {
    verify_vertical_linkage($entrance_key, "Dungeon", "Dungeon");
}

for my $i (0..$#towns) {
}
for my $i (0..$#castles) {
    $castle_name_map{$i} = $castle_names[$i % @castle_names];
}

my $desc_count = 0;
for my $key (sort { $rooms{$a}->{idx} <=> $rooms{$b}->{idx} } keys %rooms) {
    my $room = $rooms{$key};
    eval {
        describe_room($room);
    };
    if ($@ or !defined($room->{shortdesc}) or $room->{shortdesc} eq '' or !defined($room->{longdesc}) or $room->{longdesc} eq '') {
        print STDERR "\nERROR: Failed to describe room $key (idx $room->{idx}, region $room->{region}, feature $room->{feature})\n";
        print STDERR "  shortdesc: ", (defined $room->{shortdesc} ? $room->{shortdesc} : '[undef]'), "\n";
        print STDERR "  longdesc: ", (defined $room->{longdesc} ? $room->{longdesc} : '[undef]'), "\n";
        print STDERR "  Exception: $@\n" if $@;
        exit 2;
    }
    $desc_count++;
}

my $boss_persistence = "$config{'home'}/$config{'data'}/boss_persistence.dat";
if (-e $boss_persistence) {
    unlink $boss_persistence or warn "Could not delete $boss_persistence: $!";
}

my $rooms_dat_path = "$config{'home'}$config{'data'}/rooms.dat";
open(my $dat, ">:raw", $rooms_dat_path) or die "Can't write $rooms_dat_path: $!";

my $write_count = 0;
for my $key (@room_keys) {
    my $room = $rooms{$key};

   
    $room->{flags}               //= '';
    $room->{longdesc}            //= '';
    $room->{monsterclass}        //= 0;
    $room->{object}              //= '';
    $room->{hiddenobj}           //= '';
    $room->{shortdesc}           //= '';
    $room->{treasure}            //= '';
    $room->{trecharges}          //= '';
    $room->{container}           //= '';
    $room->{container_permanent} //= 0;
    $room->{region}              //= '';
    $room->{feature}             //= '';
    $room->{town_name}           //= '';
    $room->{castle_name}         //= '';
    $room->{river_name}          //= '';
    $room->{elevation}           //= 0;
    $room->{biome_data}          //= '';
    
    print $dat pack("S<", $room->{idx} // 0);

   
    for my $dir (@DIRS[0..11]) {
        my $dest = $room->{exits}{$dir} // 0;
        print $dat pack("f<", $dest + 0);
    }

   
    my $flags = $room->{flags} // '';
    $flags = substr($flags,0,40); $flags .= "\0" x (40-length($flags));
    print $dat $flags;

   
    my $ld = $room->{longdesc} // '';
    $ld = substr($ld,0,400); $ld .= " "x(400-length($ld));
    print $dat $ld;

   
    print $dat pack("s<", $room->{monsterclass} + 0);

   
    my @obj = (0) x 20;
    if (defined $room->{object} && $room->{object} =~ /\S/) {
        @obj = split(/\s+/, $room->{object});
        @obj = map { int($_) } @obj;
        push @obj, (0) x (20-@obj) if @obj < 20;
        @obj = @obj[0..19] if @obj > 20;
    }
    print $dat pack("s<20", @obj);

   
    my @hobj = (0) x 20;
    if (defined $room->{hiddenobj} && $room->{hiddenobj} =~ /\S/) {
        @hobj = split(/\s+/, $room->{hiddenobj});
        @hobj = map { int($_) } @hobj;
        push @hobj, (0) x (20-@hobj) if @hobj < 20;
        @hobj = @hobj[0..19] if @hobj > 20;
    }
    print $dat pack("s<20", @hobj);

   
    my $sd = $room->{shortdesc} // '';
    $sd = substr($sd,0,80); $sd .= " "x(80-length($sd));
    print $dat $sd;

   
    my @tre = (0) x 20;
    if (defined $room->{treasure} && $room->{treasure} =~ /\S/) {
        @tre = split(/\s+/, $room->{treasure});
        @tre = map { int($_) } @tre;
        push @tre, (0) x (20-@tre) if @tre < 20;
        @tre = @tre[0..19] if @tre > 20;
    }
    print $dat pack("s<20", @tre);

   
    my @trc = (0) x 20;
    if (defined $room->{trecharges} && $room->{trecharges} =~ /\S/) {
        @trc = split(/\s+/, $room->{trecharges});
        @trc = map { int($_) } @trc;
        push @trc, (0) x (20-@trc) if @trc < 20;
        @trc = @trc[0..19] if @trc > 20;
    }
    print $dat pack("s<20", @trc);

   
    my $cont = $room->{container} // '';
    $cont = substr($cont,0,246); $cont .= "\0" x (246-length($cont));
    print $dat $cont;
    print $dat pack("s<", $room->{container_permanent} + 0);

   
    my $region = $room->{region} // '';
    $region = substr($region,0,16); $region .= " "x(16-length($region));
    print $dat $region;

   
    my $feature = $room->{feature} // '';
    $feature = substr($feature,0,16); $feature .= " "x(16-length($feature));
    print $dat $feature;

   
    my $town_name = $room->{town_name} // '';
    $town_name = substr($town_name,0,24); $town_name .= " "x(24-length($town_name));
    print $dat $town_name;

   
    my $castle_name = $room->{castle_name} // '';
    $castle_name = substr($castle_name,0,24); $castle_name .= " "x(24-length($castle_name));
    print $dat $castle_name;

   
    my $river_name = $room->{river_name} // '';
    $river_name = substr($river_name,0,24); $river_name .= " "x(24-length($river_name));
    print $dat $river_name;

    my $x = $room->{x};
    my $y = $room->{y};
    my $elev = $elevation{"$x,$y"} // 0.0;
    my $biome = $biome{"$x,$y"} // 'grass';

    # Pack elevation as float (-1.0 to 1.0)
    print $dat pack("f<", $elev);

    # Pack biome as 8-byte string
    my $biome_packed = substr($biome . (' ' x 8), 0, 8);
    print $dat pack("a8", $biome_packed);
    
    # Pack explicit x, y, z coordinates (for caves/dungeons which don't follow grid)
    # For surface rooms: use their actual x,y coords, z=0
    # For cave/dungeon rooms: use the entrance coordinates + local offset for map display
    my $coord_x = $room->{x} // 0;
    my $coord_y = $room->{y} // 0;
    my $coord_z = $room->{z} // 0;
    
    # For cave/dungeon rooms, we need to calculate absolute coordinates
    # The key format is "cave:entrance_idx:local_x:local_y:local_z"
    # or "dungeon:entrance_idx:local_x:local_y:local_z"
    if ($key =~ /^(cave|dungeon):(\d+):(\d+):(\d+):(\d+)$/) {
        my ($type, $entrance_idx, $local_x, $local_y, $local_z) = ($1, $2, $3, $4, $5);
        
        # Find the entrance room to get its coordinates
        for my $ekey (keys %rooms) {
            if ($rooms{$ekey}->{idx} == $entrance_idx) {
                my $entrance = $rooms{$ekey};
                # Calculate absolute position: entrance coords + local offset
                # For caves/dungeons, we go "down" so z is negative (underground)
                $coord_x = ($entrance->{x} // 0) + $local_x - 6;  # Center offset (cave_size/2)
                $coord_y = ($entrance->{y} // 0) + $local_y - 6;  # Center offset
                $coord_z = -($local_z + 1);  # Negative z for underground (1 = first underground level)
                last;
            }
        }
    }
    
    print $dat pack("l<", $coord_x);  # Signed 32-bit int for x
    print $dat pack("l<", $coord_y);  # Signed 32-bit int for y
    print $dat pack("l<", $coord_z);  # Signed 32-bit int for z

    $write_count++;
}

close $dat;

open(my $meta, ">:utf8", "data/photonmud/boss_landmarks.txt") or die "Can't write boss_landmarks.txt: $!";
print $meta "# entrance_type|vault_type|nearest_type|nearest_name|room_index\n";

my %used_boss_landmark;

for my $entrance_key (@dungeon_entrance_keys) {
    my $entrance_room = $rooms{$entrance_key};
    my $entrance_idx = $entrance_room->{idx};
    my ($vault_room);
    for my $key (keys %rooms) {
        next unless $key =~ /^dungeon:\Q$entrance_idx\E:/;
        my $r = $rooms{$key};
        if ($r->{feature} eq "DungeonVault") {
            $vault_room = $r;
            last;
        }
    }
    next unless $vault_room;
    my $vault_type = $vault_room->{feature} // "DungeonVault";
    my $room_idx = $vault_room->{idx};
    my $type = $entrance_room->{entrance_landmark_type} // '';
    my $name = $entrance_room->{entrance_landmark_name} // '';
    next if !$type || !$name;
    next if $used_boss_landmark{$type . "|" . $name}++;
    print $meta join("|", "Dungeon", $vault_type, $type, $name, $room_idx), "\n";
}

my $cave_boss_written = 0;
for my $entrance_key (@cave_entrance_keys) {
    my $entrance_room = $rooms{$entrance_key};
    my $entrance_idx = $entrance_room->{idx};
    my ($deepest_room, $maxz) = (undef, -1);
    for my $key (keys %rooms) {
        next unless $key =~ /^cave:\Q$entrance_idx\E:/;
        my $r = $rooms{$key};
        next unless $r->{region} eq "Cave";
        if ($r->{z} > $maxz) {
            $maxz = $r->{z};
            $deepest_room = $r;
        }
    }
    next unless $deepest_room;
    my $vault_type = $deepest_room->{feature} // "CaveTunnel";
    my $room_idx = $deepest_room->{idx};
    my $type = $entrance_room->{entrance_landmark_type} // '';
    my $name = $entrance_room->{entrance_landmark_name} // '';
    next if !$type || !$name;
    if (!$used_boss_landmark{$type . "|" . $name}++ || !$cave_boss_written) {
        print $meta join("|", "Cave", $vault_type, $type, $name, $room_idx), "\n";
        $cave_boss_written = 1;
    }
}

my @tower_keys = grep { $rooms{$_}->{feature} eq "Tower" } keys %rooms;
if (@tower_keys) {
    my $tower_key = $tower_keys[int(rand(@tower_keys))];
    my $tower = $rooms{$tower_key};
    my $vault_type = $tower->{feature} // "Tower";
    my ($x, $y, $z) = ($tower->{x}, $tower->{y}, $tower->{z});
    my $nearest = find_nearest_landmark($x, $y, $z);
    my ($lx, $ly, $lz, $type, $name) = @$nearest;
    my $room_idx = $tower->{idx};
    unless ($used_boss_landmark{$type . "|" . $name}++) {
        print $meta join("|", "Tower", $vault_type, $type, $name, $room_idx), "\n";
    }
}

close($meta);

# Market record structure (persistent market table)
# 30 name, 16 item, 16 seller, 4 price, 4 idx, 2 type, 2 charges, 16 date, 38 reserved = 128 bytes

my @market_records;

# Helper: Add a market listing (called when generating shops)
sub add_market_listing {
    my ($item_name, $seller_name, $price, $type, $idx, $charges) = @_;
    my $date = scalar localtime;
    my $rec = {
        name    => $item_name,
        item    => $item_name,
        seller  => $seller_name,
        price   => $price,
        idx     => $idx,
        type    => $type,
        charges => $charges,
        date    => $date,
    };
    push @market_records, $rec;
}

# Collect information about treasure held by monsters to avoid duplication
for my $room (values %rooms) {
    if ($room->{monsterclass} && $room->{monsterclass} > 0) {
        my @tre = split(/\s+/, $room->{treasure} // '');
        $treasure_held_by_monsters{$_}++ for grep { $_ > 0 } @tre;
    }
}

# Collect information about treasure already placed in the realm
for my $room (values %rooms) {
    my @tre = split(/\s+/, $room->{treasure} // '');
    $treasure_placed_in_realm{$_}++ for grep { $_ > 0 } @tre;
}

# Define shop types for different towns
my @shop_types = (
    "General Store", "Armory", "Magic Shop", "Potion Shop", 
    "Blacksmith", "Tailor", "Adventurer's Outfitter", "Rare Goods Emporium"
);

# Process shops in towns
my $town_shop_count = 0;
for my $room_id (keys %rooms) {
    my $room = $rooms{$room_id};
    my $feature = $room->{feature} // '';
    my $region  = $room->{region}  // '';
    
    if ($feature eq "Shop") {
        my $town_name = $room->{town_name} // "Town";
        # Use the shop_type assigned by generate_town_shops instead of random selection
        my $shop_type = $room->{shop_type} // $shop_types[int(rand(@shop_types))];
        my $shop_name = "$town_name $shop_type";
        
        # Determine inventory size based on town presence
        my $town_size = get_town_size($town_name);
        my $inventory_size = 5 + int($town_size/2) + int(rand(4));  # 5-15 items based on town size
        
        # Generate balanced inventory using the shop's specialization
        add_shop_inventory($shop_name, $shop_type, $inventory_size);
        $town_shop_count++;
    }
}

# Add black market items - scale with world size
my $black_market_size = int(sqrt(scalar(keys %rooms)) / 10) + 5;  # Scaled by square root of room count
generate_black_market_items($black_market_size);

# Sort market records by price (lowest first)
@market_records = sort { $a->{price} <=> $b->{price} } @market_records;

# Write market data to file
my $market_file = "$config{'home'}/$config{'data'}/market.dat";
my $market_reclen = 200;

open(my $mfh, ">:raw", $market_file) or die "Can't write $market_file: $!";
binmode($mfh);

for my $rec (@market_records) {
    # Initialize a null-padded buffer
    my $buf = "\0" x $market_reclen;
    
    # Safely prepare and truncate each field
    my $name = substr($rec->{name} // '', 0, 30);
    my $item = substr($rec->{item} // '', 0, 16);
    my $seller = substr($rec->{seller} // '', 0, 16);
    my $date = substr($rec->{date} // '', 0, 16);
    
    # Pack each field with proper padding
    substr($buf, 0, 40) = pack("a40", $name);      # 40 bytes (increased from 30)
    substr($buf, 40, 40) = pack("a40", $item);     # 40 bytes (increased from 16)
    substr($buf, 80, 40) = pack("a40", $seller);   # 40 bytes (increased from 16)
    substr($buf, 120, 4) = pack("l<", $rec->{price} // 0);    # 4 bytes
    substr($buf, 124, 4) = pack("l<", $rec->{idx} // 0);      # 4 bytes
    substr($buf, 128, 2) = pack("s<", $rec->{type} // 0);     # 2 bytes
    substr($buf, 130, 2) = pack("s<", $rec->{charges} // 1);  # 2 bytes
    substr($buf, 132, 24) = pack("a24", $date);    # 24 bytes (increased from 16)
    # remaining 44 bytes are already null-padded
    
    print $mfh $buf or die "Failed to write market record: $!";
}

close($mfh) or die "Failed to close market file: $!";

# Calculate market statistics for reporting
my $market_total = scalar(@market_records);
my %market_sellers;
my %market_types;
my %market_items;
my $market_min_price = undef;
my $market_max_price = undef;
my $market_sum_price = 0;

for my $rec (@market_records) {
    $market_sellers{$rec->{seller}}++;
    $market_types{$rec->{type} == 1 ? 'Object' : 'Treasure'}++;
    $market_items{$rec->{item}}++;
    $market_min_price = $rec->{price} if !defined($market_min_price) || $rec->{price} < $market_min_price;
    $market_max_price = $rec->{price} if !defined($market_max_price) || $rec->{price} > $market_max_price;
    $market_sum_price += $rec->{price};
}

# Prepare top seller/item stats for reporting
my $seller_rank = 0;
for my $seller (sort { $market_sellers{$b} <=> $market_sellers{$a} } keys %market_sellers) {
    last if ++$seller_rank > 5;
}
my $item_rank = 0;
for my $item (sort { $market_items{$b} <=> $market_items{$a} } keys %market_items) {
    last if ++$item_rank > 5;
}

my $realm_name = generate_realm_name();
my $realm_file = "data/photonmud/realm.txt";
open(my $rfh, ">:utf8", $realm_file) or die "Can't write $realm_file: $!";
print $rfh "$realm_name\n";
close($rfh);

print "World statistics:\n";
print "  Total rooms: ", scalar(keys %rooms), "\n";
print "  Mountain rooms: $mountain_rooms\n";
print "  Lake rooms: $lake_rooms\n";
print "  Towns: ", scalar(@towns), "\n";
print "  Castles: ", scalar(@castles), "\n";
print "  Cave systems: ", scalar(@cave_entrance_keys), "\n";
print "  Dungeon complexes: ", scalar(@dungeon_entrance_keys), "\n";
print "  Rooms with objects: $rooms_with_objects\n";
print "  Rooms with hidden objects: $rooms_with_hiddenobj\n";
print "  Rooms with treasure: $rooms_with_treasure\n";
print "\nMarket statistics:\n";
print "  Total listings: $market_total\n";
print "  Price range: $market_min_price - $market_max_price gold\n";
print "  Average price: ", int($market_sum_price / ($market_total || 1)), " gold\n";
print "  Object types: ", join(", ", map { "$_ ($market_types{$_})" } sort keys %market_types), "\n";
print "\nRealm name: $realm_name\n";