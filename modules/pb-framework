#!/usr/bin/perl
#
#  Photon BBS Framework
#  (C) 2002-2013 Fewtarius

use Fcntl qw(:DEFAULT :flock);
use POSIX qw(strftime);
use Sys::Syslog qw(openlog syslog closelog);
use File::Find ();
use File::Path qw(remove_tree);

# HTTP::Tiny for webhook notifications (replaces system("curl ...") calls)
# Core module since Perl 5.14 - no CPAN required
our $HAS_HTTP_TINY = 0;
eval {
    require HTTP::Tiny;
    $HAS_HTTP_TINY = 1;
};

# POSIX::Termios for terminal control (replaces system("stty ...") calls)
# Benefits: Zero child processes, signal-safe, reliable save/restore
our $INITIAL_TERMIOS;  # Saved pristine terminal state
our $HAS_POSIX_TERMIOS = 0;
our $TERMINAL_MODE = 0;  # Track current mode: 0=normal, 1=cbreak

eval {
    require POSIX;
    POSIX->import(qw(:termios_h));
    $HAS_POSIX_TERMIOS = 1;
};

# TIOCGWINSZ constant for ioctl-based terminal size detection
# macOS: 0x40087468, Linux: 0x5413
our $TIOCGWINSZ;
eval {
    require Config;
    if ($Config::Config{osname} && $Config::Config{osname} eq 'linux') {
        $TIOCGWINSZ = 0x5413;
    } else {
        # macOS, FreeBSD, and most other Unix
        $TIOCGWINSZ = 0x40087468;
    }
};

# SECURITY: Global hash to track active lock filehandles
our %GLOBAL_LOCK_FH;

# ============================================================================
# DATE/TIME HELPERS - Use Perl instead of forking to `date` command
# ============================================================================
sub get_current_time {
    return strftime("%H:%M", localtime);
}

sub get_current_date {
    return strftime("%Y-%b-%d", localtime);
}
# ============================================================================

sub doevents {
  $currenttime=time;
  $idletime=$currenttime-$idle;
  $idlenotifycheck=$config{'idledisconnect'}/2;
  if ($idletime >= $idlenotifycheck) {
    if ($idlenotified eq 0) {
      writeline($config{'errorcolor'}."\e[s\nWarning: Your session will be disconnected in ".$idlenotifycheck." seconds due to inactivity.\e[u");
      $idlenotified=1;
    }
  }
  if ($idletime >= $config{'idledisconnect'}) {
    errorout("idle session terminated.");
  }
  $cppid = getppid;
  if ($ppid != $cppid) {
    errorout("parent process died, terminating.");
  }
  if ($atmenu eq "1") {
    unless ($noevents eq "1") {
      getpages();
    }
  }
}

sub section_header {
    my ($label) = @_;
    use constant BORDER_LEN => 79;
    my $pad = int((BORDER_LEN - length($label) - 4) / 2);
    # ───┤ label ├─── using PETSCII for C64, CP437 for modern terminals
    return (boxchar('horizontal') x $pad) . boxchar('tleft') . " $label " . boxchar('tright') . (boxchar('horizontal') x ($pad + (BORDER_LEN - length($label) - 4) % 2));
}

sub section_footer {
    my $border = boxchar('horizontal') x 79;
    return boxchar('bottomleft') . $border . boxchar('bottomright');
}

sub usersonline {
  @userlst=<$config{'home'}$config{'nodes'}/*>;
  $sysinfo{'users'}=scalar(@userlst);
  if ($sysinfo{'users'} < 0) {
    $sysinfo{'users'}=0;
  }
  @userlst=();
}

sub whosonline {
  writeline($config{'themecolor'}."\nWho's Online".$config{'promptcolor'}.":",1);

  # Collect all node files
  my @whosonline = ();
  my @node_files = <$config{'home'}$config{'nodes'}/*>;

  foreach my $node_file (@node_files) {
    open(my $fh, "<", $node_file) or next;
    my $line = <$fh>;
    close($fh);
    chomp($line);

    # Parse the node file data
    my ($ip, $node, $pid, $time, $user, $proto, $location) = split(/\|/, $line);

    # Validate the data format
    next unless defined $ip && defined $node && defined $pid && defined $time && defined $user && defined $proto && defined $location;

    # Calculate idle time
    my $idle_time = int(time - $time);
    my $idle_display = $idle_time > 60 ? sprintf("%dm", $idle_time / 60) : sprintf("%ds", $idle_time);

    # Load user status
    my $status = "Avail"; # Shortened for 80 cols
    my $uid = finduserid($user);
    my $is_hidden = 0;
    if ($uid ne "") {
      my $user_file = "$config{'home'}$config{'data'}/users/$uid.dat";
      if (open(my $ufh, "<", $user_file)) {
        while (<$ufh>) {
          $status .= "/DND" if /^dnd=1/;
          if (/^hidden=Y/) {
            $status .= "/Inv";
            $is_hidden = 1;
          }
        }
        close($ufh);
      }
    }

    # Skip hidden users unless the current user has sec_sysop or higher
    if ($is_hidden == 1 && $info{'sec_level'} < $config{'sec_sysop'}) {
      next;
    }

    # Format the data for display
    push @whosonline, {
      node      => sprintf("%03d", $node),
      user      => $user,
      proto     => $proto,
      location  => $location,
      idle_time => $idle_display,
      status    => $status,
    };
  }

  # Sort by node number
  @whosonline = sort { $a->{node} <=> $b->{node} } @whosonline;

  # Width-aware display format
  my $width = $config{'terminal_width'} || 80;
  
  if ($width == 40) {
    # 40-column format: Node(4) User(10) Via(7) Loc(16) = 37 chars
    writeline($config{'systemcolor'} . sprintf("%-4s %-10s %-7s %-16s", "Node", "User", "Via", "Location"), 1);
    
    foreach my $entry (@whosonline) {
      my $node      = $entry->{node};
      my $user      = substr($entry->{user}, 0, 10);
      my $proto     = substr($entry->{proto}, 0, 7);
      my $location  = substr($entry->{location}, 0, 16);
      printf "%-4s %-10s %-7s %-16s\n",
        $node, $user, $proto, $location;
    }
  } else {
    # 80-column format: original spacing
    writeline($config{'systemcolor'} . sprintf("%-4s %-10s %-7s %-32s %-5s %-10s", "Node", "User", "Via", "Location", "Idle", "Status"), 1);
    
    foreach my $entry (@whosonline) {
      my $node      = $entry->{node};
      my $user      = substr($entry->{user}, 0, 10);
      my $proto     = substr($entry->{proto}, 0, 7);
      my $location  = substr($entry->{location}, 0, 32);
      my $idle_time = substr($entry->{idle_time}, 0, 5);
      my $status    = substr($entry->{status}, 0, 10);
      printf "%-4s %-10s %-7s %-32s %-5s %-10s\n",
        $node, $user, $proto, $location, $idle_time, $status;
    }
  }

  # If no users are online, display a message
  if (scalar(@whosonline) == 0) {
    writeline($config{'systemcolor'}."No users are currently online.", 1);
  }

  writeline($RST."\n");
  unless ($_[0] =~ /nopause/) {
    pause();
  }
}

sub iamat {
  unless (-d "$config{'home'}$config{'nodes'}") {
    mkdir "$config{'home'}$config{'nodes'}";
  }
  unless ($info{'hidden'} eq "Y") {
    $who = $_[0];
  } else {
    $who = "*** HIDDEN ***";
  }
  $location = $_[1];
  $whofile = $config{'home'} . $config{'nodes'} . "/" . $info{'node'};
  lockfile("$whofile");
  open(my $who_fh, '>', $whofile);
  print $who_fh $sysinfo{'ip'} . "|" . $info{'node'} . "|" . $$ . "|" . time . "|" . $info{'handle'} . "|" . $info{'proto'} . "|" . $location;
  close($who_fh);
  unlockfile("$whofile");
}


sub errorout {
  cbreak(off);
  logger ("ERROR".$config{'promptcolor'}.": ".$_[0]." ".$info{'handle'}." on node ".$info{'node'}." Exiting..");
  writeline ("\n".$config{'errorcolor'}."ERROR".$config{'promptcolor'}.": ".$config{'datacolor'}.$_[0]."\e[K\nExiting..\e[K\n",1);
  bye();
}

sub bye {
  if ($info{'handle'}) {}
  iamat($info{'handle'},"Logging off!");
  cbreak(off);
  writeline($theme{'goodbyemsg'}.$RST,1);
  if ($config{'nodupes'} eq 1) {
    if (-e "$config{'home'}$config{'data'}/iplist") {
      lockfile("$config{'home'}$config{'data'}/iplist");
      open (my $in_fh, '<', "$config{'home'}$config{'data'}/iplist");
      lockfile("$config{'home'}$config{'data'}/iplist_");
      open (my $out_fh, '>', "$config{'home'}$config{'data'}/iplist_");
       while (<$in_fh>) {
        chomp $_;
        if ($_ =~/$info{'connect'}/i) {
          next;
        } else {
           print $out_fh $_."\n";
        }
      }
      close($out_fh);
      unlockfile("$config{'home'}$config{'data'}/iplist_");
      close($in_fh);
      unlockfile("$config{'home'}$config{'data'}/iplist");
      unlink ("$config{'home'}$config{'data'}/iplist");
      rename ("$config{'home'}$config{'data'}/iplist_","$config{'home'}$config{'data'}/iplist");
    }
  }

  if (-e "$config{'home'}$config{'messages'}/teleconf/TELEPUB_/$info{'node'}") {
    unlink("$config{'home'}$config{'messages'}/teleconf/TELEPUB_/$info{'node'}");
  }

  if ($info{'handle'}) {
    logger("NOTICE".$config{'promptcolor'}.": ".$info{'handle'}." Logged off!");
  }
  # Clean up node files using Perl (no shell fork needed)
  if (defined $info{'node'} && $info{'node'} =~ /^\d+$/) {
    my $node_name = $info{'node'};
    my $home = $config{'home'};
    eval {
      File::Find::find({
        wanted => sub {
          if ($_ eq $node_name) {
            if (-d $File::Find::name) {
              remove_tree($File::Find::name, { safe => 1 });
            } else {
              unlink($File::Find::name);
            }
          }
        },
        no_chdir => 0,
      }, $home) if -d $home;
    };
  }

  if ( -e "$config{'doors'}/nodes/$info{'node'}" && $info{'node'} =~ /^\d+$/) {
    remove_tree("$config{'doors'}/nodes/$info{'node'}", { safe => 1 });
  }

  # Only remove node file if it matches our PID
  my $nodefile = "$config{'home'}$config{'nodes'}/$info{'node'}";
  if (-e $nodefile) {
    open(my $fh, '<', $nodefile);
    my $line = <$fh>;
    close($fh);
    my (undef, undef, $npid, undef, undef, undef, undef) = split(/\|/, $line);
    if ($npid && $npid == $$) {
      unlink $nodefile;
    }
  }

  # Remove user's IP from iplist
  if ($config{'nodupes'} eq "1" && -e "$config{'home'}$config{'data'}/iplist") {
    lockfile("$config{'home'}$config{'data'}/iplist");
    open(my $in, "<", "$config{'home'}$config{'data'}/iplist");
    open(my $out, ">", "$config{'home'}$config{'data'}/iplist_");
    while (<$in>) {
      chomp;
      next if /$info{'connect'}/i; # Skip the user's IP
      print $out "$_\n";
    }
    close($in);
    close($out);
    unlockfile("$config{'home'}$config{'data'}/iplist");
    unlink("$config{'home'}$config{'data'}/iplist");
    rename("$config{'home'}$config{'data'}/iplist_", "$config{'home'}$config{'data'}/iplist");
  }

  kill getppid;
  exit(0);
}

sub colorize {
  if ($info{'ansi'} eq "1") {
    $CLR="\e[2J\e[0H";
    $RST="\e[0m";
    $BLK="\e[0;30m"; #BLACK
    $RED="\e[0;31m"; #RED
    $GRN="\e[0;32m"; #GREEN
    $YLW="\e[0;33m"; #YELLOW
    $BLU="\e[0;34m"; #BLUE
    $MAG="\e[0;35m"; #MAGENTA
    $CYN="\e[0;36m"; #WHITE
    $WHT="\e[0;37m"; #CYAN
    $BBK="\e[1;30m"; #GREY
    $BRD="\e[1;31m"; #BRIGHT RED
    $BGN="\e[1;32m"; #BRIGHT GREEN
    $BYL="\e[1;33m"; #BRIGHT YELLOW
    $BBL="\e[1;34m"; #BRIGHT BLUE
    $BMG="\e[1;35m"; #BRIGHT MAGENTA
    $BCN="\e[1;36m"; #BRIGHT CYAN
    $BWH="\e[1;37m"; #BRIGHT WHITE
  } else {
    $CLR="";
    $RST="";
    $BLK="";
    $RED="";
    $GRN="";
    $YLW="";
    $BLU="";
    $MAG="";
    $WHT="";
    $CYN="";
    $BBK="";
    $BRD="";
    $BGN="";
    $BYL="";
    $BBL="";
    $BMG="";
    $BCN="";
    $BWH="";
    print "";
  }
}

# ============================================================================
# TERMINAL DETECTION - Detect terminal width and height capabilities
# ============================================================================
sub detect_terminal_size {
  my $width = undef;
  my $height = undef;

  # Method 1: ioctl(TIOCGWINSZ) - zero overhead, works on any PTY
  if ($TIOCGWINSZ) {
    eval {
      my $winsize = "\0" x 8;
      if (ioctl(STDIN, $TIOCGWINSZ, $winsize)) {
        my ($rows, $cols) = unpack('SS', $winsize);
        if ($cols && $rows && $cols > 0 && $rows > 0) {
          $width = $cols;
          $height = $rows;
        }
      }
    };
  }

  # Method 2: Environment variables (set by some terminals and photonbbs-tty)
  unless ($width) {
    if ($ENV{'COLUMNS'} && $ENV{'COLUMNS'} =~ /^\d+$/ && $ENV{'COLUMNS'} > 0) {
      $width = $ENV{'COLUMNS'};
    }
  }
  unless ($height) {
    if ($ENV{'LINES'} && $ENV{'LINES'} =~ /^\d+$/ && $ENV{'LINES'} > 0) {
      $height = $ENV{'LINES'};
    }
  }

  return ($width, $height);
}

sub initialize_terminal_config {
  my ($width, $height);

  # Check if user has a saved terminal preference in their profile
  if (defined $info{'terminal_width'} && $info{'terminal_width'} > 0) {
    $width = $info{'terminal_width'};
    $height = ($width == 40) ? 25 : 24;
  } else {
    # No saved preference - try detection
    ($width, $height) = detect_terminal_size();

    # If nothing detected, default to 80x24
    $width //= 80;
    $height //= 24;
  }

  # Validate reasonable ranges
  $width = 40 if ($width < 40);
  $width = 255 if ($width > 255);
  $height = 24 if ($height < 24);
  $height = 66 if ($height > 66);

  # Store in config for session-wide access
  $config{'terminal_width'} = $width;
  $config{'terminal_height'} = $height;

  # Update rows for pagination
  $config{'rows'} = $height - 1;
  
  # Determine UI mode based on width
  if ($width < 60) {
    $config{'ui_mode'} = 'compact';
  } elsif ($width >= 100) {
    $config{'ui_mode'} = 'enhanced';
  } else {
    $config{'ui_mode'} = 'standard';
  }
  
  return ($width, $height);
}

# ============================================================================
# BOX DRAWING CHARACTERS - PETSCII vs CP437
# ============================================================================
# Returns appropriate box-drawing character based on terminal width
# C64 (40-column) uses PETSCII, modern terminals (80-column) use CP437
sub boxchar {
  my ($type) = @_;
  my $width = $config{'terminal_width'} || 80;
  
  # Character mappings: PETSCII (C64) vs CP437 (modern ANSI)
  my %chars = (
    # Single-line box drawing
    'horizontal'   => { petscii => chr(64),  cp437 => chr(196) },  # ─
    'vertical'     => { petscii => chr(93),  cp437 => chr(179) },  # │
    'topleft'      => { petscii => chr(85),  cp437 => chr(218) },  # ┌
    'topright'     => { petscii => chr(73),  cp437 => chr(191) },  # ┐
    'bottomleft'   => { petscii => chr(74),  cp437 => chr(192) },  # └
    'bottomright'  => { petscii => chr(75),  cp437 => chr(217) },  # ┘
    'tdown'        => { petscii => chr(77),  cp437 => chr(194) },  # ┬
    'tup'          => { petscii => chr(78),  cp437 => chr(193) },  # ┴
    'tright'       => { petscii => chr(107), cp437 => chr(195) },  # ├
    'tleft'        => { petscii => chr(115), cp437 => chr(180) },  # ┤
    
    # Double-line box drawing (CP437 only, use single-line for PETSCII)
    'dhorizontal'  => { petscii => chr(64),  cp437 => chr(205) },  # ═
    'dvertical'    => { petscii => chr(93),  cp437 => chr(186) },  # ║
    'dtopleft'     => { petscii => chr(85),  cp437 => chr(201) },  # ╔
    'dtopright'    => { petscii => chr(73),  cp437 => chr(187) },  # ╗
    'dbottomleft'  => { petscii => chr(74),  cp437 => chr(200) },  # ╚
    'dbottomright' => { petscii => chr(75),  cp437 => chr(188) },  # ╝
  );
  
  # Return appropriate character
  if (exists $chars{$type}) {
    return ($width == 40) ? $chars{$type}{petscii} : $chars{$type}{cp437};
  }
  
  # Fallback to space if unknown type
  return ' ';
}
# ============================================================================

sub applytheme {
  $thmfile=$config{'home'}.$config{'themes'}."/".$_[0];
  if (-e $thmfile) {
    lockfile("$thmfile");
    open (my $atheme_fh, '<', $thmfile);
     @themein=<$atheme_fh>;
    close ($atheme_fh);
    unlockfile("$thmfile");
  } else {
    errorout ("Could not load theme file [".$thmfile."] , exiting..".$RST);
  }
  $ctime = get_current_time();
  $cdate = get_current_date();
  $menu=lc($menuname);
  foreach (@themein) {
    ($key,$value) = split(/\=/);
    chomp $value;
    unless ($value eq "") {
      $$key = $value;
      # Apply all code substitutions using centralized functions
      $$key = _substitute_theme_codes($$key);
      $$key = _substitute_box_codes($$key);
      $$key = _substitute_color_codes($$key);
      # Theme-specific variable substitutions
      $$key =~s/\@USRNM/$info{'username'}/g;
      $$key =~s/\@SYSNM/$config{'systemname'}/g;
      $$key =~s/\@MENU/$menu/g;
      $$key =~s/\@NODE/$info{'node'}/g;
      $$key =~s/\@CONNECT/$info{'connect'}/g;
      $$key =~s/\@USER/$info{'handle'}/g;
      $$key =~s/\@EMAIL/$info{'email'}/g;
      $$key =~s/\@TIME/$ctime/g;
      $$key =~s/\@DATE/$cdate/g;
      $$key =~s/\@TOTALCALLS/$config{'totcalls'}/g;
      $$key =~s/\@DEFAULT/$info{'defchan'}/g;
      $$key =~s/\@PROTO/$info{'proto'}/g;
      $$key =~s/\\n/\n/g; $$key =~s/\\t/\t/g; $$key =~ s/(\$\w+)/$1/eeg;
      $theme{$key}=$$key;
      $$key="";
    }
  }
}

sub lockfile {
  my ($filepath) = @_;
  my $lockfile = "$filepath.lock";
  my $max_retries = 10;
  my $retry_count = 0;
  
  # SECURITY FIX: Use atomic flock() instead of file existence check
  # This prevents TOCTOU (Time-of-Check-Time-of-Use) race conditions
  while ($retry_count < $max_retries) {
    # Try to open the lock file for writing (create if doesn't exist)
    if (open(my $lock_fh, '>', $lockfile)) {
      # Try to acquire exclusive lock
      if (flock($lock_fh, LOCK_EX | LOCK_NB)) {
        # Successfully locked
        print $lock_fh $info{'handle'};
        chmod 0666, $lockfile;
        
        # Store the filehandle globally so unlockfile can access it
        # Note: In production, consider using a lock manager object
        $GLOBAL_LOCK_FH{$filepath} = $lock_fh;
        return 1;
      } else {
        # Lock failed, check if lock file is stale
        my @stat = stat($lockfile);
        if (@stat && (time - $stat[9]) > 60) {
          # Lock file is older than 60 seconds, remove it and retry
          close($lock_fh);
          unlink($lockfile);
          $retry_count++;
          sleep 1;
          next;
        }
        # Wait for lock
        close($lock_fh);
        $retry_count++;
        sleep 1;
        next;
      }
    } else {
      # Could not open lock file, wait and retry
      $retry_count++;
      sleep 1;
      next;
    }
  }
  
  # If we got here, we couldn't acquire the lock after retries
  # For backward compatibility, force unlock with warning
  logger("WARN: $info{'handle'} unable to acquire lock on $filepath after $max_retries attempts");
  if (-e $lockfile && (time - (stat($lockfile))[9]) > 60) {
    logger("ERROR: $info{'handle'} forced unlock on $filepath (stale lock)");
    unlink($lockfile);
  }
  
  # Return 0 to indicate failure, but don't die (maintain compatibility)
  return 0;
}

sub unlockfile {
   my ($filepath) = @_;
   
   # SECURITY FIX: Release flock() properly if it was acquired
   if (exists $GLOBAL_LOCK_FH{$filepath}) {
     my $lock_fh = $GLOBAL_LOCK_FH{$filepath};
     flock($lock_fh, LOCK_UN);
     close($lock_fh);
     delete $GLOBAL_LOCK_FH{$filepath};
   }
   
   # Clean up lock file
   my $lockfile = "$filepath.lock";
   unlink($lockfile) if -e $lockfile;
   return 1;  # Return success
}

# ============================================================================
# ATOMIC FILE WRITE - Write to temp file then rename
# ============================================================================
# Prevents data corruption if the process is killed mid-write.
# The rename() operation is atomic on POSIX filesystems.
sub atomic_write_file {
  my ($filepath, $content, $lock) = @_;
  my $tmpfile = "$filepath.tmp.$$";

  lockfile($filepath) if $lock;

  eval {
    open(my $fh, '>', $tmpfile) or die "Cannot write $tmpfile: $!";
    print $fh $content;
    close($fh) or die "Cannot close $tmpfile: $!";
    rename($tmpfile, $filepath) or die "Cannot rename $tmpfile to $filepath: $!";
  };
  if ($@) {
    unlink($tmpfile) if -e $tmpfile;
    unlockfile($filepath) if $lock;
    return 0;
  }

  unlockfile($filepath) if $lock;
  return 1;
}

# ============================================================================
# UUID GENERATION - Pure Perl UUID v4 (replaces `uuidgen` backtick)
# ============================================================================
sub generate_uuid {
  my @hex = ('0'..'9', 'a'..'f');
  my $uuid = '';
  for my $i (1..32) {
    $uuid .= $hex[int(rand(16))];
    $uuid .= '-' if ($i == 8 || $i == 12 || $i == 16 || $i == 20);
  }
  # Set version 4 (random) and variant bits
  substr($uuid, 14, 1) = '4';
  substr($uuid, 19, 1) = $hex[8 + int(rand(4))];
  return $uuid;
}

sub readconfig {
  $rfile=$config{'home'}.$config{'data'}."/".$_[0];
  lockfile("$rfile");
  open (my $config_fh, '<', $rfile);
  while (<$config_fh>) {
    $line=$_;
    chomp $line;
    unless ($line =~/^#/) {
      if ($line =~/#/i) {
        ($newline,$junk)=split(/#/,$line);
        while ($newline =~/\s$/) {
          chop $newline;
        }
        $line=$newline;
      }
      ($key,$value)=split(/=/,$line);
      $config{$key}=$value;
    }
  }
  close ($config_fh);
  unlockfile("$rfile");
}

sub cbreak {
  # Skip if we don't have a valid TTY
  return if (!defined $mytty || $mytty eq "" || $mytty =~ /not a tty/i);

  my $mode = $_[0];

  if ($HAS_POSIX_TERMIOS) {
    # POSIX::Termios approach: zero child processes, signal-safe
    if (!$INITIAL_TERMIOS) {
      eval {
        $INITIAL_TERMIOS = POSIX::Termios->new();
        $INITIAL_TERMIOS->getattr(fileno(STDIN));
      };
      if ($@) {
        _cbreak_stty($mode);
        return;
      }
    }

    if ($mode eq "on") {
      eval {
        my $t = POSIX::Termios->new();
        $t->getattr(fileno(STDIN));
        my $lflag = $t->getlflag();
        $lflag &= ~(POSIX::ECHO() | POSIX::ICANON());
        $t->setlflag($lflag);
        $t->setcc(POSIX::VMIN(), 1);
        $t->setcc(POSIX::VTIME(), 0);
        $t->setattr(fileno(STDIN), POSIX::TCSANOW());
        $TERMINAL_MODE = 1;
      };
      if ($@) {
        _cbreak_stty($mode);
      }
    }
    if ($mode eq "off") {
      eval {
        $INITIAL_TERMIOS->setattr(fileno(STDIN), POSIX::TCSANOW());
        $TERMINAL_MODE = 0;
      };
      if ($@) {
        _cbreak_stty($mode);
      }
    }
  } else {
    _cbreak_stty($mode);
  }
}

# Legacy stty fallback - only used if POSIX::Termios is unavailable
sub _cbreak_stty {
  my $mode = $_[0];
  if ($mode eq "on") {
    if ($BSD_STYLE) {
      system "stty -echo cbreak <$mytty >$mytty 2>&1";
    } else {
      system "stty -echo raw opost <$mytty >$mytty 2>&1";
    }
    $TERMINAL_MODE = 1;
  }
  if ($mode eq "off") {
    if ($BSD_STYLE) {
      system "stty echo -cbreak <$mytty >$mytty 2>&1";
    } else {
      system "stty echo -raw <$mytty >$mytty 2>&1";
    }
    $TERMINAL_MODE = 0;
  }
}

sub waitkey {
  $idle=time;
  $idlenotified=0;
  $default=$_[0];
  my $timeout=$_[1];  # Optional timeout in seconds (0 or undef = no timeout)
  my $start_time=time;
  $key="";
  cbreak(on);
  for (;;) {
    # Check if timeout exceeded (if timeout was specified)
    if ($timeout && (time - $start_time) >= $timeout) {
      # Timeout exceeded - return undef to signal timeout
      cbreak(off);
      return undef;
    }
    
    wastart: {
    eval {
      local $SIG{ALRM}=sub{$key="";doevents();goto wastart;};
      alarm 1;
      $key = "";
      $key=getc(STDIN);
      doevents();
      alarm 0;
    };
    };

    if ($key ne "") {
      unless ($key eq "\n") {
        writeline ($config{'inputcolor'}.$key);
      } else {
        $key=$default;
        writeline ($config{'inputcolor'}.$key);
      }
      last;
    } else {
      next;
    }
  }
  return $key;
}

# ============================================================================
# COLOR CODE SUBSTITUTION - Central function for @-code to ANSI conversion
# ============================================================================
sub _substitute_color_codes {
  my $text = $_[0];
  my %color_map = (
    '@RST' => $RST, '@BLK' => $BLK, '@RED' => $RED, '@GRN' => $GRN,
    '@YLW' => $YLW, '@BLU' => $BLU, '@MAG' => $MAG, '@WHT' => $WHT,
    '@CYN' => $CYN, '@BBK' => $BBK, '@BRD' => $BRD, '@BGN' => $BGN,
    '@BYL' => $BYL, '@BBL' => $BBL, '@BMG' => $BMG, '@BCN' => $BCN,
    '@BWH' => $BWH,
  );
  $text =~ s/(\@(?:RST|BLK|RED|GRN|YLW|BLU|MAG|WHT|CYN|BBK|BRD|BGN|BYL|BBL|BMG|BCN|BWH))/$color_map{$1} \/\/ ''/eg;
  return $text;
}

sub _substitute_theme_codes {
  my $text = $_[0];
  my %theme_map = (
    '@SYSTEMCLR' => $config{'systemcolor'}, '@USERCLR'   => $config{'usercolor'},
    '@INPUTCLR'  => $config{'inputcolor'},  '@ERRORCLR'  => $config{'errorcolor'},
    '@THEMECLR'  => $config{'themecolor'},  '@PROMPTCLR' => $config{'promptcolor'},
    '@DATACLR'   => $config{'datacolor'},   '@LINECLR'   => $config{'linecolor'},
  );
  $text =~ s/(\@(?:SYSTEM|USER|INPUT|ERROR|THEME|PROMPT|DATA|LINE)CLR)/$theme_map{$1} \/\/ ''/eg;
  return $text;
}

sub _substitute_box_codes {
  my $text = $_[0];
  $text =~ s/\@(D?BOX(?:HORIZ|VERT|TOPLEFT|TOPRIGHT|BOTLEFT|BOTRIGHT|TDOWN|TUP|TLEFT|TRIGHT))\@/_boxcode_lookup($1)/eg;
  return $text;
}

sub _boxcode_lookup {
  my %box_map = (
    'BOXHORIZ' => 'horizontal', 'BOXVERT' => 'vertical',
    'BOXTOPLEFT' => 'topleft', 'BOXTOPRIGHT' => 'topright',
    'BOXBOTLEFT' => 'bottomleft', 'BOXBOTRIGHT' => 'bottomright',
    'BOXTDOWN' => 'tdown', 'BOXTUP' => 'tup',
    'BOXTLEFT' => 'tleft', 'BOXTRIGHT' => 'tright',
    'DBOXHORIZ' => 'dhorizontal', 'DBOXVERT' => 'dvertical',
    'DBOXTOPLEFT' => 'dtopleft', 'DBOXTOPRIGHT' => 'dtopright',
    'DBOXBOTLEFT' => 'dbottomleft', 'DBOXBOTRIGHT' => 'dbottomright',
  );
  return boxchar($box_map{$_[0]} || 'horizontal');
}

sub writeline {
  $wrline=$_[0];
  $wrline = _substitute_color_codes($wrline);
  print $wrline . "\e[K";
  if ($_[1] eq "1") {
    print "\n";
  }
}

sub getline {
  $idle=time;
  $idlenotified=0;
  cbreak("on");
  $input{'type'}=$_[0];
  $input{'length'}=$_[1];
  $input{'text'}=$_[2];
  $result="";
  if ($_[3]) {
    # Width-aware input field sizing for C64 40-column support
    my $term_width = $config{'terminal_width'} || 80;
    
    # Strip ANSI escape codes from prompt to get visible length
    my $visible_text = $input{'text'};
    $visible_text =~ s/\e\[[0-9;]*m//g;  # Remove ANSI color codes
    my $prompt_len = length($visible_text);
    
    my $max_field = $term_width - $prompt_len - 2;  # Leave 2 chars margin
    
    # Cap input field width to available space
    my $field_width = $input{'length'};
    if ($field_width > $max_field && $max_field > 0) {
      $field_width = $max_field;
    }
    
    # Draw input field with white background
    for (1..$field_width) {
      print "\e[0;47;0m ";   ### Add to theme file!
    }
    print "\e[".$field_width."D";
  }
  writeline ($config{'inputcolor'}.$input{'text'});
  for (;;) {
    start: {
    eval {
      local $SIG{ALRM}=sub{$key="";doevents();goto start;};
      alarm 1;
      $key="";
      $key=getc(STDIN);
      doevents();
      alarm 0;
    };
    };
    if ($key =~/\n/ || $key =~/\r/) {
      chomp $result;
      $retmsg=$result;
      $result="";
      print $RST;
      unless ($retmsg ne "") {
        print $RST;
      }
      cbreak(off);
      if ($input{'type'} =~/chat/) {
        my $width = $config{'terminal_width'} || 80;
        print "\e[${width}D\e[2K";
      } else {
        writeline("\n");
      }
      return ($retmsg);
    }
    # Enhanced backspace/delete logic
    if ($key =~/\c?/ || $key =~/\ch/) {
      if (length($result) > 0) {
        # Always delete just one character for DOB
        $result = substr($result, 0, -1);
        print "\e[1D \e[1D";
      }
      next;
    }
    if (ord($key) >= 32 && ord($key) <= 126) {
      if ($input{'type'} eq "dob") {
        $input{'length'}=10;
        # Only allow digits and slashes
        unless ($key =~ /[0-9\/]/) {
          $key = "";
          next;
        }
        # If user types a slash, only allow at positions 2 or 5
        if ($key eq "/") {
          unless (length($result) == 2 || length($result) == 5) {
            next;
          }
        }
        # If user types a digit, auto-insert slash after MM and DD if not present
        if ($key =~ /[0-9]/) {
          if ((length($result) == 2 || length($result) == 5) && substr($result, -1) ne "/") {
            $result .= "/";
            print "/";
          }
        }
      }
      if ($input{'type'} eq "phone") {
        $input{'length'}=14;
        unless ($key =~/[0-9]/) {
          $key="";
          next;
        }
        if (length($result) lt 1) {
          $key="(".$key;
        }
        if (length($result) eq 3) {
          $key=$key.")";
        }
        if (length($result) eq 4) {
          $key=")".$key;
        }
        if (length($result) eq 5) {
          $key=" ".$key;
        }
        if (length($result) eq 8) {
          $key=$key."-";
        }
        if (length($result) eq 9) {
          $key="-".$key;
        }
      }
      unless (length($result) == $input{'length'}) {
        unless ($input{'type'} =~/password/) {
          print $key;
        } elsif ($key ne "") {
          print $config{'passchr'};
        }
        $result = $result . $key;
        if ($input{'type'} =~/chat/) {
          if ($result eq "$config{'help'}") {
            $retmsg=$result;
            $result="";
            writeline("\n");
            return ($retmsg);
          }
        }
      }
    }
  }
}

sub colorline {
  $_[0] = _substitute_theme_codes($_[0]);
  $_[0] = _substitute_box_codes($_[0]);
  $_[0] = _substitute_color_codes($_[0]);
  return $_[0];
}

sub readfile {
  my $requested_file = $_[0];
  my $pause = $_[1];
  my $absolute = $_[2];
  my $filename;
  
  # Auto-select width-specific file variant if terminal width is 40
  unless ($absolute) {
    my $width = $config{'terminal_width'} || 80;
    if ($width == 40) {
      # Try width-specific file first (e.g., welcome.asc -> welcome-40.asc)
      my $width_specific = $requested_file;
      $width_specific =~ s/(\.\w+)$/-40$1/;  # Insert -40 before extension
      my $width_file = $config{'home'} . $config{'text'} . "/" . $width_specific;
      
      if (-e $width_file && -r $width_file) {
        $requested_file = $width_specific;  # Use the 40-column version
      }
    }
  }
  
  if ($absolute) {
    $filename = $requested_file;
  } else {
    $filename = $config{'home'} . $config{'text'} . "/" . $requested_file;
  }
  
  # SECURITY: Basic path traversal protection
  # Check for directory traversal patterns
  if ($requested_file =~ /\.\./) {
    errorout("Security: Invalid file path requested: $requested_file");
    return;
  }
  
  # For relative paths, reject absolute path injection attempts
  if (!$absolute && $requested_file =~ /^\//) {
    errorout("Security: Invalid file path requested: $requested_file");
    return;
  }
  
  # Verify file exists and is readable before further processing
  unless (-e $filename && -r $filename) {
    # File doesn't exist - not a security error, just missing file
    return;
  }
  
  # SECURITY: Canonicalize and verify path is within allowed directories
  # Note: We check against multiple allowed bases since data dir may be a symlink
  use Cwd qw(realpath abs_path);
  my $real_path = realpath($filename);
  
  # Define allowed base directories (resolve symlinks in data paths too)
  my @allowed_bases = (
    realpath($config{'home'}),                    # /opt/photonbbs
    realpath($config{'home'} . $config{'data'}),  # data directory (may be symlink)
    realpath($config{'home'} . $config{'text'}),  # text directory
  );
  
  # Verify path is within at least one allowed base directory
  my $path_valid = 0;
  for my $base (@allowed_bases) {
    if (defined $real_path && defined $base && $real_path =~ /^\Q$base\E/) {
      $path_valid = 1;
      last;
    }
  }
  
  unless ($path_valid) {
    errorout("Security: Path outside allowed directory: $requested_file");
    return;
  }
  
  usersonline();
  lockfile("$filename") || errorout ("Unable to open $filename");
  open (my $file_fh, '<', $filename) || errorout ("Unable to open $filename");
  my $linecount=1;
  my $menu=lc($menuname);
  my $ctime = get_current_time();
  my $cdate = get_current_date();
  while (<$file_fh>) {
    s/\@SYSTEMCLR/$config{'systemcolor'}/g;
    s/\@USERCLR/$config{'usercolor'}/g;
    s/\@INPUTCLR/$config{'inputcolor'}/g;
    s/\@ERRORCLR/$config{'errorcolor'}/g;
    s/\@THEMECLR/$config{'themecolor'}/g;
    s/\@PROMPTCLR/$config{'promptcolor'}/g;
    s/\@DATACLR/$config{'datacolor'}/g;
    s/\@LINECLR/$config{'linecolor'}/g;
    
    # Box-drawing character macros (PETSCII-aware)
    s/\@BOXHORIZ\@/boxchar('horizontal')/eg;
    s/\@BOXVERT\@/boxchar('vertical')/eg;
    s/\@BOXTOPLEFT\@/boxchar('topleft')/eg;
    s/\@BOXTOPRIGHT\@/boxchar('topright')/eg;
    s/\@BOXBOTLEFT\@/boxchar('bottomleft')/eg;
    s/\@BOXBOTRIGHT\@/boxchar('bottomright')/eg;
    s/\@BOXTDOWN\@/boxchar('tdown')/eg;
    s/\@BOXTUP\@/boxchar('tup')/eg;
    s/\@BOXTLEFT\@/boxchar('tleft')/eg;
    s/\@BOXTRIGHT\@/boxchar('tright')/eg;
    
    # Double-line box-drawing macros
    s/\@DBOXHORIZ\@/boxchar('dhorizontal')/eg;
    s/\@DBOXVERT\@/boxchar('dvertical')/eg;
    s/\@DBOXTOPLEFT\@/boxchar('dtopleft')/eg;
    s/\@DBOXTOPRIGHT\@/boxchar('dtopright')/eg;
    s/\@DBOXBOTLEFT\@/boxchar('dbottomleft')/eg;
    s/\@DBOXBOTRIGHT\@/boxchar('dbottomright')/eg;
    
    s/\@SYSNM/$config{'systemname'}/g;
    s/\@NODE/$info{'node'}/g;
    s/\@CONNECT/$info{'connect'}/g;
    s/\@HOST/$sysinfo{'host'}/g;
    s/\@IP/$sysinfo{'ip'}/g;
    s/\@USERS/$sysinfo{'users'}/g;
    s/\@TIME/$ctime/g;	s/\@DATE/$cdate/g;
    s/\@DEFAULT/$info{'defchan'}/g;
    s/\@PROTO/$info{'proto'}/g;
    s/\@USER/$info{'handle'}/g;
    s/\@RNAME/$info{'rname'}/g;
    s/\@DOB/$info{'dob'}/g;
    s/\@PHONE/$info{'phonenumber'}/g;
    s/\@LOCAL/$info{'location'}/g;
    s/\@CREDITS/$info{'credits'}/g;
    s/\@TLEFT/$info{'tlimit'}/g;
    s/\@ID/$info{'id'}/g;
    s/\@EMAIL/$info{'email'}/g;
    s/\@DND/$info{'dnd'}/g;
    s/\@BANNED/$info{'banned'}/g;
    s/\@CLR/$CLR/g;
    s/\@RST/$RST/g;
    s/\@BLK/$BLK/g;
    s/\@RED/$RED/g;
    s/\@GRN/$GRN/g;
    s/\@YLW/$YLW/g;
    s/\@BLU/$BLU/g;
    s/\@MAG/$MAG/g;
    s/\@WHT/$WHT/g;
    s/\@CYN/$CYN/g;
    s/\@BBK/$BBK/g;
    s/\@BRD/$BRD/g;
    s/\@BGN/$BGN/g;
    s/\@BYL/$BYL/g;
    s/\@BBL/$BBL/g;
    s/\@BMG/$BMG/g;
    s/\@BCN/$BCN/g;
    s/\@BWH/$BWH/g;
    s/~AT/\@/g;

    if ($info{'ansi'} eq 1) {
      $ansi="Y";
    } else {
      $ansi="N";
    }
    s/\@ANSI/$ansi/g;
    s/\\n/\n/g;
    s/\\t/\t/g;

    unless ($inteleconf eq 1) {
      print $_;
    } else {
      chomp $_;
      unless ($_ eq "") {
        my $width = $config{'terminal_width'} || 80;
        print "\e[${width}D\e[2K".$_."\n";
        $gotapage="1";
      }
    }

    if ($inteleconf eq "1" && $gotapage eq "1") {
      writeline($RST.$config{'inputcolor'}.$config{'promptchr'}." ".$result);
    }

    unless ($pause eq "1") {
      ++$linecount;
      if ($linecount == $config{'rows'}) {
        unless ($wait eq "C") {
          $wait=pause();
        }
        if ($wait eq "Q") {
          last;
        }
        if ($wait eq "N") {
          $linecount=1;
        }
      }
    }
  }
  close ($file_fh);
  unlockfile("$filename") || errorout ("Unable to close $filename");
}

sub pause {
  writeline ($theme{'pause'}." ".$RST);
  $noevents=1;
  $key=waitkey();
  $noevents="";
  $key=uc($key);
  my $width = $config{'terminal_width'} || 80;
  print "\e[2K\e[${width}D";
  unless ($key =~/C/ || $key =~/N/ || $key =~/Q/) {
    $key="N";
  }
  return $key;
}

sub hi {
  $ppid=getppid;

  # --- Use server-assigned node number from ARGV[2] ---
  my $nodeid = $ARGV[2];
  if (!$nodeid || $nodeid !~ /^\d+$/) {
    writeline("No node number provided by server, cannot continue.");
    logger("ERROR: No node number provided by server, disconnecting.");
    exit 1;
  }
  $info{'node'} = $nodeid;

  if ( $ARGV[1] =~ /sftp/i  || $ARGV[1] =~ /scp/i || $ARGV[1] =~ /exec/i ) {
    writeline("Attempt reported.",1);
    logger("ERROR: Connection attempt via SCP or SFTP from (@ARGV).");
    exit 0;
  }

  # Robust protocol/IP detection for all telnetd variants
  if ($ARGV[0] && $ARGV[1] && $ARGV[0] !~ /^-/) {
      # Standard: proto, connect
      $info{'proto'}   = $ARGV[0];
      $info{'connect'} = $ARGV[1];
  } elsif ($ARGV[1] && $ARGV[1] !~ /^-/) {
      # in.telnetd: proto, connect
      $info{'proto'}   = $ARGV[0] // "TELNET";
      $info{'connect'} = $ARGV[1];
  } elsif ($ARGV[2] && $ARGV[2] !~ /^-/) {
      # BSD/BusyBox: -h, connect, -p
      $info{'proto'}   = "TELNET";
      $info{'connect'} = $ARGV[2];
  } elsif ($ENV{'SSH_CLIENT'}) {
      @sshprts = split(/\ /, $ENV{'SSH_CLIENT'});
      $info{'connect'} = shift(@sshprts);
      $info{'proto'} = "SSH";
  } else {
      $info{'connect'} = $mtty;
      $info{'proto'} = "LOCAL";
  }

  $cli=join(' ',@ARGV);
  chomp ($cli);

  unless ($info{'connect'} =~/\w\.\w/i || $info{'connect'} =~/\w{4,32}/i) {
     writeline("Dont know who you are, can not continue.");
     logger ("ERROR: Can't find IP address for connection ($cli), disconnecting.");
     bye()
  }

  if ($config{'nodupes'} eq 1) {
    unless (-e "$config{'home'}$config{'data'}/iplist") {
      open (my $out_fh, '>', "$config{'home'}$config{'data'}/iplist");
       print $out_fh "UNKNOWNUSER\n";
      close($out_fh);
    }
    # Always lock before reading or writing
    lockfile("$config{'home'}$config{'data'}/iplist");
    open (my $in_fh, '<', "$config{'home'}$config{'data'}/iplist");
    my @lines = <$in_fh>;
    close($in_fh);

    # Check for duplicates
    foreach my $line (@lines) {
      chomp $line;
      if ($line =~/$info{'connect'}/i) {
        writeline ($config{'systemcolor'}."\nIP ".$config{'usercolor'}.$info{'connect'}.$config{'systemcolor'}." is already logged on ..",1);
        ($kpid,$kip)=split(/:/,$line);
        logger("WARN: Duplicate IP ".$info{'connect'}." connected. Killing PID ".$kpid);
        kill 15,$kpid;
        unlockfile("$config{'home'}$config{'data'}/iplist");
        bye();
      }
    }

    # Add this session
    open (my $out_fh, '>>', "$config{'home'}$config{'data'}/iplist");
    print $out_fh getppid.":".$info{'connect'}."\n";
    close($out_fh);
    unlockfile("$config{'home'}$config{'data'}/iplist");
  }

  cbreak(on);
  eval {
    if ( $config{'clearlogin'} eq "1" ) {
       print "\e[2J\e[0H";
    }
    if ($config{'headers'} eq 1) {
      @OPENING=split(//,"\nConnected to ".$config{'systemname'})
    }
    push (@OPENING,"\nAuto-sensing .");
    for (0..scalar(@OPENING)) {
     select(undef, undef, undef, 0.010);
     print shift(@OPENING);
    }

    local $SIG{ALRM} = sub {$response="\c[6c";next;};
    print "\e[c";
    alarm 1;
    while ($tchr=getc(STDIN)){
      $termmode=$termmode.getc(STDIN);
      if ($termmode =~/\cx/i) {
        $termmode="1c";
        last;
      } elsif ($termmode =~/[0-9]c/i) {
       last;
      }
    }
    alarm 0;
  };
  print ".";
  if ($termmode =~/[0-1]c/gi) {
    $info{'ext'}="asc";
    $info{'ansi'}="0";
  } else {
    $info{'ext'}="ans";
    $info{'ansi'}="1";
  }
  eval {
    alarm 1;
    local $SIG{ALRM} = sub {$tchr="c";next;};
    while ($tchr=$tchr.getc(STDIN)) {
      if ($tchr =~/c$/i) {
        break;
      }
    }
    alarm 0;
  };
  print ".";
  eval {
    alarm 1;
      local $SIG{ALRM} = sub {$tchr="";next;};
      while ($tchr=$tchr.getc(STDIN)) {
        last;
      }
    alarm 0;
  };
  print ".";
  # Get TTY number using Perl instead of forking to tty|sed
  if (defined $mytty && $mytty ne "") {
    my $ttynum = $mytty;
    $ttynum =~ s/[\/a-z]//gi;
    $info{'tty'} = $ttynum;
  } else {
    $info{'tty'} = "";
  }

  # Now that the node is reserved, write initial session info
  iamat("CONNECT", "Logging on");

  if (-e "$config{'home'}$config{'messages'}/$info{'node'}.page") {
    unlink("$config{'home'}$config{'messages'}/$info{'node'}.page");
  }

  if (-e "$config{'home'}$config{'data'}/banned_ip") {
    lockfile("$config{'home'}$config{'data'}/banned_ip");
    open (my $banned_fh, '<', "$config{'home'}$config{'data'}/banned_ip");
      while(<$banned_fh>) {
        chomp $_;
          if ($info{'connect'} =~/$_/i) {
            writeline ($config{'systemcolor'}."\nHost ".$config{'usercolor'}.$info{'connect'}.$config{'systemcolor'}." has been ".$config{'errorcolor'}."banned".$config{'systemcolor'}.", terminating connection ..",1);
              logger("WARN: Banned User connected from".$config{'promptcolor'}.": ".$info{'connect'});
              close($banned_fh);
            unlockfile("$config{'home'}$config{'data'}/banned_ip");
            bye();
          }
      }
    close($banned_fh);
    unlockfile("$config{'home'}$config{'data'}/banned_ip");
  }

  if (-e "$config{'home'}/$config{'data'}/totalcalls") {
    lockfile("$config{'home'}/$config{'data'}/totalcalls");
    open (my $tcalls_fh, '<', "$config{'home'}/$config{'data'}/totalcalls");
    $config{'totcalls'}=<$tcalls_fh>;
    chomp ($config{'totcalls'});
    close ($tcalls_fh);
    unlockfile("$config{'home'}/$config{'data'}/totalcalls");
  }
  ++$config{'totcalls'};
  atomic_write_file("$config{'home'}/$config{'data'}/totalcalls", $config{'totcalls'}, 1);
}

sub logger {
  my $msg = $_[0];

  # Syslog: direct Perl call instead of forking to system("logger ...")
  eval {
    openlog($sysinfo{'servername'} || 'photonbbs', 'ndelay,pid', $config{'facility'} || 'local0');
    syslog('info', '%s', $msg);
    closelog();
  };

  # Slack Webhook Integration
  if ( $config{'slackintegration'} eq "1" ) {
    if ( $config{'slackerrors'} eq "0" && $msg =~ /^ERR/ ) {
      return;
    }
    if ( $config{'slackwarnings'} eq "0" && $msg =~ /^WARN/ ) {
      return;
    }
    _webhook_post(
      'https://hooks.slack.com/services/'.$config{'slackapipath'},
      '{"channel": "'.$config{'slackchannel'}.'", "username": "'.$config{'slackuser'}.'", "text": "'.escape_json_string($msg).'", "icon_emoji": "'.$config{'slackemoji'}.'"}'
    );
  }

  # Discord Webhook Integration
  if ( $config{'discordintegration'} eq "1" && $config{'discordwebhook'} ne "" ) {
    if ( $config{'discorderrors'} eq "0" && $msg =~ /^ERR/ ) {
      return;
    }
    if ( $config{'discordwarnings'} eq "0" && $msg =~ /^WARN/ ) {
      return;
    }
    my $discord_payload = '{'.
      '"username": "'.$config{'discorduser'}.'",'.
      ($config{'discordavatar'} ne "" ? '"avatar_url": "'.$config{'discordavatar'}.'",' : '').
      '"content": "'.escape_discord($msg).'"'.
      '}';
    _webhook_post($config{'discordwebhook'}, $discord_payload);
  }
}

# Send webhook POST request using HTTP::Tiny (no child process)
sub _webhook_post {
  my ($url, $payload) = @_;
  if ($HAS_HTTP_TINY) {
    eval {
      my $http = HTTP::Tiny->new(timeout => 5);
      $http->post($url, {
        headers => { 'Content-Type' => 'application/json' },
        content => $payload,
      });
    };
  } else {
    my $escaped_payload = $payload;
    $escaped_payload =~ s/'/'\\''/g;
    system("curl -s -H 'Content-Type: application/json' -X POST -d '$escaped_payload' '$url' >/dev/null 2>&1");
  }
}

sub escape_json_string {
  my $s = shift;
  $s =~ s/\\/\\\\/g;
  $s =~ s/"/\\"/g;
  $s =~ s/\n/\\n/g;
  $s =~ s/\r/\\r/g;
  $s =~ s/\t/\\t/g;
  return $s;
}

# Helper: Escape Discord special chars (basic)
sub escape_discord {
  my $msg = shift;
  $msg =~ s/"/\\"/g;
  $msg =~ s/\n/\\n/g;
  $msg =~ s/\r//g;
  return $msg;
}

sub bulletins {
  $bullidx=$config{'home'}.$config{'data'}."/bullidx.dat";
  if (-e $bullidx) {
    lockfile("$bullidx");
    open (my $bull_fh, '<', $bullidx);
    @bulls=<$bull_fh>;
    close ($bull_fh);
  }
  unlockfile("$bullidx");
  if (scalar(@bulls) > "0") {
    writeline($config{'themecolor'}."Found ".$config{'datacolor'}.scalar(@bulls).$config{'themecolor'}." bulletin(s)!",1);
  } else {
    writeline($config{'systemcolor'}."No new bulletins are available today.",1);
    return;
  }
  if ($config{'bulletins'} eq 0) {
    return;
  }
  bullmenu();
}

sub bullmenu {
  bullmenu: {
    $inteleconf=0;
    writeline("\n");
    iamat($info{'handle'},"Bulletins Menu");
    $count=1;

    ###
    ### bulletins.xxx should contain the index
    ### if it doesn't exist, generate a menu
    ###

    $readit=0;
    if (-e "$config{'home'}$config{'text'}/bulletins.$info{'ext'}") {
      readfile("welcome.$info{'ext'}");
      $readit=1;
    }
    if (-e "$config{'home'}$config{'text'}/bulletins.txt" && $readit ne "1") {
      readfile("welcome.txt");
      $readit=1;
    }

    if ($readit ne "1") {
      writeline("$theme{'bulltop'}\n",1);
    }

    $bullidx=$config{'home'}.$config{'data'}."/bullidx.dat";
    lockfile("$bullidx");
    open (my $bull_fh, '<', $bullidx);
    @bulls=<$bull_fh>;
    close ($bull_fh);
    unlockfile("$bullidx");

    unless($readit eq 1) {
      for (0..scalar(@bulls)) {
        $bulln=$_+1;
        chomp ($bulls[$_]);
        ($bullid,$bulltext)=split(/\|/,$bulls[$_]);
        if ($bulltext ne "") {
          writeline($config{'datacolor'}.$bulln.$config{'usercolor'}." ...".$config{'themecolor'}." ".$bulltext,1);
        }
      }
    }

    writeline($config{'themecolor'}."\nEnter Option, or \"".$config{'datacolor'}."Q".$config{'themecolor'}."\" to quit".$config{'promptcolor'}.": ");
    $result=getline(text,,1);
    unless ($result =~/^[Qq]$/ || $result eq "") {
      iamat($info{'handle'},"Reading a bulletin");
      $result=$result-1;
      if ($result lt 0) {
        $result=0;
      }
      chomp ($bulls[$_]);
      ($bullid,$bulltext)=split(/\|/,$bulls[$result]);
      if (-e "$config{'home'}/$config{'text'}/$bullid") {
        writeline("\n");
        readfile($bullid);
        goto bullmenu;
      }
    }
    writeline("\n");
  }
  $inteleconf=1;
}

# Add a function to enumerate active sessions/nodes for external tools
sub list_sessions {
  my @sessions;
  my $nodes_dir = $config{'home'}.$config{'nodes'};
  opendir(my $dh, $nodes_dir) or return ();
  while (my $node = readdir($dh)) {
    next if $node =~ /^\./;
    my $file = "$nodes_dir/$node";
    next unless -f $file;
    open(my $fh, '<', $file) or next;
    my $line = <$fh>;
    close($fh);
    chomp $line;
    # $line format: ip|node|pid|time|user|proto|location
    my ($ip, $nodeid, $pid, $time, $user, $proto, $location) = split(/\|/, $line);
    push @sessions, {
      ip       => $ip,
      node     => $nodeid,
      pid      => $pid,
      time     => $time,
      user     => $user,
      proto    => $proto,
      location => $location,
      file     => $file,
    };
  }
  closedir($dh);
  return @sessions;
}

# ============================================================================
# END BLOCK - Restore terminal state on ANY exit
# ============================================================================
END {
  if ($TERMINAL_MODE && $TERMINAL_MODE != 0) {
    if ($HAS_POSIX_TERMIOS && $INITIAL_TERMIOS) {
      eval { $INITIAL_TERMIOS->setattr(fileno(STDIN), POSIX::TCSANOW()); };
    } else {
      eval {
        local $SIG{ALRM} = sub { die "stty timeout\n" };
        alarm(1);
        system "stty sane 2>/dev/null";
        alarm(0);
      };
      alarm(0);
    }
  }
}

return 1;
