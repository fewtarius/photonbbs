use strict;
use warnings;
use Storable qw(store retrieve lock_store lock_retrieve);
use List::Util qw(shuffle);
use Fcntl qw(:DEFAULT :flock);
use JSON::PP;
use feature qw(state);

our %config;
our @combat_actions = @pm_monsters::combat_actions;
our $COMBAT_DEBUG = exists $ENV{PHOTON_COMBAT_DEBUG} ? $ENV{PHOTON_COMBAT_DEBUG} : 0;
our $player;

# New combat mode constants
use constant {
    COMBAT_MODE_NORMAL => 0,     # Standard 1v1 combat
    COMBAT_MODE_PARTY => 1,      # Party vs party or party vs monster
    COMBAT_MODE_FFA => 2,        # Free-for-all, everyone for themselves
    COMBAT_MODE_MERCENARY => 3,  # Mercenary/bounty mode
};

# Alliance types
use constant {
    ALLIANCE_PERMANENT => 0,    # Standard alliance, cannot be broken (party members)
    ALLIANCE_TEMPORARY => 1,    # Temporary alliance, can be broken
    ALLIANCE_MERCENARY => 2,    # Mercenary alliance, based on payment
};

sub combat_debug {
    my $msg = shift;
    return unless $COMBAT_DEBUG;
    my $ts = scalar localtime();
    open my $dbg, ">>", "$config{home}/$config{data}/combat_debug.log";
    print $dbg "[$ts] $msg\n";
    close $dbg;
    writeline("[COMBAT DEBUG] $msg", 1);
}

our %MONSTER_DAMAGE_DICE = (
    goblin              => [1, 6, 0],
    orc                 => [1, 8, 1],
    kobold              => [1, 4, 0],
    hobgoblin           => [1, 8, 1],
    gnoll               => [2, 4, 0],
    bugbear             => [2, 4, 1],
    ogre                => [2, 8, 4],
    troll               => [2, 6, 6],
    hill_giant          => [2,10, 7],
    ogre_mage           => [2, 8, 2],
    skeleton            => [1, 6, 0],
    zombie              => [1, 8, 0],
    ghoul               => [1, 6, 0],
    wight               => [1, 8, 1],
    wraith              => [1, 8, 2],
    mummy               => [1,12, 2],
    vampire             => [2, 6, 2],
    lich                => [2, 8, 3],
    shadow              => [1, 4, 1],
    ghost               => [1,10, 3],
    giant_rat           => [1, 3, 0],
    giant_bat           => [1, 4, 0],
    giant_spider        => [1, 6, 1],
    giant_centipede     => [1, 2, 0],
    giant_snake         => [1, 6, 1],
    wolf                => [1, 6, 1],
    bear                => [2, 4, 2],
    giant_lizard        => [1, 8, 1],
    rust_monster        => [1, 6, 1],
    gelatinous_cube     => [2, 4, 2],
    mimic               => [2, 8, 2],
    fire_elemental      => [2, 8, 4],
    earth_elemental     => [2,10, 4],
    air_elemental       => [2, 8, 4],
    water_elemental     => [2,10, 4],
    balor               => [3,12, 8],
    pit_fiend           => [3,12,10],
    marilith            => [3,10, 8],
    white_dragon        => [3,10, 6],
    black_dragon        => [3,12, 8],
    green_dragon        => [3,12, 8],
    blue_dragon         => [3,12, 8],
    red_dragon          => [3,12,10],
    gold_dragon         => [4,12,12],
    mind_flayer         => [2, 8, 4],
    beholder            => [2,10, 6],
    vampire_lord        => [3,10, 8],
    lich_king           => [3,10, 8],
    dragon_king         => [4,12,14],
    demon_lord          => [4,12,14],
    cleric_vampire      => [2, 8, 4],
    stone_golem         => [2,10, 6],
    kebular_demodand    => [2,10, 6],
    nyca_demon          => [2,10, 6],
    major_titan         => [3,10, 8],
    baku                => [2,10, 6],
    ultro_demon         => [2,10, 6],
    demelich            => [2,10, 8],
    demon_prince        => [4,12,12],
    elemental_prince    => [3,10, 8],
    slaad_lord          => [3,10, 8],
    tarrasque           => [5,12,20],
    solar               => [3,10, 8],
    iron_golem          => [3,10, 8],
    planetar            => [3,10, 8],
    death_slaad         => [3,10, 8],
    astral_dragon       => [3,12,10],
    cloud_dragon        => [3,12,10],
    etheral_dragon      => [3,12,10],
    elder_titan         => [3,10, 8],
    charona_demon       => [3,10, 8],
    arch_devil          => [3,10, 8],
    mountain_elf        => [1, 8, 1],
    mountain_dwarf      => [2, 8, 2],
    mountain_orc        => [2, 8, 2],
    star_lord           => [2,10, 6],
    leech               => [2, 6, 2],
    horror_eye          => [1, 8, 1],
    brain_mole          => [1, 6, 1],
    morpher             => [2, 6, 2],
    water_wierd         => [2, 6, 2],
    berserker           => [2, 6, 2],
    death_dragon        => [3,10, 8],
    mind_host           => [1, 8, 1],
    vengencar           => [1, 8, 1],
    stone_pirate        => [1, 8, 1],
    acid_beast          => [1, 6, 1],
    centaur             => [2, 6, 2],
    wood_elf            => [1, 8, 1],
    death_orb           => [1, 8, 1],
    darknell            => [2, 8, 2],
    acid_dragon         => [2,10, 6],
    kirin               => [2, 8, 2],
    stone_giant         => [2,10, 6],
    mold_crew           => [1, 6, 1],
    caterwaul           => [2, 6, 2],
    tree_orc            => [1, 8, 1],
    slime_devil         => [1, 6, 1],
    slime_demon         => [1, 6, 1],
    incubus             => [1, 6, 1],
    succubus            => [1, 6, 1],
    lurcher             => [2,10, 6],
    gelatinous_cube     => [2, 4, 2],
);

# Helper functions for min/max operations
sub max {
    my ($a, $b) = @_;
    return $a > $b ? $a : $b;
}

sub min {
    my ($a, $b) = @_;
    return $a < $b ? $a : $b;
}

# ============================================================================
# EQUIPMENT & WEAPON FUNCTIONS
# ============================================================================

sub get_equipped_bonus {
    my ($player, $slot) = @_;
    return 0 unless $player->{equipped} && $player->{equipped}{$slot};
    my $inv = $player->{equipped}{$slot};
    my $treas = read_treasure_record($inv->{idx});
    my $bonus = $treas->{plus} // 0;

   
    if ($slot eq 'weapon' && $player->{proficiency}) {
        my $prof = $player->{proficiency};
        my $wname = lc($treas->{name} // '');
        if (
            ($prof eq 'Sword'   && $wname =~ /sword|blade|scimitar|sabre|rapier|cutlass/) ||
            ($prof eq 'Axe'     && $wname =~ /axe|hatchet/) ||
            ($prof eq 'Bow'     && $wname =~ /bow|crossbow|longbow|shortbow/) ||
            ($prof eq 'Staff'   && $wname =~ /staff|polearm|halberd|glaive|spear/) ||
            ($prof eq 'Dagger'  && $wname =~ /dagger|knife|stiletto/) ||
            ($prof eq 'Mace'    && $wname =~ /mace|club|flail|hammer|maul|morningstar/) ||
            ($prof eq 'Sling'   && $wname =~ /sling|stone|rock/) ||
            ($prof eq 'Unarmed' && $wname =~ /fist|hand|unarmed|punch|kick/)
        ) {
            $bonus += 2;
        }
    }
    return $bonus;
}

sub get_mounted_combat_bonus {
    my ($player_or_state) = @_;
    
    # Handle both player objects and combat state objects
    my $mounted_info;
    if ($player_or_state->{mounted}) {
        $mounted_info = $player_or_state->{mounted};
    } elsif ($player_or_state->{mount}) {
        # Legacy mount system
        $mounted_info = $player_or_state->{mount};
    } else {
        return 0;
    }
    
    return 0 unless $mounted_info;
    
    my $caps = $mounted_info->{capabilities};
    my $base_bonus = $caps->{combat_bonus} || 0;
    my $specials = $caps->{special} || [];
    
    # Additional bonuses for special abilities
    my $special_bonus = 0;
    $special_bonus += 2 if grep { $_ eq 'fire_breath' } @$specials;
    $special_bonus += 1 if grep { $_ eq 'archer_bonus' } @$specials;
    
    return $base_bonus + $special_bonus;
}

sub get_weapon_damage_dice {
    my ($player) = @_;
    return (1, 4) unless $player->{equipped} && $player->{equipped}{weapon};
    my $inv = $player->{equipped}{weapon};
    my $treas = read_treasure_record($inv->{idx});
    my $wname = lc($treas->{name} // '');

    # Enhanced weapon damage mapping
    return (1, 8) if $wname =~ /longsword|broadsword|bastard|greatsword|flamberge/;
    return (1, 6) if $wname =~ /shortsword|scimitar|cutlass|rapier/;
    return (1, 6) if $wname =~ /mace|club|flail|morningstar|warhammer/;
    return (1, 4) if $wname =~ /dagger|knife|stiletto/;
    return (1,10) if $wname =~ /halberd|glaive|polearm/;
    return (1, 8) if $wname =~ /battleaxe|greataxe/;
    return (1, 6) if $wname =~ /handaxe|hatchet/;
    return (1, 8) if $wname =~ /spear|trident/;
    return (1, 8) if $wname =~ /bow|crossbow|longbow|shortbow/;
    return (1, 4) if $wname =~ /sling|stone|rock/;
    return (1, 3) if $wname =~ /fist|hand|unarmed|punch|kick/;
    
    # Special weapons
    return (2, 6) if $wname =~ /vorpal/;
    return (1, 8) if $wname =~ /holy avenger|flame tongue/;
    
    # Default
    return (1, 4);
}

sub get_monster_damage_dice {
    my ($monster) = @_;
    my $name = lc($monster->{name} // '');
    $name =~ s/\s+/_/g;
    if (exists $MONSTER_DAMAGE_DICE{$name}) {
        return @{$MONSTER_DAMAGE_DICE{$name}};
    }
    # Fallback: scale by level
    my $level = $monster->{level} // 1;
    return (1 + int($level/5), 6, int($level/2));
}

sub get_proficiency_bonus {
    my ($player, $inv) = @_;
    my $treas = read_treasure_record($inv->{idx});
    my $prof = $player->{proficiency} // '';
    my $wname = lc($treas->{name} // '');
   
    if ($prof eq 'Sword' && $wname =~ /sword|blade/) { return 2; }
    if ($prof eq 'Axe'   && $wname =~ /axe|hatchet/) { return 2; }
    if ($prof eq 'Bow'   && $wname =~ /bow|arrow/)   { return 2; }
    if ($prof eq 'Staff' && $wname =~ /staff|pole/)  { return 2; }
    if ($prof eq 'Dagger'&& $wname =~ /dagger|knife/){ return 2; }
    if ($prof eq 'Mace'  && $wname =~ /mace|club/)   { return 2; }
    if ($prof eq 'Sling' && $wname =~ /sling|stone/) { return 2; }
    if ($prof eq 'Unarmed' && $wname =~ /fist|hand|unarmed|punch|kick/) { return 2; }
    return 0;
}

# ============================================================================
# CHARACTER ADVANCEMENT
# ============================================================================

sub check_level_up {
    my ($player) = @_;
    my $xp = $player->{experience} // 0;
    my $class = $player->{class} // 'Fighter';
    my $level = int($player->{level} // 1);
    $level = 1 if $level < 1;
    my $table = get_xp_table($class);

    my %class_hit_die = (
        Fighter   => 10,
        Paladin   => 10,
        Ranger    => 8,
        MagicUser => 4,
        Thief     => 6,
        Cleric    => 8,
        Druid     => 6,
    );
    my %prime = (
        Fighter   => 'str',
        Paladin   => 'str',
        Ranger    => 'dex',
        MagicUser => 'int',
        Thief     => 'dex',
        Cleric    => 'wis',
        Druid     => 'wis',
    );
    my @stats = qw(str int wis dex pie cha);

    while ($xp >= xp_for_next_level($player)) {
        $level++;
        $player->{level} = $level;

        my $hit_die = $class_hit_die{$class} || 6;
        my $con_mod = int(($player->{stats}{con} - 10) / 2);
        my $hp_gain = 1 + int(rand($hit_die)) + $con_mod;
        $hp_gain = 1 if $hp_gain < 1;
        $player->{max_hp} = ($player->{max_hp} // 1) + $hp_gain;
        $player->{hp} = $player->{max_hp};

        # Classic D&D stat gain
        my $roll = 1 + int(rand(10));
        my $stat;
        if ($roll <= 6) {
            $stat = undef; # No stat gain
        } elsif ($roll <= 8) {
            $stat = $prime{$class} || 'str';
        } elsif ($roll == 9) {
            my @up_stats = grep { $_ ne 'con' } @stats;
            $stat = $up_stats[int(rand(@up_stats))];
        } else {
            $stat = $stats[int(rand(@stats))];
        }
        if ($stat && $player->{stats}{$stat} < 18) {
            $player->{stats}{$stat}++;
            writeline($config{'systemcolor'}."You gain +1 $stat!".$config{'themecolor'}, 1);
        }

        # Spell learning for casters
        if ($class =~ /MagicUser|Cleric|Druid/) {
            my $spellnum = find_new_spell_for_player($player);
            if ($spellnum) {
                player_learn_spell($player, $spellnum);
                my $spell = read_spell_record($spellnum);
                writeline($config{'systemcolor'}."You learn a new spell: $spell->{name}!" . $config{'themecolor'}, 1);
            }
        }
        my $statmsg = $stat ? "+1 $stat" : "no stat gain";
        writeline($config{'systemcolor'}."Congratulations! You have reached level $level! (+$hp_gain HP, $statmsg)".$config{'themecolor'}, 1);

        # --- Room notification ---
        broadcast_room_message($player->{room}, $player->{name},
            $config{'usercolor'}."$player->{name} has reached level $level!".$config{'themecolor'});

        add_to_ranklist($player) if $player && $player->{name};
        save_player($player);
    }
}

sub xp_for_next_level {
    my ($player) = @_;
    my $class = $player->{class} // 'Fighter';
    my $level = int($player->{level} // 1);
    $level = 1 if $level < 1;
    my $table = get_xp_table($class);
   
    if ($level < @$table) {
        return $table->[$level];
    } else {
       
        my $last = $table->[-1];
        my $extra = 250000 * ($level - @$table + 1);
        return $last + $extra;
    }
}

sub xp_for_current_level {
    my ($player) = @_;
    my $class = $player->{class} // 'Fighter';
    my $level = int($player->{level} // 1);
    $level = 1 if $level < 1;
    my $table = get_xp_table($class);
   
    if ($level <= @$table) {
        return $table->[$level-1];
    } else {
        my $last = $table->[-1];
        my $extra = 250000 * ($level - @$table);
        return $last + $extra;
    }
}

# ============================================================================
# COMBAT POINTER & FILE MANAGEMENT
# ============================================================================

sub player_in_combat {
    my ($player_name) = @_;
    my $pointer = player_combat_pointer_path($player_name);
    my $data = read_combat_pointer($pointer);
    return $data && -e $data->{meta};
}

sub cleanup_stale_combat_files {
    my ($player_name) = @_;
    
    # Hash the player name for file lookups
    my $player_hash = safe_name($player_name);
    
    # Clean up all combat-related files for this player
    my $combat_pointer = "$config{transient}/player_$player_hash.combat";
    my $combat_handshake = "$config{transient}/combat_handshake_$player_hash.txt";
    my $combat_response = "$config{transient}/combat_response_$player_hash.txt";
    
    # Get meta file path before removing pointer
    my $meta_file = undef;
    if (-e $combat_pointer) {
        my $pointer_data = read_combat_pointer($combat_pointer);
        if ($pointer_data && $pointer_data->{meta}) {
            $meta_file = $pointer_data->{meta};
            photonmud_debug("cleanup_stale_combat_files: Found meta file $meta_file from pointer");
        }
    }
    
    # Check if player is dead and handle death before removing files
    if ($meta_file && -e $meta_file) {
        my $meta = eval { lock_retrieve($meta_file) };
        if ($meta && $meta->{players} && $meta->{players}{$player_hash}) {
            # If HP is zero or negative in the meta file, this player is dead
            if ($meta->{players}{$player_hash}{hp} <= 0) {
                photonmud_debug("cleanup_stale_combat_files: Player $player_name is dead in meta file");
                
                # Handle player death if this is the current player
                if ($player && $player->{name} eq $player_name) {
                    photonmud_debug("cleanup_stale_combat_files: Handling death for current player");
                    handle_player_death($player);
                }
            }
            
            # Mark this player as done with combat in the meta file
            $meta->{players}{$player_hash}{done} = 1;
            eval { lock_store($meta, $meta_file) };
        }
    }
    
    # Force removal of all player's combat files
    unlink $combat_pointer if -e $combat_pointer;
    unlink $combat_handshake if -e $combat_handshake;
    unlink $combat_response if -e $combat_response;
    
    # If meta file exists and no other player is using it, remove it
    if ($meta_file && -e $meta_file) {
        my $meta = eval { lock_retrieve($meta_file) };
        if ($meta) {
            # Check if all players are marked as done or dead
            my $all_done = 1;
            foreach my $key (keys %{$meta->{players}}) {
                if (!$meta->{players}{$key}{done} && $meta->{players}{$key}{hp} > 0) {
                    $all_done = 0;
                    last;
                }
            }
            
            # Delete meta file if all players are done or dead
            if ($all_done) {
                photonmud_debug("cleanup_stale_combat_files: All players done with combat, deleting meta file");
                unlink $meta_file;
            } else {
                # Also check if any pointers still reference this meta file
                my $in_use = 0;
                
                foreach my $f (glob("$config{transient}/player_*.combat"), glob("$config{transient}/monster_*.combat")) {
                    next if $f =~ /player_${player_hash}\.combat$/;
                    
                    my $data = read_combat_pointer($f);
                    if ($data && $data->{meta} && $data->{meta} eq $meta_file) {
                        $in_use = 1;
                        last;
                    }
                }
                
                unless ($in_use) {
                    photonmud_debug("cleanup_stale_combat_files: No other pointers to $meta_file, deleting it");
                    unlink $meta_file;
                }
            }
        }
    }
    
    # Reset combat state
    $::last_in_combat = 0;
    
    photonmud_debug("Completed cleanup of combat files for $player_name");
    return 1;
}

# ============================================================================
# COMBAT RESOLUTION
# ============================================================================

sub resolve_defense_effects {
    my ($attacker, $defender, $dmg, $roomid) = @_;
    
    # Safety check - ensure both attacker and defender are hash references
    return $dmg unless ref($attacker) eq 'HASH' && ref($defender) eq 'HASH';

    # Defensive flags are set on the defender's player hash
    # _dodge_next: 50% chance to avoid all damage
    if ($defender->{_dodge_next}) {
        if (rand() < 0.5) {
            $dmg = 0;
            writeline($config{'systemcolor'}."You dodge the attack!".$config{'themecolor'}, 1) 
                if $defender->{name} && $player && $defender->{name} eq $player->{name};
            writeline($config{'systemcolor'}."$defender->{name} dodges your attack!".$config{'themecolor'}, 1) 
                if $attacker->{name} && $player && $attacker->{name} eq $player->{name};
            broadcast_room_message($roomid, '', $config{'usercolor'}."$defender->{name} dodges $attacker->{name}'s attack!".$config{'themecolor'});
        }
        $defender->{_dodge_next} = 0;
    }
    
    # _parry_next: halve damage if not dodged
    if ($defender->{_parry_next}) {
        $dmg = int($dmg/2);
        writeline($config{'systemcolor'}."You parry the attack! (damage halved)".$config{'themecolor'}, 1) 
            if $defender->{name} && $player && $defender->{name} eq $player->{name};
        writeline($config{'systemcolor'}."$defender->{name} parries your attack!".$config{'themecolor'}, 1) 
            if $attacker->{name} && $player && $attacker->{name} eq $player->{name};
        broadcast_room_message($roomid, '', $config{'usercolor'}."$defender->{name} parries $attacker->{name}'s attack!".$config{'themecolor'});
        $defender->{_parry_next} = 0;
    }
    
    # _guard_next: reduce damage by 2
    if ($defender->{_guard_next}) {
        $dmg -= 2;
        $dmg = 0 if $dmg < 0;
        writeline($config{'systemcolor'}."You guard against the attack! (damage -2)".$config{'themecolor'}, 1) 
            if $defender->{name} && $player && $defender->{name} eq $player->{name};
        writeline($config{'systemcolor'}."$defender->{name} guards against your attack!".$config{'themecolor'}, 1) 
            if $attacker->{name} && $player && $attacker->{name} eq $player->{name};
        broadcast_room_message($roomid, '', $config{'usercolor'}."$defender->{name} guards against $attacker->{name}'s attack!".$config{'themecolor'});
        $defender->{_guard_next} = 0;
    }
    
    # _shield_next: halve damage if not dodged
    if ($defender->{_shield_next}) {
        $dmg = int($dmg/2);
        writeline($config{'systemcolor'}."You block with your shield! (damage halved)".$config{'themecolor'}, 1) 
            if $defender->{name} && $player && $defender->{name} eq $player->{name};
        writeline($config{'systemcolor'}."$defender->{name} blocks with a shield!".$config{'themecolor'}, 1) 
            if $attacker->{name} && $player && $attacker->{name} eq $player->{name};
        broadcast_room_message($roomid, '', $config{'usercolor'}."$defender->{name} blocks $attacker->{name}'s attack with a shield!".$config{'themecolor'});
        $defender->{_shield_next} = 0;
    }
    
    # _counter_next: reflect half damage back to attacker
    if ($defender->{_counter_next}) {
        my $reflected = int($dmg/2);
        if ($reflected > 0) {
            $attacker->{hp} -= $reflected;
            writeline($config{'systemcolor'}."You counter and reflect $reflected damage!".$config{'themecolor'}, 1) 
                if $defender->{name} && $player && $defender->{name} eq $player->{name};
            writeline($config{'systemcolor'}."$defender->{name} counters and you take $reflected damage!".$config{'themecolor'}, 1) 
                if $attacker->{name} && $player && $attacker->{name} eq $player->{name};
            broadcast_room_message($roomid, '', $config{'usercolor'}."$defender->{name} counters $attacker->{name}'s attack and reflects $reflected damage!".$config{'themecolor'});
        }
        $defender->{_counter_next} = 0;
    }
    
    return $dmg;
}

# ============================================================================
# COMBAT INITIALIZATION
# ============================================================================
sub atomic_start_pvp_combat {
    my ($p1, $p2, $combat_mode) = @_;
    $combat_mode //= COMBAT_MODE_NORMAL;
    
    # Basic sanity check for required parameters
    unless ($p1 && $p2) {
        combat_debug("[COMBAT] atomic_start_pvp_combat: Missing required parameters");
        return (undef, undef);
    }
    
    # Track execution with timestamps for debugging
    my $start_time = time();
    
    # Ensure players have proper IDs
    my $p1_id = $p1->{is_monster} ? $p1->{id} : safe_name($p1->{name});
    my $p2_id = $p2->{is_monster} ? $p2->{id} : safe_name($p2->{name});
    
    combat_debug("[COMBAT] atomic_start_pvp_combat: Starting initiation between $p1_id and $p2_id (mode: $combat_mode)");
    
    # Check if either participant is already in combat
    if (($p1->{is_monster} && monster_in_combat($p1->{id})) || 
        (!$p1->{is_monster} && player_in_combat($p1->{name})) ||
        ($p2->{is_monster} && monster_in_combat($p2->{id})) || 
        (!$p2->{is_monster} && player_in_combat($p2->{name}))) {
        
        combat_debug("[COMBAT] atomic_start_pvp_combat: One or both participants already in combat");
        return (undef, undef);
    }
    
    # Verify they are in the same room
    my $p1_room = $p1->{room};
    my $p2_room = $p2->{room};
    
    unless (defined $p1_room && defined $p2_room && $p1_room == $p2_room) {
        combat_debug("[COMBAT] atomic_start_pvp_combat: $p1_id and $p2_id not in same room ($p1_room vs $p2_room)");
        return (undef, undef);
    }
    
    # Generate unique creator ID for this combat
    my $creator_id = "$$-" . time() . "-" . int(rand(1000000));
    
    # Generate metafile path
    my $meta_file = combat_metafile_path($p1, $p2);
    
    # Initialize combat meta object
    my $meta = {
        players => {
            $p1_id => {
                id        => $p1->{id},
                name      => $p1->{name},
                hp        => $p1->{hp} // 1,
                max_hp    => $p1->{max_hp} // $p1->{hp} // 1,
                stats     => $p1->{stats} // {},
                is_monster=> $p1->{is_monster} // 0,
                ready     => 0,
                initiator => 1,
                room      => $p1_room,
                level     => $p1->{level} // 1,
                treasure  => $p1->{treasure},
                gold      => $p1->{gold} // 0,
                inventory => $p1->{inventory},
                team      => get_player_team($p1),
                alignment => $p1->{alignment},
                alliance_type => ALLIANCE_PERMANENT,
            },
            $p2_id => {
                id        => $p2->{id},
                name      => $p2->{name},
                hp        => $p2->{hp} // 1,
                max_hp    => $p2->{max_hp} // $p2->{hp} // 1,
                stats     => $p2->{stats} // {},
                is_monster=> $p2->{is_monster} // 0,
                ready     => 0,
                initiator => 0,
                room      => $p2_room,
                level     => $p2->{level} // 1,
                treasure  => $p2->{treasure},
                gold      => $p2->{gold} // 0,
                inventory => $p2->{inventory},
                team      => get_player_team($p2),
                alignment => $p2->{alignment},
                alliance_type => ALLIANCE_PERMANENT,
            },
        },
        status => "initiated",
        combat_mode => $combat_mode,
        log => [ { 
            actor => "system", 
            msg => "$p1->{name} engages $p2->{name} in combat!",
            time => time(),
            displayed_to => {}
        } ],
        creator_id => $creator_id,
        alliances => {},
        free_for_all => ($combat_mode == COMBAT_MODE_FFA),
        mercenary => ($combat_mode == COMBAT_MODE_MERCENARY),
    };
    
    # Set up initial teams/alliances
    if ($combat_mode == COMBAT_MODE_PARTY) {
        # In party mode, members of the same party are automatically allied
        setup_party_alliances($meta);
    }
    elsif ($combat_mode == COMBAT_MODE_FFA) {
        # In FFA mode, every player starts on their own team
        foreach my $pid (keys %{$meta->{players}}) {
            $meta->{players}{$pid}{team} = $pid;
        }
    }
    
    # Set alliance types based on alignment for players
    foreach my $pid (keys %{$meta->{players}}) {
        my $p = $meta->{players}{$pid};
        next if $p->{is_monster};
        
        # Chaotic evil players can always betray
        if ($p->{alignment} && $p->{alignment} =~ /chaotic\s+evil/i) {
            $p->{can_betray} = 1;
            $p->{alliance_type} = ALLIANCE_TEMPORARY;
        }
        # Lawful players are less likely to break alliances
        elsif ($p->{alignment} && $p->{alignment} =~ /lawful/i) {
            $p->{can_betray} = 0;
            $p->{alliance_type} = ALLIANCE_PERMANENT;
        }
        # Others have standard ability to change alliances
        else {
            $p->{can_betray} = ($combat_mode != COMBAT_MODE_NORMAL);
            $p->{alliance_type} = ALLIANCE_TEMPORARY;
        }
    }
    
    # Create directory structure if needed
    my $meta_dir = $meta_file;
    $meta_dir =~ s/\/[^\/]+$//;
    unless (-d $meta_dir) {
        eval { make_path($meta_dir) };
        if ($@) {
            combat_debug("[COMBAT] atomic_start_pvp_combat: Failed to create directory $meta_dir: $@");
            return (undef, undef);
        }
    }
    
    # Store meta file
    eval {
        lock_store($meta, $meta_file);
    };
    if ($@) {
        combat_debug("[COMBAT] atomic_start_pvp_combat: Failed to store combat meta: $@");
        return (undef, undef);
    }
    
    combat_debug("[COMBAT] atomic_start_pvp_combat: Created meta file $meta_file");
    
    # Clean up any existing combat pointers for the participants
    unlink player_combat_pointer_path($p1->{name}) unless $p1->{is_monster};
    unlink monster_combat_pointer_path($p1->{id}) if $p1->{is_monster};
    unlink player_combat_pointer_path($p2->{name}) unless $p2->{is_monster};
    unlink monster_combat_pointer_path($p2->{id}) if $p2->{is_monster};
    
    # Now create the pointer files that reference the meta file
    if ($p1->{is_monster}) {
        write_combat_pointer(monster_combat_pointer_path($p1->{id}), $meta_file, $creator_id);
        # Set combat lock for P1 monster
        my $opponent_name = $p2->{is_monster} ? "monster_$p2->{id}" : $p2->{name};
        if (defined &set_monster_combat_lock) {
            set_monster_combat_lock($p1->{id}, $opponent_name, 300);
            combat_debug("[COMBAT] atomic_start_pvp_combat: Set combat lock for monster $p1->{id}");
        }
    } else {
        write_combat_pointer(player_combat_pointer_path($p1->{name}), $meta_file, $creator_id);
    }
    
    # Mark P1 (initiator) as ready
    $meta->{players}{$p1_id}{ready} = 1;
    
    # Handle P2 based on type
    if ($p2->{is_monster}) {
        # Monsters are always ready for combat
        write_combat_pointer(monster_combat_pointer_path($p2->{id}), $meta_file, $creator_id);
        $meta->{players}{$p2_id}{ready} = 1;
        
        # IMPORTANT: Set monster combat lock so monsterai knows not to move this monster
        my $player_name = $p1->{is_monster} ? "monster_$p1->{id}" : $p1->{name};
        if (defined &set_monster_combat_lock) {
            set_monster_combat_lock($p2->{id}, $player_name, 300);  # 5 minute lock
            combat_debug("[COMBAT] atomic_start_pvp_combat: Set combat lock for monster $p2->{id}");
        }
        
        # Update meta status since both are ready
        $meta->{status} = "initializing";
        
        # Save updated meta with ready status
        eval { lock_store($meta, $meta_file) };
        if ($@) {
            combat_debug("[COMBAT] atomic_start_pvp_combat: Failed to save meta after monster ready: $@");
            # Clean up on failure
            unlink $meta_file;
            unlink monster_combat_pointer_path($p1->{id}) if $p1->{is_monster};
            unlink player_combat_pointer_path($p1->{name}) unless $p1->{is_monster};
            unlink monster_combat_pointer_path($p2->{id});
            return (undef, undef);
        }
        
        combat_debug("[COMBAT] atomic_start_pvp_combat: Monster combat ready, both participants set");
    } else {
        # For player P2, create a handshake file and wait for response
        my $handshake_file = "$config{transient}/combat_handshake_" . safe_name($p2->{name}) . ".txt";
        
        # Create handshake file
        eval {
            open(my $hf, ">", $handshake_file) or die "Cannot create handshake file: $!";
            print $hf "$p1->{name}|$p1_id|$p1_room|" . time();
            close($hf);
        };
        if ($@) {
            combat_debug("[COMBAT] atomic_start_pvp_combat: Failed to create handshake file: $@");
            # Clean up on failure
            unlink $meta_file;
            unlink monster_combat_pointer_path($p1->{id}) if $p1->{is_monster};
            unlink player_combat_pointer_path($p1->{name}) unless $p1->{is_monster};
            return (undef, undef);
        }
        
        combat_debug("[COMBAT] atomic_start_pvp_combat: Created handshake file for $p2->{name}");
        
        # Wait for defender's response
        my $response_file = "$config{transient}/combat_response_" . safe_name($p2->{name}) . ".txt";
        my $wait_start = time();
        my $max_wait = 30;  # 30 seconds timeout
        my $defender_response = "";
        
        # Wait for response file to appear with improved file reading
        while (time() - $wait_start < $max_wait) {
            if (-e $response_file) {
                # Read response with retry logic for partial writes and file locking issues
                my $attempts = 0;
                my $max_attempts = 10;
                my $resp_data;
                
                while ($attempts < $max_attempts) {
                    eval {
                        # Use sysopen with shared lock to prevent race conditions
                        if (sysopen(my $rf, $response_file, O_RDONLY)) {
                            # Try to get a shared lock
                            if (flock($rf, LOCK_SH | LOCK_NB)) {
                                $resp_data = do { local $/; <$rf> };
                                flock($rf, LOCK_UN);
                            } else {
                                # If we can't lock, read without lock (file might be being written)
                                $resp_data = do { local $/; <$rf> };
                            }
                            close($rf);
                        }
                    };
                    
                    # If we got data and it contains the pipe separator, we have a complete response
                    if ($resp_data && $resp_data =~ /\|/) {
                        combat_debug("[COMBAT] atomic_start_pvp_combat: Read response data: '$resp_data'");
                        last;
                    }
                    
                    # Short delay before retry
                    select(undef, undef, undef, 0.05);
                    $attempts++;
                }
                
                # Parse the response if we got valid data
                if ($resp_data) {
                    chomp($resp_data);
                    if ($resp_data =~ /^fight\|/) {
                        $defender_response = "fight";
                        combat_debug("[COMBAT] atomic_start_pvp_combat: Player chose to fight");
                    } elsif ($resp_data =~ /^run\|/) {
                        $defender_response = "run";
                        combat_debug("[COMBAT] atomic_start_pvp_combat: Player chose to run");
                    } else {
                        combat_debug("[COMBAT] atomic_start_pvp_combat: Invalid response format: '$resp_data'");
                    }
                }
                
                # Break on valid response
                if ($defender_response eq "fight" || $defender_response eq "run") {
                    last;
                }
                
                # If we couldn't read the file properly, wait a bit longer
                select(undef, undef, undef, 0.1);
            }
            
            # Short wait between checks
            select(undef, undef, undef, 0.1);
        }
        
        # Clean up response file immediately after reading
        unlink $response_file if -e $response_file;
        
        # Process defender's response
        if ($defender_response eq "run") {
            # Player chose to run, abort combat
            combat_debug("[COMBAT] atomic_start_pvp_combat: Defender chose to run, aborting combat");
            
            # Clean up all created files
            unlink $handshake_file if -e $handshake_file;
            unlink $meta_file if -e $meta_file;
            unlink monster_combat_pointer_path($p1->{id}) if $p1->{is_monster};
            unlink player_combat_pointer_path($p1->{name}) unless $p1->{is_monster};
            
            return (undef, undef);
        } elsif ($defender_response eq "fight") {
            # Player accepted combat
            combat_debug("[COMBAT] atomic_start_pvp_combat: Defender accepted combat");
            
            # Mark that combat is initializing
            $meta->{status} = "initializing";
            $meta->{players}{$p2_id}{ready} = 1;
            
            # Save meta with updated status
            eval { lock_store($meta, $meta_file) };
            if ($@) {
                combat_debug("[COMBAT] atomic_start_pvp_combat: Failed to save meta after player acceptance: $@");
                # Clean up on failure
                unlink $handshake_file if -e $handshake_file;
                unlink $meta_file;
                unlink monster_combat_pointer_path($p1->{id}) if $p1->{is_monster};
                unlink player_combat_pointer_path($p1->{name}) unless $p1->{is_monster};
                return (undef, undef);
            }
            
            # Now create pointer for P2 since they've agreed to fight
            write_combat_pointer(player_combat_pointer_path($p2->{name}), $meta_file, $creator_id);
            
            # Clean up handshake file
            unlink $handshake_file if -e $handshake_file;
            
            combat_debug("[COMBAT] atomic_start_pvp_combat: Combat accepted, pointers created for both players");
            
            # CRITICAL: Don't return here - continue to the final success section
        } else {
            # No or invalid response, abort combat
            combat_debug("[COMBAT] atomic_start_pvp_combat: No valid response from defender (response='$defender_response'), aborting combat");
            
            # Clean up all created files
            unlink $handshake_file if -e $handshake_file;
            unlink $meta_file if -e $meta_file;
            unlink monster_combat_pointer_path($p1->{id}) if $p1->{is_monster};
            unlink player_combat_pointer_path($p1->{name}) unless $p1->{is_monster};
            
            return (undef, undef);
        }
    }
    
    # Broadcast combat start to room
    broadcast_room_message(
        $p1_room,
        $p1->{name},
        $config{'usercolor'}."$p1->{name} attacks $p2->{name}!".$config{'themecolor'}
    );
    
    # If this is party combat, also notify all party members
    if ($combat_mode == COMBAT_MODE_PARTY) {
        # Automatically include all party members of both players
        include_party_in_combat($p1, $p2, $meta_file, $creator_id);
        include_party_in_combat($p2, $p1, $meta_file, $creator_id);
    }
    
    # Log completion time for performance tracking
    my $end_time = time();
    combat_debug("[COMBAT] atomic_start_pvp_combat: completed in " . ($end_time - $start_time) . " seconds");
    
    # CRITICAL: Always return both values for success
    combat_debug("[COMBAT] atomic_start_pvp_combat: SUCCESS - returning meta_file='$meta_file', creator_id='$creator_id'");
    return ($meta_file, $creator_id);
}

# Helper function to determine a player's team
sub get_player_team {
    my ($player) = @_;
    
    # Monster team is based on monster type or just "monsters"
    if ($player->{is_monster}) {
        return $player->{monster_type} || "monsters";
    }
    
    # Player team is based on party membership
    if (defined &party_leader_of) {
        my $leader = party_leader_of($player->{name});
        return $leader if $leader;
    }
    
    # Default: player is their own team
    return $player->{name};
}

# Set up alliances for party combat
sub setup_party_alliances {
    my ($meta) = @_;
    
    # Create a mapping of players to their party leaders
    my %party_membership;
    
    foreach my $pid (keys %{$meta->{players}}) {
        my $p = $meta->{players}{$pid};
        next if $p->{is_monster};
        
        if (defined &party_leader_of) {
            my $leader = party_leader_of($p->{name});
            if ($leader) {
                $party_membership{$pid} = safe_name($leader);
                $p->{team} = safe_name($leader);
            } else {
                $party_membership{$pid} = $pid;
                $p->{team} = $pid;
            }
        } else {
            $party_membership{$pid} = $pid;
            $p->{team} = $pid;
        }
    }
    
    # Now create alliance records
    foreach my $pid1 (keys %party_membership) {
        foreach my $pid2 (keys %party_membership) {
            next if $pid1 eq $pid2;
            
            # If in same party, create alliance
            if ($party_membership{$pid1} eq $party_membership{$pid2}) {
                $meta->{alliances}{$pid1}{$pid2} = ALLIANCE_PERMANENT;
                $meta->{alliances}{$pid2}{$pid1} = ALLIANCE_PERMANENT;
            }
        }
    }
}

# Include party members in combat
sub include_party_in_combat {
    my ($player, $opponent, $meta_file, $creator_id) = @_;
    return unless defined &party_members;
    return if $player->{is_monster};
    
    # Get player's party members
    my @members = party_members($player->{name});
    return unless @members;
    
    # Load the meta file
    my $meta = eval { lock_retrieve($meta_file) };
    return unless $meta;
    
    # Add each party member who's in the same room
    foreach my $member (@members) {
        next if $member eq $player->{name}; # Skip the original player
        
        my $member_obj = load_player($member);
        next unless $member_obj;
        
        # Only include if in the same room
        next unless $member_obj->{room} == $player->{room};
        
        # Skip if already in combat
        next if player_in_combat($member);
        
        # Generate safe name
        my $member_id = safe_name($member);
        
        # Skip if already in this combat
        next if exists $meta->{players}{$member_id};
        
        # Add to combat
        $meta->{players}{$member_id} = {
            id        => $member_id,
            name      => $member,
            hp        => $member_obj->{hp} // 1,
            max_hp    => $member_obj->{max_hp} // $member_obj->{hp} // 1,
            stats     => $member_obj->{stats} // {},
            is_monster=> 0,
            ready     => 1, # Auto-ready for party members
            initiator => 0,
            room      => $member_obj->{room},
            level     => $member_obj->{level} // 1,
            treasure  => $member_obj->{treasure},
            gold      => $member_obj->{gold} // 0,
            inventory => $member_obj->{inventory},
            team      => get_player_team($member_obj),
            alignment => $member_obj->{alignment},
            alliance_type => ALLIANCE_PERMANENT,
        };
        
        # Set up alliances between party members
        foreach my $pid (keys %{$meta->{players}}) {
            my $p = $meta->{players}{$pid};
            next if $p->{is_monster};
            
            # If same team/party, create alliance
            if ($p->{team} eq $meta->{players}{$member_id}{team}) {
                $meta->{alliances}{$pid}{$member_id} = ALLIANCE_PERMANENT;
                $meta->{alliances}{$member_id}{$pid} = ALLIANCE_PERMANENT;
            }
        }
        
        # Create a pointer for this player
        write_combat_pointer(player_combat_pointer_path($member), $meta_file, $creator_id);
        
        # Notify the player they've joined combat
        if (defined &write_session_message && player_online($member)) {
            write_session_message($member, 
                $config{'systemcolor'}."You join $player->{name} in combat with $opponent->{name}!".$config{'themecolor'});
        }
        
        # Add to combat log
        push @{$meta->{log}}, {
            actor => "system",
            msg => "$member joins the combat!",
            time => time(),
            displayed_to => {}
        };
        
        combat_debug("[COMBAT] include_party_in_combat: Added $member to combat $meta_file");
    }
    
    # Save updated meta
    eval { lock_store($meta, $meta_file) };
}

sub get_combat_participants {
    my ($file) = @_;
    combat_debug("get_combat_participants: loading participants from $file");
    my $meta = eval { lock_retrieve($file) };
    unless ($meta && $meta->{players}) {
        combat_debug("get_combat_participants: failed to load meta or no players in $file");
        return ();
    }
    my @participants;
    foreach my $key (keys %{$meta->{players}}) {
        my $p = $meta->{players}{$key};
        combat_debug("get_combat_participants: found participant key=$key, name=$p->{name}, is_monster=$p->{is_monster}, id=$p->{id}");
        # Try to load full player or monster object
        if ($p->{is_monster}) {
            my $room = read_room_record($p->{room});
            my @monsters = get_room_monsters($room);
            my ($mon) = grep { $_->{id} eq $p->{id} } @monsters;
            $mon //= { %$p }; # fallback to meta
            combat_debug("get_combat_participants: loaded monster object for id=$p->{id}, name=$p->{name}");
            push @participants, $mon;
        } else {
            my $pl = load_player($p->{name});
            $pl //= { %$p }; # fallback to meta
            combat_debug("get_combat_participants: loaded player object for name=$p->{name}");
            push @participants, $pl;
        }
    }
    combat_debug("get_combat_participants: returning " . scalar(@participants) . " participants");
    return @participants;
}

sub write_combat_pointer {
    my ($path, $meta_file, $creator) = @_;
    my $data = {
        meta    => $meta_file,
        creator => $creator,
        time    => time,
        host    => `hostname` =~ /(\S+)/ ? $1 : '',
        pid     => $$,
    };
    open(my $fh, ">", $path) or die "Can't write $path: $!";
    print $fh encode_json($data);
    close($fh);
}

sub read_combat_pointer {
    my ($path) = @_;
    return unless -e $path;
    open(my $fh, "<", $path) or return;
    local $/;
    my $json = <$fh>;
    close($fh);
    my $data = eval { decode_json($json) };
    return $data if $data && $data->{meta};
    return;
}

sub delete_combat_pointer_if_creator {
    my ($path, $expected_creator) = @_;
    my $data = read_combat_pointer($path);
    return unless $data && $data->{creator} && $data->{creator} eq $expected_creator;
    unlink $path;
}

# ============================================================================
# POINTER PATH HELPERS
# ============================================================================

sub player_combat_pointer_path {
    my ($player_name) = @_;
    my $player_hash = safe_name($player_name);
    return "$config{transient}/player_${player_hash}.combat";
}

sub monster_combat_pointer_path {
    my ($id) = @_;
    return "$config{transient}/monster_$id.combat";
}

sub combat_metafile_path {
    my ($p1, $p2) = @_;
    
    # Handle both string names and hash refs
    my $p1_id;
    if (ref($p1) eq 'HASH') {
        $p1_id = $p1->{is_monster} ? $p1->{id} : safe_name($p1->{name});
    } else {
        # It's a string (player name)
        $p1_id = safe_name($p1);
    }
    
    my $p2_id;
    if (ref($p2) eq 'HASH') {
        $p2_id = $p2->{is_monster} ? $p2->{id} : safe_name($p2->{name});
    } else {
        # It's a string (player name)
        $p2_id = safe_name($p2);
    }
    
    my @sorted = sort($p1_id, $p2_id);
    return "$config{transient}/combat_$sorted[0]_$sorted[1].storable";
}

# ============================================================================
# COMBAT LOOP
# ============================================================================

sub pvp_combat_metaloop {
    my ($actor, %opts) = @_;
    my $is_ai = $opts{ai} // 0;
    my $actor_key = $actor->{is_monster} ? $actor->{id} : safe_name($actor->{name});
    my $pointer = $actor->{is_monster}
        ? monster_combat_pointer_path($actor->{id})
        : player_combat_pointer_path($actor->{name});
    
    combat_debug("pvp_combat_metaloop: actor=$actor_key, is_ai=$is_ai, pointer=$pointer");
    
    # Verify pointer exists
    unless (-e $pointer) {
        combat_debug("pvp_combat_metaloop: pointer file $pointer doesn't exist, exiting.");
        return;
    }

    # Read the combat pointer data
    my $pointer_data = read_combat_pointer($pointer);
    unless ($pointer_data && $pointer_data->{meta}) {
        combat_debug("pvp_combat_metaloop: pointer file $pointer missing or invalid, exiting.");
        return;
    }
    
    my $file = $pointer_data->{meta};
    my $creator_id = $pointer_data->{creator} // "$$";
    combat_debug("pvp_combat_metaloop: using meta file $file");

    # Verify meta file exists
    unless ($file && -e $file) {
        combat_debug("pvp_combat_metaloop: meta file $file doesn't exist, exiting.");
        unlink $pointer if -e $pointer;
        return;
    }

    # Load meta file
    my $meta = eval { lock_retrieve($file) };
    unless ($meta && $meta->{players}) {
        combat_debug("pvp_combat_metaloop: meta file $file missing or unreadable, exiting.");
        return;
    }

    # Check if we need to upgrade to group combat
    my @keys = keys %{$meta->{players}};
    my $combat_mode = $meta->{combat_mode} // COMBAT_MODE_NORMAL;
    if (@keys > 2 || $combat_mode != COMBAT_MODE_NORMAL) {
        combat_debug("pvp_combat_metaloop: Detected >2 participants or non-standard mode, upgrading to group combat.");
        group_combat_metaloop($actor, %opts);
        return;
    }

    # Identify opponent
    my ($opponent_key) = grep { $_ ne $actor_key } @keys;
    unless ($actor_key && $opponent_key) {
        combat_debug("pvp_combat_metaloop: Could not find actor_key/opponent_key in metafile");
        cleanup_pvp_metafiles($actor_key, $opponent_key, $file, $creator_id) unless $is_ai;
        return;
    }
    
    # Get state for both participants
    my $my_state = $meta->{players}{$actor_key};
    my $opp_state = $meta->{players}{$opponent_key};
    
    # Verify room positions match
    if (defined $my_state->{room} && defined $opp_state->{room} && $my_state->{room} != $opp_state->{room}) {
        combat_debug("pvp_combat_metaloop: room mismatch before combat ($my_state->{room} vs $opp_state->{room})");
        writeline($config{'errorcolor'}."Combat aborted: you and your opponent are in different rooms.".$config{'themecolor'}, 1) unless $is_ai;
        $meta->{status} = "aborted";
        $meta->{abort_reason} = "room_mismatch";
        lock_store($meta, $file);
        cleanup_pvp_metafiles($actor_key, $opponent_key, $file, $creator_id) unless $is_ai;
        return;
    }
    
    # Set ourselves as ready for combat
    $my_state->{ready} = 1;
    $my_state->{ready_time} = time();
    
    # If we're the first to mark ready, announce combat beginning
    if ($meta->{status} eq "initiated" || $meta->{status} eq "initializing") {
        # Show the "Combat begins" message only to the player
        unless ($is_ai) {
            writeline($config{'systemcolor'}."Combat begins now!".$config{'themecolor'}, 1);
        }
        
        # If opponent is an AI or already ready, initialize combat fully
        if ($opp_state->{is_monster} || $opp_state->{ready}) {
            # Roll initiative since both sides are ready
            my $dex_a = $my_state->{stats}{dex} // 10;
            my $dex_b = $opp_state->{stats}{dex} // 10;
            my $init_a = int(rand(20)) + 1 + int(($dex_a - 10) / 2);
            my $init_b = int(rand(20)) + 1 + int(($dex_b - 10) / 2);
            my ($first, $second) = $init_a > $init_b ? ($actor_key, $opponent_key)
                                    : $init_b > $init_a ? ($opponent_key, $actor_key)
                                    : (rand() < 0.5 ? ($actor_key, $opponent_key) : ($opponent_key, $actor_key));
            
            $meta->{initiative} = { $actor_key => $init_a, $opponent_key => $init_b };
            $meta->{turn_order} = [ $first, $second ];
            $meta->{turn_index} = 0;
            $meta->{turn} = $first;
            $meta->{current_turn} = $first;  # Ensure both turn fields are set
            $meta->{status} = "active";
            $meta->{victory_announced} = 0;  # Initialize victory announcement tracker
            
            # Format message with player/monster names
            my $first_name = $meta->{players}{$first}{name};
            my $msg = "$first_name wins initiative and acts first!";
            
            # Add to combat log
            push @{$meta->{log}}, { 
                actor => "system", 
                msg => $msg, 
                time => time(),
                displayed_to => {}
            };
            
            combat_debug("pvp_combat_metaloop: Rolled initiative: $init_a vs $init_b, $first_name goes first");
            
            # Immediately save the meta file with turn info
            lock_store($meta, $file);
        }
    }
    
    # Save updated meta
    lock_store($meta, $file);
    
    # Wait for status to become active
    my $wait_start = time();
    my $active_notified = 0;
    
    while (1) {
        # Reload meta to check if initiative has been rolled
        $meta = eval { lock_retrieve($file) };
        
        # Exit if meta file disappeared
        unless ($meta) {
            combat_debug("pvp_combat_metaloop: meta file disappeared during wait");
            return;
        }
        
        # If status is active, we can proceed
        if ($meta->{status} eq "active") {
            # Only show initiative message once
            if (!$active_notified && !$is_ai) {
                $active_notified = 1;
                # Ensure a small pause to let the messages appear in the right order
                select(undef, undef, undef, 0.5);
                combat_debug("pvp_combat_metaloop: combat is now active");
            }
            last;
        }
        
        # If combat has already completed (victory, etc.), exit normally
        if ($meta->{status} eq "completed") {
            combat_debug("pvp_combat_metaloop: combat has already completed with reason: $meta->{end_reason}");
            cleanup_pvp_metafiles($actor_key, $opponent_key, $file, $creator_id) unless $is_ai;
            return;
        }

        # If status is still initializing, check if we need to activate it
        if (($meta->{status} eq "initializing" || $meta->{status} eq "initiated") && 
            $meta->{players}{$actor_key}{ready} && $meta->{players}{$opponent_key}{ready}) {
            
            # Initialize combat if both are ready but status is still pending
            if (!$meta->{initiative}) {
                my $dex_a = $meta->{players}{$actor_key}{stats}{dex} // 10;
                my $dex_b = $meta->{players}{$opponent_key}{stats}{dex} // 10;
                my $init_a = int(rand(20)) + 1 + int(($dex_a - 10) / 2);
                my $init_b = int(rand(20)) + 1 + int(($dex_b - 10) / 2);
                my ($first, $second) = $init_a >= $init_b ? ($actor_key, $opponent_key) : ($opponent_key, $actor_key);
                
                $meta->{initiative} = { $actor_key => $init_a, $opponent_key => $init_b };
                $meta->{turn_order} = [ $first, $second ];
                $meta->{turn_index} = 0;
                $meta->{turn} = $first;
                $meta->{current_turn} = $first;  # Ensure both turn fields are set
                $meta->{victory_announced} = 0;  # Initialize victory announcement tracker
                
                # Format message with player/monster names
                my $first_name = $meta->{players}{$first}{name};
                my $msg = "$first_name wins initiative and acts first!";
                
                # Add to combat log
                push @{$meta->{log}}, { 
                    actor => "system", 
                    msg => $msg, 
                    time => time(),
                    displayed_to => {}
                };
            }
            
            $meta->{status} = "active";
            lock_store($meta, $file);
            
            # Small delay to ensure UI sequence is clear
            select(undef, undef, undef, 0.5);
            combat_debug("pvp_combat_metaloop: Combat now active, both sides ready");
            last;
        }
        
        # Check for timeout
        if (time() - $wait_start > 15) {  # 15 second timeout
            # Check one last time if combat has completed properly
            $meta = eval { lock_retrieve($file) };
            if ($meta && $meta->{status} eq "completed") {
                combat_debug("pvp_combat_metaloop: combat completed successfully just before timeout");
                cleanup_pvp_metafiles($actor_key, $opponent_key, $file, $creator_id) unless $is_ai;
                return;
            }
            
            combat_debug("pvp_combat_metaloop: timeout waiting for active status");
            writeline($config{'errorcolor'}."Combat initialization timed out.".$config{'themecolor'}, 1) unless $is_ai;
            
            # Add this to notify the other player
            if ($meta->{players}{$opponent_key} && 
                player_online($meta->{players}{$opponent_key}{name}) && 
                defined &send_session_message) {
                send_session_message($meta->{players}{$opponent_key}{name}, 
                    $config{'errorcolor'}."Combat with $actor->{name} timed out.".$config{'themecolor'});
            }
            
            # Mark combat as aborted in metadata only if not already completed
            if ($meta->{status} ne "completed") {
                $meta->{status} = "aborted";
                $meta->{abort_reason} = "timeout";
                lock_store($meta, $file);
            }
            
            cleanup_pvp_metafiles($actor_key, $opponent_key, $file, $creator_id) unless $is_ai;
            return;
        }
        
        # Short wait
        select(undef, undef, undef, 0.1);
    }
    
    # --- Main combat loop ---
    my $last_processed_turn_index = -1;  # Track which turn we last processed
    my $turn_count = 0;
    my $max_turns = 50;  # Safeguard to prevent infinite loops
    
    while ($turn_count < $max_turns) {
        $turn_count++;
        
        # Reload meta at start of each iteration
        $meta = eval { lock_retrieve($file) };
        unless ($meta) {
            combat_debug("pvp_combat_metaloop: meta file missing in main loop, exiting.");
            cleanup_pvp_metafiles($actor_key, $opponent_key, $file, $creator_id) unless $is_ai;
            return;
        }
        
        # Check if combat ended
        if ($meta->{status} ne "active") {
            combat_debug("pvp_combat_metaloop: combat has ended, status=$meta->{status}");
            cleanup_pvp_metafiles($actor_key, $opponent_key, $file, $creator_id) unless $is_ai;
            return;
        }
        
        # Display any pending messages immediately for all participants
        if ($meta->{log} && @{$meta->{log}}) {
            my $new_messages = 0;
            foreach my $entry (@{$meta->{log}}) {
                next unless $entry->{msg};
                next if $entry->{displayed_to} && $entry->{displayed_to}{$actor_key};
                
                # Color the message appropriately based on content
                my $color = $config{'datacolor'};
                if ($entry->{msg} =~ /attacks|strikes|hits|damage|defeated|critical/i) {
                    $color = $config{'errorcolor'};
                } elsif ($entry->{msg} =~ /misses|fails|dodges|parries|guards|blocks/i) {
                    $color = $config{'systemcolor'};
                } elsif ($entry->{msg} =~ /prepares|ready|stance|evade|deflect/i) {
                    $color = $config{'usercolor'};
                } elsif ($entry->{msg} =~ /It's.*turn!/i) {
                    $color = $config{'systemcolor'};
                }
                
                # Add blank line before turn announcements for better readability
                if ($entry->{msg} =~ /It's.*turn!/i) {
                    writeline("", 1) unless $is_ai;
                }
                
                # Show message to player immediately
                writeline($color . $entry->{msg} . $config{'themecolor'}, 1) unless $is_ai;
                $entry->{displayed_to}{$actor_key} = 1;
                $new_messages = 1;
            }
            
            # Save that we've seen these messages
            if ($new_messages) {
                eval { lock_store($meta, $file) };
            }
        }
        
        # Check current turn assignment
        my $current_turn_key = $meta->{current_turn} || $meta->{turn};
        
        # If it's not our turn, wait for it
        if ($current_turn_key ne $actor_key) {
            combat_debug("pvp_combat_metaloop: waiting for turn, currently " . 
                        ($current_turn_key || "unknown"));
            my $turn_wait_start = time();
            my $last_notification = 0;
            
            while (1) {
                # Reload meta
                $meta = eval { lock_retrieve($file) };
                
                # Exit if meta file disappeared
                unless ($meta) {
                    combat_debug("pvp_combat_metaloop: meta file disappeared during turn wait");
                    return;
                }
                
                # Check if combat ended
                if ($meta->{status} ne "active") {
                    combat_debug("pvp_combat_metaloop: combat ended while waiting for turn, status=$meta->{status}");
                    
                    # If we won (opponent died), make sure we see the victory message
                    if ($meta->{players}{$opponent_key} && $meta->{players}{$opponent_key}{hp} <= 0) {
                        my $victory_msg = "$meta->{players}{$opponent_key}{name} has been defeated!";
                        writeline($config{'systemcolor'}.$victory_msg.$config{'themecolor'}, 1) unless $is_ai;
                    }
                    
                    cleanup_pvp_metafiles($actor_key, $opponent_key, $file, $creator_id) unless $is_ai;
                    return;
                }
                
                # CRITICAL: Process AI turns while waiting
                $current_turn_key = $meta->{current_turn} || $meta->{turn};
                if ($current_turn_key && $current_turn_key ne $actor_key) {
                    my $current_player = $meta->{players}{$current_turn_key};
                    
                    # If it's an AI/monster's turn, process it
                    if ($current_player && $current_player->{is_monster}) {
                        combat_debug("pvp_combat_metaloop: Processing AI turn for $current_player->{name}");
                        
                        # Find the monster object
                        my $room = read_room_record($current_player->{room});
                        my @monsters = get_room_monsters($room);
                        my ($monster) = grep { $_->{id} eq $current_turn_key } @monsters;
                        
                        if ($monster) {
                            # Process AI turn
                            my $ai_action = ai_combat_turn($monster, $meta, $current_turn_key, $actor_key);
                            
                            # IMPORTANT: Display AI messages immediately to player
                            if ($meta->{log} && @{$meta->{log}}) {
                                my $messages_shown = 0;
                                foreach my $entry (@{$meta->{log}}) {
                                    next unless $entry->{msg};
                                    next if $entry->{displayed_to} && $entry->{displayed_to}{$actor_key};
                                    
                                    # Check if this is a recent AI message (within last 5 seconds)
                                    if ($entry->{time} && (time() - $entry->{time}) <= 5) {
                                        # Color the message appropriately
                                        my $color = $config{'datacolor'};
                                        if ($entry->{msg} =~ /attacks|strikes|hits|damage|defeated|critical/i) {
                                            $color = $config{'errorcolor'};
                                        } elsif ($entry->{msg} =~ /misses|fails|dodges|parries|guards|blocks/i) {
                                            $color = $config{'systemcolor'};
                                        } elsif ($entry->{msg} =~ /prepares|ready|stance|evade|deflect/i) {
                                            $color = $config{'usercolor'};
                                        } elsif ($entry->{msg} =~ /It's.*turn!/i) {
                                            $color = $config{'systemcolor'};
                                        }
                                        
                                        # Add blank line before turn announcements
                                        if ($entry->{msg} =~ /It's.*turn!/i) {
                                            writeline("", 1) unless $is_ai;
                                        }
                                        
                                        # Show AI action immediately to player
                                        writeline($color . $entry->{msg} . $config{'themecolor'}, 1) unless $is_ai;
                                        $entry->{displayed_to}{$actor_key} = 1;
                                        $messages_shown = 1;
                                    }
                                }
                                
                                # Save message display tracking if we showed any
                                if ($messages_shown) {
                                    eval { lock_store($meta, $file) };
                                }
                            }
                            
                            # Save meta after AI action
                            eval { lock_store($meta, $file) };
                            
                            # IMMEDIATE death check - if player died from AI attack, handle it NOW
                            if ($meta->{players}{$actor_key}{hp} <= 0) {
                                combat_debug("pvp_combat_metaloop: Player died from AI attack - handling immediately");
                                
                                # Sync HP from combat state to player object
                                $actor->{hp} = $meta->{players}{$actor_key}{hp};
                                
                                # Update global player if this is the current player
                                if ($::player && $::player->{name} eq $actor->{name}) {
                                    $::player->{hp} = $meta->{players}{$actor_key}{hp};
                                }
                                
                                # Save updated player state
                                save_player($actor);
                                
                                # Handle death immediately
                                my $player_obj = load_player($actor->{name});
                                if ($player_obj && !$player_obj->{_death_handled}) {
                                    $player_obj->{_death_handled} = 1;
                                    save_player($player_obj);
                                    handle_player_death($player_obj);
                                } else {
                                    $actor->{_death_handled} = 1;
                                    save_player($actor);
                                    handle_player_death($actor);
                                }
                                
                                cleanup_pvp_metafiles($actor_key, $current_turn_key, $file, $creator_id);
                                return;
                            }
                            
                            # Advance turn after AI action
                            if ($meta->{status} eq "active") {
                                advance_turn($meta, $file);
                            }
                            
                            # Break out of wait loop to check our turn again
                            last;
                        } else {
                            combat_debug("pvp_combat_metaloop: Could not find monster object for AI turn");
                            # Skip the AI turn if we can't find the monster
                            advance_turn($meta, $file);
                            last;
                        }
                    }
                }
                
                # Check if I died
                if ($meta->{players}{$actor_key}{hp} <= 0) {
                    combat_debug("pvp_combat_metaloop: actor died while waiting for turn");
                    if (!$is_ai) {
                        # Sync HP from combat state to player object
                        $actor->{hp} = $meta->{players}{$actor_key}{hp};
                        
                        # Update global player if this is the current player
                        if ($::player && $::player->{name} eq $actor->{name}) {
                            $::player->{hp} = $meta->{players}{$actor_key}{hp};
                        }
                        
                        # Save updated player state
                        save_player($actor);
                        
                        # Load a fresh copy of the player to ensure latest state
                        my $player_obj = load_player($actor->{name});
                        if ($player_obj && !$player_obj->{_death_handled}) {
                            $player_obj->{_death_handled} = 1;
                            save_player($player_obj);
                            handle_player_death($player_obj);
                        } else {
                            # Fallback to current object
                            $actor->{_death_handled} = 1;
                            save_player($actor);
                            handle_player_death($actor);
                        }
                    }
                    
                    cleanup_pvp_metafiles($actor_key, $opponent_key, $file, $creator_id) unless $is_ai;
                    return;
                }
                
                # Check for my turn - check both turn fields
                if ($meta->{turn} eq $actor_key || $meta->{current_turn} eq $actor_key) {
                    # CRITICAL: Make sure we haven't already processed this turn
                    if ($meta->{turn_index} == $last_processed_turn_index) {
                        # We already processed this turn, keep waiting for a new turn
                        select(undef, undef, undef, 0.5);
                        next;
                    }
                    
                    combat_debug("pvp_combat_metaloop: it's now our turn ($actor_key)");
                    last;
                }
                
                # Check for timeout - extended for PvP
                if (time() - $turn_wait_start > 45) {  # 45 second timeout for PvP
                    combat_debug("pvp_combat_metaloop: timeout waiting for turn");
                    writeline($config{'errorcolor'}."Combat timed out waiting for your turn.".$config{'themecolor'}, 1) unless $is_ai;
                    $meta->{status} = "aborted";
                    $meta->{abort_reason} = "turn_wait_timeout";
                    lock_store($meta, $file);
                    cleanup_pvp_metafiles($actor_key, $opponent_key, $file, $creator_id) unless $is_ai;
                    return;
                }
                
                # Show waiting message periodically
                if (time() - $last_notification > 10) {  # Every 10 seconds
                    my $current_turn_player = $meta->{current_turn} ? 
                        $meta->{players}{$meta->{current_turn}}{name} : 
                        ($meta->{turn} ? $meta->{players}{$meta->{turn}}{name} : "unknown player");
                    writeline($config{'systemcolor'}."Waiting for $current_turn_player\'s turn to complete...".$config{'themecolor'}, 1) unless $is_ai;
                    $last_notification = time();
                }
                
                # Short wait between checks
                select(undef, undef, undef, 0.25);
            }
        }
        
        # Track that we're processing this turn
        $last_processed_turn_index = $meta->{turn_index};
        
        # Verify it's still our turn - check both turn fields
        if ($meta->{turn} ne $actor_key && $meta->{current_turn} ne $actor_key) {
            combat_debug("pvp_combat_metaloop: not our turn anymore, turn=" . 
                        ($meta->{current_turn} || $meta->{turn} || "unknown"));
            
            # Retry several times with a short delay before giving up
            my $retry_count = 0;
            my $max_retries = 3;
            
            while ($retry_count < $max_retries) {
                # Small delay before checking again
                select(undef, undef, undef, 0.5);
                
                # Reload meta
                $meta = eval { lock_retrieve($file) };
                last unless $meta;
                
                # Check if it's our turn now - check both turn fields
                if ($meta->{turn} eq $actor_key || $meta->{current_turn} eq $actor_key) {
                    combat_debug("pvp_combat_metaloop: turn is now ours after retry");
                    last;
                }
                
                $retry_count++;
            }
            
            # If it's still not our turn, continue to next iteration
            if ($meta->{turn} ne $actor_key && $meta->{current_turn} ne $actor_key) {
                next;
            }
        }
        
        # Check if opponent changed rooms
        my $my_state = $meta->{players}{$actor_key};
        my $opp_state = $meta->{players}{$opponent_key};
        
        if (defined $my_state->{room} && defined $opp_state->{room} && $my_state->{room} != $opp_state->{room}) {
            combat_debug("pvp_combat_metaloop: room mismatch during combat ($my_state->{room} vs $opp_state->{room})");
            writeline($config{'errorcolor'}."Combat aborted: your opponent has left the area.".$config{'themecolor'}, 1) unless $is_ai;
            $meta->{status} = "aborted";
            $meta->{abort_reason} = "room_mismatch";
            lock_store($meta, $file);
            cleanup_pvp_metafiles($actor_key, $opponent_key, $file, $creator_id) unless $is_ai;
            return;
        }
        
        # --- Process turn ---
        my $action;
        
        if ($is_ai) {
            # AI-controlled turn
            $action = ai_combat_turn($actor, $meta, $actor_key, $opponent_key);
            
            # IMPORTANT: Save the meta file immediately after AI action
            eval { lock_store($meta, $file) };
            
            # Display AI messages immediately to all players
            if ($meta->{log} && @{$meta->{log}}) {
                foreach my $entry (@{$meta->{log}}) {
                    next unless $entry->{msg};
                    
                    # For each participant that hasn't seen this message
                    foreach my $pkey (keys %{$meta->{players}}) {
                        next if $entry->{displayed_to} && $entry->{displayed_to}{$pkey};
                        next if $meta->{players}{$pkey}{is_monster}; # Don't send to monsters
                        
                        # Send message to online players immediately
                        if ($pkey eq $actor_key && !$is_ai) {
                            # Display to current player immediately
                            my $color = $config{'datacolor'};
                            if ($entry->{msg} =~ /attacks|hits|damage|defeated/) {
                                $color = $config{'errorcolor'};
                            } elsif ($entry->{msg} =~ /misses|fails/) {
                                $color = $config{'systemcolor'};
                            }
                            writeline($color . $entry->{msg} . $config{'themecolor'}, 1);
                        } elsif (player_online($meta->{players}{$pkey}{name})) {
                            # Mark as displayed to this player
                            $entry->{displayed_to}{$pkey} = 1;
                        }
                    }
                }
                # Save the updated display tracking
                eval { lock_store($meta, $file) };
            }
        } else {
            # Player-controlled turn
            $action = player_combat_turn($actor, $meta, $actor_key, $opponent_key, $file);
            
            # Sync HP changes from combat state to player object
            $actor->{hp} = $meta->{players}{$actor_key}{hp};
            $actor->{max_hp} = $meta->{players}{$actor_key}{max_hp} // $actor->{max_hp};
            
            # Update global player if this is the current player
            if ($::player && $::player->{name} eq $actor->{name}) {
                $::player->{hp} = $meta->{players}{$actor_key}{hp};
                $::player->{max_hp} = $meta->{players}{$actor_key}{max_hp} // $::player->{max_hp};
            }
            
            # Save updated player state to persist HP changes
            save_player($actor);
        }
        
        # Add a flag to mark this turn as processed by this player
        $meta->{last_processed}{$actor_key} = $meta->{turn_index};
        
        # Check if opponent died after our action
        if ($meta->{players}{$opponent_key}{hp} <= 0 && !$meta->{victory_announced}) {
            # Mark opponent as dead to prevent duplicate death processing
            $meta->{players}{$opponent_key}{hp} = 0; # Ensure HP is exactly 0
            $meta->{players}{$opponent_key}{done} = 1;
            $meta->{players}{$opponent_key}{death_time} = time();
            $meta->{status} = "completed";
            $meta->{end_reason} = "victory";
            $meta->{winner} = $actor_key;
            $meta->{victory_announced} = 1; # Flag to prevent duplicate announcements
            
            # Save changes immediately
            eval { lock_store($meta, $file) };
            
            # Send victory notification to log
            if (!$is_ai) {
                combat_debug("pvp_combat_metaloop: Player $actor->{name} has defeated $meta->{players}{$opponent_key}{name}");
                
                # Make sure we see the victory message just once
                writeline($config{'systemcolor'}."You have defeated $meta->{players}{$opponent_key}{name} in combat!".$config{'themecolor'}, 1);
                
                # Award XP for victory
                if (!$actor->{is_monster}) {
                    # Use proper XP calculation function (follows documented rules)
                    my $xp_gain = calculate_xp_gain($actor, $opp_state);
                    
                    $actor->{experience} = ($actor->{experience} // 0) + $xp_gain;
                    
                    # Show XP message
                    writeline($config{'systemcolor'}."You gain $xp_gain experience!".$config{'themecolor'}, 1);
                    
                    # Check for level up
                    check_level_up($actor);
                    
                    # Save player state to persist XP gain
                    save_player($actor);
                }
            }
            
            # Process the defeated player's death
            if (!$opp_state->{is_monster} && !$opp_state->{_death_handled}) {
                my $defeated_player = load_player($opp_state->{name});
                if ($defeated_player && !$defeated_player->{_death_handled}) {
                    # Ensure the HP is set to 0 to trigger death handling
                    $defeated_player->{hp} = 0;
                    # Mark death as handled
                    $defeated_player->{_death_handled} = 1;
                    save_player($defeated_player);
                    
                    # Handle death immediately (this sends all the death messages)
                    handle_player_death($defeated_player);
                }
            }
            
            # Combat is completed, so we can exit the main loop
            cleanup_pvp_metafiles($actor_key, $opponent_key, $file, $creator_id) unless $is_ai;
            return;
        }
        
        # Check if action is one that should end our turn
        if ($action && ($action eq "attack" || $action eq "run" || $action eq "special" || 
                        $action eq "defend" || $action eq "flee_failed")) {
                
            # Sync HP changes from combat state to player object before ending turn
            if (!$is_ai) {
                $actor->{hp} = $meta->{players}{$actor_key}{hp};
                $actor->{max_hp} = $meta->{players}{$actor_key}{max_hp} // $actor->{max_hp};
                
                # Update global player if this is the current player
                if ($::player && $::player->{name} eq $actor->{name}) {
                    $::player->{hp} = $meta->{players}{$actor_key}{hp};
                    $::player->{max_hp} = $meta->{players}{$actor_key}{max_hp} // $::player->{max_hp};
                }
                
                # Save updated player state
                save_player($actor);
            }
                
            # Save meta file before advancing turn - in case advance_turn fails
            eval { lock_store($meta, $file) };
            if ($@) {
                combat_debug("pvp_combat_metaloop: Error saving meta before turn advance: $@");
            }
            
            # Only advance turn if combat is still active
            if ($meta->{status} eq "active") {
                # Make sure we haven't already advanced the turn
                if (!$meta->{turn_advanced_by} || $meta->{turn_advanced_by} ne $actor_key) {
                    advance_turn($meta, $file);
                    
                    # Mark that we advanced the turn
                    $meta->{turn_advanced_by} = $actor_key;
                    
                    # Ensure both turn fields are consistent
                    $meta->{current_turn} = $meta->{turn};
                    
                    # Update last_processed_turn_index to prevent double-processing
                    $last_processed_turn_index = $meta->{turn_index};
                    
                    # Save the updated meta file
                    eval { lock_store($meta, $file) };
                    
                    # Add delay to ensure turn transition is noticed
                    select(undef, undef, undef, 0.5);
                }
            }
            
            # Mark all messages as seen before ending turn
            if ($meta->{log} && @{$meta->{log}}) {
                foreach my $entry (@{$meta->{log}}) {
                    next unless $entry->{msg};
                    $entry->{displayed_to}{$actor_key} = 1;
                }
                eval { lock_store($meta, $file) };
            }
            
            # Continue with the main loop - DON'T break or return!
            next;
        }
        
        # Talk action doesn't end turn
        if ($action eq "talk") {
            # Save changes to meta file
            eval { lock_store($meta, $file) };
            if ($@) {
                combat_debug("pvp_combat_metaloop: Error saving meta after talk: $@");
            }
            
            # Short pause before continuing
            select(undef, undef, undef, 0.2);
            next;
        }
    }
    
    # If we exceeded turn limit, abort combat
    if ($turn_count >= $max_turns) {
        combat_debug("pvp_combat_metaloop: Exceeded maximum turns ($max_turns), aborting combat");
        $meta->{status} = "aborted";
        $meta->{abort_reason} = "turn_limit";
        lock_store($meta, $file);
        
        writeline($config{'errorcolor'}."Combat exceeded maximum turns and was aborted.".$config{'themecolor'}, 1) unless $is_ai;
    }
    
    # Clean up resources
    cleanup_pvp_metafiles($actor_key, $opponent_key, $file, $creator_id) unless $is_ai;
}

# ============================================================================
# GROUP COMBAT SYSTEM
# ============================================================================

sub group_combat_metaloop {
    my ($actor, %opts) = @_;
    my $is_ai = $opts{ai} // 0;
    my $actor_key = $actor->{is_monster} ? $actor->{id} : safe_name($actor->{name});
    my $pointer = $actor->{is_monster}
        ? monster_combat_pointer_path($actor->{id})
        : player_combat_pointer_path($actor->{name});
    
    combat_debug("group_combat_metaloop: actor=$actor_key, is_ai=$is_ai, pointer=$pointer");
    
    # Verify pointer exists
    unless (-e $pointer) {
        combat_debug("group_combat_metaloop: pointer file $pointer doesn't exist, exiting.");
        return;
    }

    # Read the combat pointer data
    my $pointer_data = read_combat_pointer($pointer);
    unless ($pointer_data && $pointer_data->{meta}) {
        combat_debug("group_combat_metaloop: pointer file $pointer missing or invalid, exiting.");
        return;
    }
    
    my $file = $pointer_data->{meta};
    my $creator_id = $pointer_data->{creator} // "$$";
    combat_debug("group_combat_metaloop: using meta file $file");

    # Verify meta file exists
    unless ($file && -e $file) {
        combat_debug("group_combat_metaloop: meta file $file doesn't exist, exiting.");
        unlink $pointer if -e $pointer;
        return;
    }

    # Load meta file
    my $meta = eval { lock_retrieve($file) };
    unless ($meta && $meta->{players}) {
        combat_debug("group_combat_metaloop: meta file $file missing or unreadable, exiting.");
        return;
    }
    
    # Set ourselves as ready for combat
    $meta->{players}{$actor_key}{ready} = 1;
    $meta->{players}{$actor_key}{ready_time} = time();
    
    # Check if we're the last one to join and need to start combat
    if (($meta->{status} eq "initiated" || $meta->{status} eq "initializing") && 
        all_participants_ready($meta)) {
        
        # Initialize combat by rolling initiative and setting turn order
        initialize_group_combat($meta);
        
        # Save updated meta
        lock_store($meta, $file);
        
        # Show combat starting message
        unless ($is_ai) {
            writeline($config{'systemcolor'}."Combat begins now!".$config{'themecolor'}, 1);
        }
    } else {
        # Just save our ready status
        lock_store($meta, $file);
    }
    
    # Wait for status to become active
    my $wait_start = time();
    my $active_notified = 0;
    
    while (1) {
        # Reload meta to check status
        $meta = eval { lock_retrieve($file) };
        
        # Exit if meta file disappeared
        unless ($meta) {
            combat_debug("group_combat_metaloop: meta file disappeared during wait");
            return;
        }
        
        # If status is active, we can proceed
        if ($meta->{status} eq "active") {
            # Only show initiative message once
            if (!$active_notified && !$is_ai) {
                $active_notified = 1;
                # Ensure a small pause to let the messages appear in the right order
                select(undef, undef, undef, 0.5);
                combat_debug("group_combat_metaloop: combat is now active");
            }
            last;
        }
        
        # Check if we need to initialize combat
        if (($meta->{status} eq "initializing" || $meta->{status} eq "initiated") && 
            all_participants_ready($meta)) {
            
            # Initialize combat by rolling initiative and setting turn order
            initialize_group_combat($meta);
            
            # Save updated meta
            lock_store($meta, $file);
        }
        
        # Check for timeout
        if (time() - $wait_start > 20) {  # 20 second timeout
            combat_debug("group_combat_metaloop: timeout waiting for active status");
            writeline($config{'errorcolor'}."Combat initialization timed out.".$config{'themecolor'}, 1) unless $is_ai;
            cleanup_combat_files($actor, $file, $creator_id) unless $is_ai;
            return;
        }
        
        # Short wait
        select(undef, undef, undef, 0.1);
    }
    
    # Display any pending messages before waiting for turn
    if ($meta->{log} && @{$meta->{log}}) {
        foreach my $entry (@{$meta->{log}}) {
            next unless $entry->{msg};
            next if $entry->{displayed_to} && $entry->{displayed_to}{$actor_key};
            writeline($config{'datacolor'}.$entry->{msg}.$config{'themecolor'}, 1) unless $is_ai;
            $entry->{displayed_to}{$actor_key} = 1;
        }
        # Save that we've seen these messages
        lock_store($meta, $file);
    }
    
    # --- Main turn-based loop ---
    my $turn_count = 0;
    my $max_turns = 200; # More turns allowed for group combat
    my $my_turns_taken = 0;  # Track only this participant's turns
    
    while ($turn_count < $max_turns) {
        # Wait for our turn if needed
        if ($meta->{current_turn} ne $actor_key) {
            if (!wait_for_turn($meta, $file, $actor_key, $is_ai)) {
                # Combat ended or error occurred during wait
                cleanup_combat_files($actor, $file, $creator_id) unless $is_ai;
                return;
            }
        }
        
        # Increment loop iteration counter (for safety)
        $turn_count++;
        
        # Reload meta file at start of each turn
        $meta = eval { lock_retrieve($file) };
        unless ($meta) {
            combat_debug("group_combat_metaloop: meta file missing in main loop, exiting.");
            cleanup_combat_files($actor, $file, $creator_id) unless $is_ai;
            return;
        }
        
        # Check if combat ended
        if ($meta->{status} ne "active") {
            combat_debug("group_combat_metaloop: combat has ended, status=$meta->{status}");
            cleanup_combat_files($actor, $file, $creator_id) unless $is_ai;
            return;
        }
        
        # Verify it's still our turn
        if ($meta->{current_turn} ne $actor_key) {
            combat_debug("group_combat_metaloop: not our turn anymore, turn=$meta->{current_turn}");
            next;
        }
        
        # Check if actor has died
        if ($meta->{players}{$actor_key}{hp} <= 0) {
            combat_debug("group_combat_metaloop: actor is dead, skipping turn");
            advance_group_turn($meta, $file);
            next;
        }
        
        # --- Process turn ---
        if ($is_ai) {
            # AI-controlled turn
            process_ai_group_turn($actor, $meta, $file);
        } else {
            # Player-controlled turn
            process_player_group_turn($actor, $meta, $file);
        }
        
        # Advance to next turn
        advance_group_turn($meta, $file);
        
        # Short delay to allow for message display
        select(undef, undef, undef, 0.2) unless $is_ai;
    }
    
    # Safety cleanup if we somehow exceeded turn limit
    if ($turn_count >= $max_turns) {
        writeline($config{'errorcolor'}."Combat exceeded maximum allowed turns and was terminated.".$config{'themecolor'}, 1) unless $is_ai;
        $meta->{status} = "aborted";
        $meta->{abort_reason} = "turn_limit_exceeded";
        lock_store($meta, $file);
        cleanup_combat_files($actor, $file, $creator_id) unless $is_ai;
    }
}

# Check if all participants are ready
sub all_participants_ready {
    my ($meta) = @_;
    
    foreach my $key (keys %{$meta->{players}}) {
        # Skip monsters, they're always considered ready
        next if $meta->{players}{$key}{is_monster};
        
        # Skip dead players
        next if $meta->{players}{$key}{hp} <= 0;
        
        # If any player isn't ready, return false
        return 0 unless $meta->{players}{$key}{ready};
    }
    
    return 1;
}

# Initialize group combat by rolling initiative and setting turn order
sub initialize_group_combat {
    my ($meta) = @_;
    
    # Roll initiative for all participants
    my @ordered_participants;
    
    foreach my $key (keys %{$meta->{players}}) {
        my $p = $meta->{players}{$key};
        
        # Skip dead participants
        next if $p->{hp} <= 0;
        
        my $dex = $p->{stats}{dex} // 10;
        my $init_mod = int(($dex - 10) / 2);
        my $init_roll = int(rand(20)) + 1 + $init_mod;
        
        $meta->{initiative}{$key} = $init_roll;
        
        push @ordered_participants, {
            key => $key,
            name => $p->{name},
            initiative => $init_roll,
            is_monster => $p->{is_monster} // 0,
        };
    }
    
    # Sort by initiative (highest to lowest)
    @ordered_participants = sort { $b->{initiative} <=> $a->{initiative} } @ordered_participants;
    
    # Set turn order
    $meta->{turn_order} = [ map { $_->{key} } @ordered_participants ];
    $meta->{turn_index} = 0;
    $meta->{current_turn} = $meta->{turn_order}[0];
    $meta->{status} = "active";
    
    # Create initiative message for log
    my $init_msg = "Initiative order: ";
    $init_msg .= join(", ", map { "$_->{name} ($_->{initiative})" } @ordered_participants);
    
    # Add to combat log
    push @{$meta->{log}}, { 
        actor => "system", 
        msg => $init_msg,
        time => time(),
        displayed_to => {}
    };
    
    # Add turn start message
    my $first_name = $meta->{players}{$meta->{current_turn}}{name};
    push @{$meta->{log}}, { 
        actor => "system", 
        msg => "It's $first_name\'s turn!",
        time => time(),
        displayed_to => {}
    };
    
    combat_debug("initialize_group_combat: Combat now active, turn order set");
}

sub player_ready_flag_path {
    my ($player_name) = @_;
    my $player_hash = safe_name($player_name);
    return "$config{transient}/player_${player_hash}.ready";
}

# Wait for actor's turn in group combat
sub wait_for_turn {
    my ($meta, $file, $actor_key, $is_ai) = @_;
    
    combat_debug("wait_for_turn: waiting for turn, currently " . 
                ($meta->{current_turn} || $meta->{turn} || "unknown"));
    my $turn_wait_start = time();
    my $last_notification = 0;
    
    while (1) {
        # Reload meta
        $meta = eval { lock_retrieve($file) };
        
        # Exit if meta file disappeared
        unless ($meta) {
            combat_debug("wait_for_turn: meta file disappeared during turn wait");
            return 0;
        }
        
        # Check if combat ended
        if ($meta->{status} ne "active") {
            combat_debug("wait_for_turn: combat ended while waiting for turn");
            return 0;
        }
        
        # Check if actor died
        if ($meta->{players}{$actor_key}{hp} <= 0) {
            combat_debug("wait_for_turn: actor died while waiting for turn");
            if (!$is_ai) {
                # handle_player_death prints all the death messages
                my $player_obj = load_player($meta->{players}{$actor_key}{name});
                handle_player_death($player_obj) if $player_obj && !$player_obj->{is_monster};
            }
            return 0;
        }
        
        # Check both turn fields - either can indicate it's our turn
        if (($meta->{current_turn} && $meta->{current_turn} eq $actor_key) || 
            ($meta->{turn} && $meta->{turn} eq $actor_key)) {
            combat_debug("wait_for_turn: it's now our turn ($actor_key)");
            return 1;
        }
        
        # CRITICAL: Process AI turns while waiting (if we're the player waiting)
        my $current_turn_key = $meta->{current_turn} || $meta->{turn};
        if ($current_turn_key && !$is_ai) {
            my $current_player = $meta->{players}{$current_turn_key};
            
            # If it's a monster's turn, process it
            if ($current_player && $current_player->{is_monster}) {
                combat_debug("wait_for_turn: Processing AI turn for $current_player->{name}");
                
                # Create a temporary monster object for AI processing
                my $monster = {
                    id => $current_turn_key,
                    name => $current_player->{name},
                    is_monster => 1,
                    hp => $current_player->{hp},
                    max_hp => $current_player->{max_hp},
                    level => $current_player->{level},
                    room => $current_player->{room},
                    stats => $current_player->{stats} // { str => 10, dex => 10, con => 10, int => 10, wis => 10, cha => 10 },
                };
                
                # Process the AI turn
                process_ai_group_turn($monster, $meta, $file);
                
                # Display AI messages to player
                if ($meta->{log} && @{$meta->{log}}) {
                    foreach my $entry (@{$meta->{log}}) {
                        next unless $entry->{msg};
                        next if $entry->{displayed_to} && $entry->{displayed_to}{$actor_key};
                        
                        # Color the message appropriately
                        my $color = $config{'datacolor'};
                        if ($entry->{msg} =~ /attacks|strikes|hits|damage|defeated|critical/i) {
                            $color = $config{'errorcolor'};
                        } elsif ($entry->{msg} =~ /misses|fails|dodges|parries|guards|blocks/i) {
                            $color = $config{'systemcolor'};
                        } elsif ($entry->{msg} =~ /It's.*turn!/i) {
                            $color = $config{'systemcolor'};
                            writeline("", 1);  # Blank line before turn announcement
                        }
                        
                        writeline($color . $entry->{msg} . $config{'themecolor'}, 1);
                        $entry->{displayed_to}{$actor_key} = 1;
                    }
                }
                
                # Advance to next turn
                advance_group_turn($meta, $file);
                
                # Reload meta after advancing
                $meta = eval { lock_retrieve($file) };
                
                # Reset timeout since things are happening
                $turn_wait_start = time();
                
                # Small delay for readability
                select(undef, undef, undef, 0.3);
                next;
            }
        }
        
        # Check for timeout - increased to 45 seconds for PvP
        if (time() - $turn_wait_start > 45) {  # 45 second timeout
            combat_debug("wait_for_turn: timeout waiting for turn");
            writeline($config{'errorcolor'}."Combat timed out waiting for your turn.".$config{'themecolor'}, 1) unless $is_ai;
            
            # IMPORTANT: Mark status as aborted properly
            $meta->{status} = "aborted";
            $meta->{abort_reason} = "turn_wait_timeout";
            eval { lock_store($meta, $file) };
            return 0;
        }
        
        # Display any new messages while waiting
        if ($meta->{log} && @{$meta->{log}}) {
            foreach my $entry (@{$meta->{log}}) {
                next unless $entry->{msg};
                next if $entry->{displayed_to} && $entry->{displayed_to}{$actor_key};
                writeline($config{'datacolor'}.$entry->{msg}.$config{'themecolor'}, 1) unless $is_ai;
                $entry->{displayed_to}{$actor_key} = 1;
            }
            # Save that we've seen these messages
            eval { lock_store($meta, $file) };
        }
        
        # Show a periodic waiting message to indicate the system is still active
        if (time() - $last_notification > 10) {  # Every 10 seconds
            my $current_turn_player = $meta->{current_turn} ? $meta->{players}{$meta->{current_turn}}{name} : 
                                     ($meta->{turn} ? $meta->{players}{$meta->{turn}}{name} : "unknown player");
            writeline($config{'systemcolor'}."Waiting for $current_turn_player\'s turn to complete...".$config{'themecolor'}, 1) unless $is_ai;
            $last_notification = time();
        }
        
        # Short wait between checks - increased slightly for network latency
        select(undef, undef, undef, 0.25);
    }
}

# Advance to the next turn in group combat
sub advance_group_turn {
    my ($meta, $file) = @_;
    
    # Increment turn index
    $meta->{turn_index}++;
    
    # Wrap around if we've gone through all participants
    if ($meta->{turn_index} >= scalar(@{$meta->{turn_order}})) {
        $meta->{turn_index} = 0;
        $meta->{round_number} = ($meta->{round_number} // 0) + 1;
        
        # Add round transition message
        push @{$meta->{log}}, { 
            actor => "system", 
            msg => "Round " . ($meta->{round_number}) . " begins!",
            time => time(),
            displayed_to => {}
        };
    }
    
    # Set current turn to the next participant
    my $next_turn = $meta->{turn_order}[$meta->{turn_index}];
    
    # If next participant is dead, find the next living one
    my $checked = 0;
    while ($meta->{players}{$next_turn}{hp} <= 0 || $meta->{players}{$next_turn}{fled}) {
        $meta->{turn_index}++;
        
        # Wrap around again if needed
        if ($meta->{turn_index} >= scalar(@{$meta->{turn_order}})) {
            $meta->{turn_index} = 0;
            $meta->{round_number} = ($meta->{round_number} // 0) + 1;
            
            # Add round transition message
            push @{$meta->{log}}, { 
                actor => "system", 
                msg => "Round " . ($meta->{round_number}) . " begins!",
                time => time(),
                displayed_to => {}
            };
        }
        
        $next_turn = $meta->{turn_order}[$meta->{turn_index}];
        
        # Emergency exit if we've checked all participants and they're all dead
        $checked++;
        if ($checked >= scalar(@{$meta->{turn_order}})) {
            $meta->{status} = "completed";
            $meta->{end_reason} = "all_dead";
            lock_store($meta, $file);
            return;
        }
    }
    
    $meta->{current_turn} = $next_turn;
    
    # Add turn start message
    my $next_name = $meta->{players}{$next_turn}{name};
    push @{$meta->{log}}, { 
        actor => "system", 
        msg => "It's $next_name\'s turn!",
        time => time(),
        displayed_to => {}
    };
    
    # Check for victory conditions
    check_group_combat_victory($meta);
    
    # Save updated meta
    lock_store($meta, $file);
}

# Check if combat has ended due to victory or defeat
sub check_group_combat_victory {
    my ($meta) = @_;
    
    # Skip check if combat is already finished
    return if $meta->{status} ne "active";
    
    # Track living participants by team
    my %living_teams;
    
    foreach my $key (keys %{$meta->{players}}) {
        my $p = $meta->{players}{$key};
        
        # Skip dead or fled participants
        next if $p->{hp} <= 0 || $p->{fled};
        
        # Get team name
        my $team = $p->{team} // $key;
        
        # Count living members by team
        $living_teams{$team} = ($living_teams{$team} // 0) + 1;
    }
    
    # If no teams are left, it's a draw
    if (scalar(keys %living_teams) == 0) {
        $meta->{status} = "completed";
        $meta->{end_reason} = "all_dead";
        
        push @{$meta->{log}}, { 
            actor => "system", 
            msg => "Combat ends with no survivors!",
            time => time(),
            displayed_to => {}
        };
        return;
    }
    
    # In free-for-all mode, victory requires only 1 player left
    if ($meta->{free_for_all}) {
        # If more than one team/player remains, combat continues
        if (scalar(keys %living_teams) > 1) {
            return;
        }
        
        # Only one team/player left, they win
        my ($winner_team) = keys %living_teams;
        $meta->{status} = "completed";
        $meta->{end_reason} = "victory";
        $meta->{winner} = $winner_team;
        
        # Find winning player name
        my $winner_name = $winner_team;
        foreach my $key (keys %{$meta->{players}}) {
            my $p = $meta->{players}{$key};
            if (($p->{team} // $key) eq $winner_team && $p->{hp} > 0) {
                $winner_name = $p->{name};
                last;
            }
        }
        
        push @{$meta->{log}}, { 
            actor => "system", 
            msg => "$winner_name is the last one standing and wins the battle!",
            time => time(),
            displayed_to => {}
        };
        return;
    }
    
    # In normal/party mode, we need at least one team/party left and all enemies defeated
    
    # If only one team remains, they win
    if (scalar(keys %living_teams) == 1) {
        my ($winner_team) = keys %living_teams;
        $meta->{status} = "completed";
        $meta->{end_reason} = "victory";
        $meta->{winner} = $winner_team;
        
        # Format appropriate victory message
        my $victory_msg;
        if ($winner_team =~ /^monsters/) {
            $victory_msg = "The monsters are victorious!";
        } else {
            $victory_msg = "Team $winner_team is victorious!";
        }
        
        push @{$meta->{log}}, { 
            actor => "system", 
            msg => $victory_msg,
            time => time(),
            displayed_to => {}
        };
        return;
    }
    
    # Check if all remaining teams are allied
    my @remaining_teams = keys %living_teams;
    my $all_allied = 1;
    
    for (my $i = 0; $i < @remaining_teams; $i++) {
        for (my $j = $i + 1; $j < @remaining_teams; $j++) {
            my $team1 = $remaining_teams[$i];
            my $team2 = $remaining_teams[$j];
            
            # Find a member of each team
            my $member1;
            my $member2;
            
            foreach my $key (keys %{$meta->{players}}) {
                my $p = $meta->{players}{$key};
                next if $p->{hp} <= 0 || $p->{fled};
                
                if (($p->{team} // $key) eq $team1) {
                    $member1 = $key;
                } elsif (($p->{team} // $key) eq $team2) {
                    $member2 = $key;
                }
                
                last if $member1 && $member2;
            }
            
            # If either team has no alliance with the other, they're not all allied
            if (!($meta->{alliances}{$member1}{$member2} && $meta->{alliances}{$member2}{$member1})) {
                $all_allied = 0;
                last;
            }
        }
        
        last unless $all_allied;
    }
    
    # If all remaining teams are allied, they win together
    if ($all_allied && @remaining_teams > 1) {
        $meta->{status} = "completed";
        $meta->{end_reason} = "allied_victory";
        $meta->{winners} = \@remaining_teams;
        
        my $team_names = join(", ", @remaining_teams);
        push @{$meta->{log}}, { 
            actor => "system", 
            msg => "Allied teams ($team_names) are victorious!",
            time => time(),
            displayed_to => {}
        };
    }
}

# Process AI turn in group combat
sub process_ai_group_turn {
    my ($actor, $meta, $file) = @_;
    my $actor_key = $actor->{is_monster} ? $actor->{id} : safe_name($actor->{name});
    
    # Get actor state from meta
    my $actor_state = $meta->{players}{$actor_key};
    
    # Select an action (basic AI)
    my $action = "attack";
    
    # If low health, consider fleeing
    if ($actor_state->{hp} < ($actor_state->{max_hp} * 0.25)) {
        if (rand() < 0.3) { # 30% chance to try to flee when low on health
            $action = "flee";
        }
    }
    
    # Process the action
    if ($action eq "attack") {
        # Find a valid target
        my $target_key = select_ai_target($actor, $meta);
        
        # If no valid target, just end turn
        unless ($target_key) {
            push @{$meta->{log}}, { 
                actor => $actor_state->{name}, 
                msg => "$actor_state->{name} looks for a target but finds none.",
                time => time(),
                displayed_to => {}
            };
            return;
        }
        
        # Perform attack
        perform_group_attack($actor_key, $target_key, $meta);
    }
    elsif ($action eq "flee") {
        # Try to flee from combat
        my $dex = $actor_state->{stats}{dex} // 10;
        my $dex_mod = int(($dex - 10) / 2);
        my $flee_roll = int(rand(20)) + 1 + $dex_mod;
        
        if ($flee_roll >= 15) { # DC 15 to flee
            # Successful flee
            $actor_state->{fled} = 1;
            push @{$meta->{log}}, { 
                actor => $actor_state->{name}, 
                msg => "$actor_state->{name} flees from combat!",
                time => time(),
                displayed_to => {}
            };
        } else {
            # Failed flee attempt
            push @{$meta->{log}}, { 
                actor => $actor_state->{name}, 
                msg => "$actor_state->{name} tries to flee but fails!",
                time => time(),
                displayed_to => {}
            };
        }
    }
    
    # Save updated meta
    lock_store($meta, $file);
}

# Select a valid target for AI attack
sub select_ai_target {
    my ($actor, $meta) = @_;
    my $actor_key = $actor->{is_monster} ? $actor->{id} : safe_name($actor->{name});
    my $actor_state = $meta->{players}{$actor_key};
    my $actor_team = $actor_state->{team} // $actor_key;
    
    # Find all valid targets (living, not on same team, not allied)
    my @valid_targets;
    
    foreach my $key (keys %{$meta->{players}}) {
        my $p = $meta->{players}{$key};
        
        # Skip self
        next if $key eq $actor_key;
        
        # Skip dead or fled participants
        next if $p->{hp} <= 0 || $p->{fled};
        
        # Skip allies
        my $target_team = $p->{team} // $key;
        next if $target_team eq $actor_team;
        next if $meta->{alliances}{$actor_key}{$key};
        
        push @valid_targets, $key;
    }
    
    # Return random target, or undef if none available
    return @valid_targets ? $valid_targets[int(rand(@valid_targets))] : undef;
}

# Process player turn in group combat
sub process_player_group_turn {
    my ($actor, $meta, $file) = @_;
    my $actor_key = $actor->{is_monster} ? $actor->{id} : safe_name($actor->{name});
    
    # Display combat status
    display_group_combat_status($actor, $meta);
    
    # Get action from player
    my ($action, $target_key) = get_player_group_combat_action($actor, $meta);
    
    # Process the action
    if ($action eq "attack") {
        # Perform attack
        perform_group_attack($actor_key, $target_key, $meta);
    }
    elsif ($action eq "defend") {
        # Set defensive stance for next round
        $meta->{players}{$actor_key}{defending} = 1;
        
        # Add to log
        push @{$meta->{log}}, { 
            actor => $actor->{name}, 
            msg => "$actor->{name} takes a defensive stance.",
            time => time(),
            displayed_to => {}
        };
        
        # Show message to player
        writeline($config{'systemcolor'}."You take a defensive stance, reducing incoming damage.".$config{'themecolor'}, 1);
    }
    elsif ($action eq "flee") {
        # Try to flee from combat
        my $dex = $actor->{stats}{dex} // 10;
        my $dex_mod = int(($dex - 10) / 2);
        my $flee_roll = int(rand(20)) + 1 + $dex_mod;
        
        if ($flee_roll >= 15) { # DC 15 to flee
            # Successful flee
            $meta->{players}{$actor_key}{fled} = 1;
            
            # Add to log
            push @{$meta->{log}}, { 
                actor => $actor->{name}, 
                msg => "$actor->{name} successfully flees from combat!",
                time => time(),
                displayed_to => {}
            };
            
            # Show message to player
            writeline($config{'systemcolor'}."You successfully flee from combat!".$config{'themecolor'}, 1);
        } else {
            # Failed flee attempt
            push @{$meta->{log}}, { 
                actor => $actor->{name}, 
                msg => "$actor->{name} tries to flee but fails!",
                time => time(),
                displayed_to => {}
            };
            
            # Show message to player
            writeline($config{'errorcolor'}."You try to flee but fail!".$config{'themecolor'}, 1);
        }
    }
    elsif ($action eq "betray") {
        # Attempt to betray/switch allegiance
        process_betrayal($actor, $meta, $target_key);
    }
    elsif ($action eq "alliance") {
        # Attempt to form an alliance
        process_alliance_request($actor, $meta, $target_key);
    }
    
    # Save updated meta
    lock_store($meta, $file);
}

# Display group combat status to player
sub display_group_combat_status {
    my ($actor, $meta) = @_;
    my $actor_key = $actor->{is_monster} ? $actor->{id} : safe_name($actor->{name});
    
    writeline($config{'systemcolor'}."--- Combat Status ---".$config{'themecolor'}, 1);
    writeline($config{'systemcolor'}."It's your turn!".$config{'themecolor'}, 1);
    
    # Show round number if applicable
    if ($meta->{round_number}) {
        writeline($config{'systemcolor'}."Round: $meta->{round_number}".$config{'themecolor'}, 1);
    }
    
    # Display participants by team
    my %teams;
    
    foreach my $key (keys %{$meta->{players}}) {
        my $p = $meta->{players}{$key};
        
        # Skip dead or fled participants
        next if $p->{hp} <= 0 || $p->{fled};
        
        # Group by team
        my $team = $p->{team} // $key;
        $teams{$team} //= [];
        push @{$teams{$team}}, {
            key => $key,
            name => $p->{name},
            hp => $p->{hp},
            max_hp => $p->{max_hp},
            is_monster => $p->{is_monster} // 0,
            is_self => ($key eq $actor_key),
            is_ally => $meta->{alliances}{$actor_key}{$key},
        };
    }
    
    # Display teams
    foreach my $team (sort keys %teams) {
        my $is_actor_team = 0;
        my $is_allied_team = 0;
        
        # Check if this is actor's team or allied
        foreach my $member (@{$teams{$team}}) {
            if ($member->{is_self}) {
                $is_actor_team = 1;
                last;
            }
            if ($member->{is_ally}) {
                $is_allied_team = 1;
            }
        }
        
        # Determine team display color
        my $team_color = $is_actor_team ? $config{'usercolor'} : 
                         $is_allied_team ? $config{'systemcolor'} : 
                         $config{'errorcolor'};
        
        # Display team header
        writeline($team_color."Team: $team".$config{'themecolor'}, 1);
        
        # Display team members
        foreach my $member (sort { $a->{name} cmp $b->{name} } @{$teams{$team}}) {
            my $status_color = $member->{is_self} ? $config{'usercolor'} : 
                               $member->{is_ally} ? $config{'systemcolor'} : 
                               $config{'datacolor'};
            
            my $health_pct = int(($member->{hp} / $member->{max_hp}) * 100);
            my $health_status = $health_pct > 75 ? "healthy" : 
                               $health_pct > 50 ? "wounded" : 
                               $health_pct > 25 ? "badly hurt" : "critical";
            
            my $member_desc = sprintf("%s: %d/%d HP (%s)", 
                $member->{name}, 
                $member->{hp}, 
                $member->{max_hp},
                $health_status
            );
            
            writeline($status_color.$member_desc.$config{'themecolor'}, 1);
        }
    }
}

# Get player's action in group combat
sub get_player_group_combat_action {
    my ($actor, $meta) = @_;
    my $actor_key = $actor->{is_monster} ? $actor->{id} : safe_name($actor->{name});
    my $actor_state = $meta->{players}{$actor_key};
    
    # Define action options
    my @action_options = (
        { key => "A", name => "Attack", desc => "Attack an enemy" },
        { key => "D", name => "Defend", desc => "Take a defensive stance" },
        { key => "F", name => "Flee", desc => "Try to escape combat" },
    );
    
    # Add betrayal option if applicable
    if ($actor_state->{can_betray} || 
        ($actor_state->{alignment} && $actor_state->{alignment} =~ /chaotic\s+evil/i)) {
        push @action_options, { key => "B", name => "Betray", desc => "Switch sides and attack former allies" };
    }
    
    # Add alliance option in FFA or mercenary mode
    if ($meta->{free_for_all} || $meta->{mercenary}) {
        push @action_options, { key => "L", name => "Alliance", desc => "Form a temporary alliance with another combatant" };
    }
    
    # Display action menu
    writeline($config{'promptcolor'}."Combat Actions:".$config{'themecolor'}, 1);
    foreach my $opt (@action_options) {
        writeline(sprintf("%s[%s]%s %s - %s", 
            $config{'promptcolor'}, $opt->{key}, $config{'themecolor'},
            $opt->{name}, $opt->{desc}), 1);
    }
    
    # Get player choice - use readline to avoid mud_key's alarm handler interfering
    writeline($config{'promptcolor'}."Choose action: ".$config{'themecolor'}, 0);
    my $action_input = readline(0);  # No timeout
    $action_input =~ s/^\s+|\s+$//g if defined $action_input;
    my $action_key = uc(substr($action_input // "A", 0, 1));
    
    # Map key to action
    my $action;
    if ($action_key eq "D") {
        $action = "defend";
    } elsif ($action_key eq "F") {
        $action = "flee";
    } elsif ($action_key eq "B" && ($actor_state->{can_betray} || 
             ($actor_state->{alignment} && $actor_state->{alignment} =~ /chaotic\s+evil/i))) {
        $action = "betray";
    } elsif ($action_key eq "L" && ($meta->{free_for_all} || $meta->{mercenary})) {
        $action = "alliance";
    } else {
        $action = "attack";  # Default
    }
    
    # For actions requiring a target, get target selection
    my $target_key;
    if ($action eq "attack" || $action eq "betray" || $action eq "alliance") {
        $target_key = select_combat_target($actor, $meta, $action);
    }
    
    return ($action, $target_key);
}

# Select a target for combat action
sub select_combat_target {
    my ($actor, $meta, $action) = @_;
    my $actor_key = $actor->{is_monster} ? $actor->{id} : safe_name($actor->{name});
    my $actor_state = $meta->{players}{$actor_key};
    my $actor_team = $actor_state->{team} // $actor_key;
    
    # Get valid targets based on action type
    my @valid_targets;
    
    if ($action eq "attack") {
        # Valid targets are living, not on same team, not allied
        foreach my $key (keys %{$meta->{players}}) {
            my $p = $meta->{players}{$key};
            
            # Skip self
            next if $key eq $actor_key;
            
            # Skip dead or fled participants
            next if $p->{hp} <= 0 || $p->{fled};
            
            # Skip allies
            my $target_team = $p->{team} // $key;
            next if $target_team eq $actor_team;
            next if $meta->{alliances}{$actor_key}{$key};
            
            push @valid_targets, {
                key => $key,
                name => $p->{name},
                hp => $p->{hp},
                max_hp => $p->{max_hp},
                is_monster => $p->{is_monster} // 0,
            };
        }
    }
    elsif ($action eq "betray") {
        # Valid targets are living allies
        foreach my $key (keys %{$meta->{players}}) {
            my $p = $meta->{players}{$key};
            
            # Skip self
            next if $key eq $actor_key;
            
            # Skip dead or fled participants
            next if $p->{hp} <= 0 || $p->{fled};
            
            # Only include allies
            my $target_team = $p->{team} // $key;
            if ($target_team eq $actor_team || $meta->{alliances}{$actor_key}{$key}) {
                push @valid_targets, {
                    key => $key,
                    name => $p->{name},
                    hp => $p->{hp},
                    max_hp => $p->{max_hp},
                    is_monster => $p->{is_monster} // 0,
                };
            }
        }
    }
    elsif ($action eq "alliance") {
        # Valid targets are living non-allies
        foreach my $key (keys %{$meta->{players}}) {
            my $p = $meta->{players}{$key};
            
            # Skip self
            next if $key eq $actor_key;
            
            # Skip dead or fled participants
            next if $p->{hp} <= 0 || $p->{fled};
            
            # Skip existing allies
            my $target_team = $p->{team} // $key;
            next if $target_team eq $actor_team;
            next if $meta->{alliances}{$actor_key}{$key};
            
            push @valid_targets, {
                key => $key,
                name => $p->{name},
                hp => $p->{hp},
                max_hp => $p->{max_hp},
                is_monster => $p->{is_monster} // 0,
            };
        }
    }
    
    # If no valid targets, return undef
    unless (@valid_targets) {
        writeline($config{'errorcolor'}."No valid targets available!".$config{'themecolor'}, 1);
        return undef;
    }
    
    # Sort targets by name
    @valid_targets = sort { $a->{name} cmp $b->{name} } @valid_targets;
    
    # Display target selection menu
    writeline($config{'promptcolor'}."Choose your target:".$config{'themecolor'}, 1);
    for (my $i = 0; $i < @valid_targets; $i++) {
        my $t = $valid_targets[$i];
        writeline(sprintf("%d. %s (%d/%d HP)", 
            $i+1, $t->{name}, $t->{hp}, $t->{max_hp}), 1);
    }
    
    # Get player choice - use readline for multi-digit input
    writeline($config{'promptcolor'}."Target #: ".$config{'themecolor'}, 0);
    my $choice = readline(0);  # No timeout, wait for input
    $choice =~ s/^\s+|\s+$//g if defined $choice;  # Trim whitespace
    $choice = $choice =~ /^\d+$/ ? int($choice) : 1;
    $choice = 1 if $choice < 1 || $choice > @valid_targets;
    
    # Return selected target key
    return $valid_targets[$choice-1]{key};
}

# Perform attack in group combat
sub perform_group_attack {
    my ($attacker_key, $target_key, $meta) = @_;
    
    # Get attacker and target states
    my $attacker_state = $meta->{players}{$attacker_key};
    my $target_state = $meta->{players}{$target_key};
    
    # Safety check - ensure both states exist
    unless ($attacker_state && ref($attacker_state) eq 'HASH' && 
            $target_state && ref($target_state) eq 'HASH') {
        combat_debug("[ERROR] perform_group_attack: Invalid attacker or target states");
        return 0;
    }
    
    # Calculate attack
    my ($num_dice, $dice_type, $flat_bonus) = (1, 6, 0);
    
    # Determine damage based on attacker type
    if ($attacker_state->{is_monster}) {
        # Monster damage
        my $name = lc($attacker_state->{name} // '');
        $name =~ s/\s+/_/g;
        if (exists $MONSTER_DAMAGE_DICE{$name}) {
            ($num_dice, $dice_type, $flat_bonus) = @{$MONSTER_DAMAGE_DICE{$name}};
        } else {
            # Fallback: scale by level
            my $level = $attacker_state->{level} // 1;
            $num_dice = 1 + int($level/5);
            $dice_type = 6;
            $flat_bonus = int($level/2);
        }
    } else {
        # Player damage
        if ($attacker_state->{equipped} && $attacker_state->{equipped}{weapon}) {
            my $inv = $attacker_state->{equipped}{weapon};
            my $treas;
            if ($inv->{idx}) {
                $treas = read_treasure_record($inv->{idx});
            }
            
            if ($treas) {
                my $wname = lc($treas->{name} // '');
                
                # Weapon-based damage
                if ($wname =~ /longsword|broadsword|bastard|greatsword/) {
                    $num_dice = 1;
                    $dice_type = 8;
                } elsif ($wname =~ /shortsword|scimitar|cutlass|rapier/) {
                    $num_dice = 1;
                    $dice_type = 6;
                } elsif ($wname =~ /mace|club|flail|morningstar/) {
                    $num_dice = 1;
                    $dice_type = 6;
                } elsif ($wname =~ /dagger|knife|stiletto/) {
                    $num_dice = 1;
                    $dice_type = 4;
                } elsif ($wname =~ /halberd|glaive|polearm/) {
                    $num_dice = 1;
                    $dice_type = 10;
                } elsif ($wname =~ /battleaxe|greataxe/) {
                    $num_dice = 1;
                    $dice_type = 8;
                } elsif ($wname =~ /handaxe|hatchet/) {
                    $num_dice = 1;
                    $dice_type = 6;
                } elsif ($wname =~ /spear|trident/) {
                    $num_dice = 1;
                    $dice_type = 8;
                } elsif ($wname =~ /bow|crossbow|longbow|shortbow/) {
                    $num_dice = 1;
                    $dice_type = 8;
                } elsif ($wname =~ /sling|stone|rock/) {
                    $num_dice = 1;
                    $dice_type = 4;
                } else {
                    $num_dice = 1;
                    $dice_type = 4;
                }
                
                # Add weapon bonus
                $flat_bonus += $treas->{plus} // 0;
                
                # Add proficiency bonus
                if ($attacker_state->{proficiency}) {
                    my $prof = $attacker_state->{proficiency};
                    if (
                        ($prof eq 'Sword'   && $wname =~ /sword|blade|scimitar|sabre|rapier|cutlass/) ||
                        ($prof eq 'Axe'     && $wname =~ /axe|hatchet/) ||
                        ($prof eq 'Bow'     && $wname =~ /bow|crossbow|longbow|shortbow/) ||
                        ($prof eq 'Staff'   && $wname =~ /staff|polearm|halberd|glaive|spear/) ||
                        ($prof eq 'Dagger'  && $wname =~ /dagger|knife|stiletto/) ||
                        ($prof eq 'Mace'    && $wname =~ /mace|club|flail|hammer|maul|morningstar/) ||
                        ($prof eq 'Sling'   && $wname =~ /sling|stone|rock/) ||
                        ($prof eq 'Unarmed' && $wname =~ /fist|hand|unarmed|punch|kick/)
                    ) {
                        $flat_bonus += 2;
                    }
                }
            }
        }
        
        # Add strength bonus for melee weapons
        my $str = $attacker_state->{stats}{str} // 10;
        $flat_bonus += int(($str - 10) / 2);
    }
    
    # Roll damage
    my $damage = 0;
    for (my $i = 0; $i < $num_dice; $i++) {
        $damage += 1 + int(rand($dice_type));
    }
    $damage += $flat_bonus;
    $damage = 1 if $damage < 1;
    
    # Apply defensive effects if target is defending
    if ($target_state->{defending}) {
        $damage = int($damage / 2);
        $damage = 1 if $damage < 1;
        $target_state->{defending} = 0;
    }
    
    # Apply damage
    $target_state->{hp} -= $damage;
    
    # Create attack message
    my $msg = "$attacker_state->{name} attacks $target_state->{name} for $damage damage!";
    
    # Add weapon/proficiency info for player attacks
    if (!$attacker_state->{is_monster} && $attacker_state->{equipped} && $attacker_state->{equipped}{weapon}) {
        my $inv = $attacker_state->{equipped}{weapon};
        my $weapon_bonus = 0;
        my $prof_bonus = 0;
        
        if ($inv->{idx}) {
            my $treas = read_treasure_record($inv->{idx});
            $weapon_bonus = $treas->{plus} // 0;
            
            if ($attacker_state->{proficiency}) {
                my $prof = $attacker_state->{proficiency};
                my $wname = lc($treas->{name} // '');
                if (
                    ($prof eq 'Sword'   && $wname =~ /sword|blade|scimitar|sabre|rapier|cutlass/) ||
                    ($prof eq 'Axe'     && $wname =~ /axe|hatchet/) ||
                    ($prof eq 'Bow'     && $wname =~ /bow|crossbow|longbow|shortbow/) ||
                    ($prof eq 'Staff'   && $wname =~ /staff|polearm|halberd|glaive|spear/) ||
                    ($prof eq 'Dagger'  && $wname =~ /dagger|knife|stiletto/) ||
                    ($prof eq 'Mace'    && $wname =~ /mace|club|flail|hammer|maul|morningstar/) ||
                    ($prof eq 'Sling'   && $wname =~ /sling|stone|rock/) ||
                    ($prof eq 'Unarmed' && $wname =~ /fist|hand|unarmed|punch|kick/)
                ) {
                    $prof_bonus = 2;
                }
            }
        }
        
        $msg .= " (Weapon bonus: +$weapon_bonus, Proficiency bonus: +$prof_bonus)";
    }
    
    # Check if target died
    if ($target_state->{hp} <= 0) {
        $target_state->{hp} = 0;
        $msg .= " $target_state->{name} has been defeated!";
    }
    
    # Add to combat log
    push @{$meta->{log}}, { 
        actor => $attacker_state->{name}, 
        msg => $msg,
        time => time(),
        displayed_to => {}
    };
    
    return $damage;
}

# Process betrayal action
sub process_betrayal {
    my ($actor, $meta, $target_key) = @_;
    my $actor_key = $actor->{is_monster} ? $actor->{id} : safe_name($actor->{name});
    my $actor_state = $meta->{players}{$actor_key};
    my $target_state = $meta->{players}{$target_key};
    
    # Check if betrayal is allowed
    unless ($actor_state->{can_betray} || 
            ($actor_state->{alignment} && $actor_state->{alignment} =~ /chaotic\s+evil/i)) {
        writeline($config{'errorcolor'}."Your alignment prevents you from betraying allies.".$config{'themecolor'}, 1);
        return;
    }
    
    # Remove alliance
    delete $meta->{alliances}{$actor_key}{$target_key};
    delete $meta->{alliances}{$target_key}{$actor_key};
    
    # Create betrayal message
    my $msg = "$actor_state->{name} betrays $target_state->{name} and attacks!";
    
    # Add to combat log
    push @{$meta->{log}}, { 
        actor => $actor_state->{name}, 
        msg => $msg,
        time => time(),
        displayed_to => {}
    };
    
    # Show message to player
    writeline($config{'systemcolor'}."You betray $target_state->{name} and attack!".$config{'themecolor'}, 1);
    
    # Immediately perform an attack
    perform_group_attack($actor_key, $target_key, $meta);
}

# Process alliance request
sub process_alliance_request {
    my ($actor, $meta, $target_key) = @_;
    my $actor_key = $actor->{is_monster} ? $actor->{id} : safe_name($actor->{name});
    my $actor_state = $meta->{players}{$actor_key};
    my $target_state = $meta->{players}{$target_key};
    
    # Check if alliance is allowed
    unless ($meta->{free_for_all} || $meta->{mercenary}) {
        writeline($config{'errorcolor'}."You cannot form alliances in this combat mode.".$config{'themecolor'}, 1);
        return;
    }
    
    # In mercenary mode, require payment
    if ($meta->{mercenary} && !$target_state->{is_monster}) {
        my $offer = prompt_for_alliance_payment($actor, $meta);
        
        if ($offer <= 0) {
            writeline($config{'errorcolor'}."Alliance canceled - no payment offered.".$config{'themecolor'}, 1);
            return;
        }
        
        # Create payment offer message
        my $offer_msg = "$actor_state->{name} offers $target_state->{name} $offer gold for an alliance!";
        
        # Add to combat log
        push @{$meta->{log}}, { 
            actor => $actor_state->{name}, 
            msg => $offer_msg,
            time => time(),
            displayed_to => {}
        };
        
        # Store the offer in meta
        $meta->{alliance_offers}{$actor_key}{$target_key} = {
            amount => $offer,
            time => time(),
        };
        
        writeline($config{'systemcolor'}."You offer $target_state->{name} $offer gold for an alliance.".$config{'themecolor'}, 1);
        writeline($config{'systemcolor'}."They will consider your offer on their turn.".$config{'themecolor'}, 1);
        return;
    }
    
    # For non-mercenary mode or monster targets, alliances form immediately
    
    # Create new alliance
    $meta->{alliances}{$actor_key}{$target_key} = ALLIANCE_TEMPORARY;
    $meta->{alliances}{$target_key}{$actor_key} = ALLIANCE_TEMPORARY;
    
    # Create alliance message
    my $msg = "$actor_state->{name} forms an alliance with $target_state->{name}!";
    
    # Add to combat log
    push @{$meta->{log}}, { 
        actor => $actor_state->{name}, 
        msg => $msg,
        time => time(),
        displayed_to => {}
    };
    
    # Show message to player
    writeline($config{'systemcolor'}."You form an alliance with $target_state->{name}!".$config{'themecolor'}, 1);
}

# Prompt player for alliance payment amount
sub prompt_for_alliance_payment {
    my ($actor, $meta) = @_;
    
    writeline($config{'promptcolor'}."How much gold will you offer for this alliance? ".$config{'themecolor'}, 0);
    my $input = mud_getline();
    
    # Parse input as number
    if ($input =~ /^\d+$/) {
        my $amount = int($input);
        
        # Check if player has enough gold
        if ($amount > ($actor->{gold} // 0)) {
            writeline($config{'errorcolor'}."You don't have that much gold!".$config{'themecolor'}, 1);
            return 0;
        }
        
        return $amount;
    }
    
    return 0;
}

# Clean up combat files for a participant
sub cleanup_combat_files {
    my ($actor, $file, $creator_id) = @_;
    my $actor_key = $actor->{is_monster} ? $actor->{id} : safe_name($actor->{name});
    
    # Remove combat pointer
    my $pointer = $actor->{is_monster}
        ? monster_combat_pointer_path($actor->{id})
        : player_combat_pointer_path($actor->{name});
    
    unlink $pointer if -e $pointer;
    
    # Remove monster combat locks if this is a monster
    if ($actor->{is_monster} && defined &remove_monster_combat_lock) {
        # Get meta to find opponent for lock removal
        my $meta = eval { lock_retrieve($file) };
        if ($meta && $meta->{players}) {
            foreach my $key (keys %{$meta->{players}}) {
                next if $key eq $actor_key;
                my $opponent = $meta->{players}{$key};
                my $opponent_name = $opponent->{is_monster} ? "monster_$opponent->{id}" : $opponent->{name};
                remove_monster_combat_lock($actor->{id}, $opponent_name);
            }
        }
    }
    
    # Check if meta file is still in use by other participants
    my $meta = eval { lock_retrieve($file) };
    if ($meta && $meta->{players}) {
        # Mark this participant as done
        $meta->{players}{$actor_key}{done} = 1;
        eval { lock_store($meta, $file) };
        
        # Check if all participants are done
        my $all_done = 1;
        foreach my $key (keys %{$meta->{players}}) {
            if (!$meta->{players}{$key}{done} && !$meta->{players}{$key}{fled} && $meta->{players}{$key}{hp} > 0) {
                $all_done = 0;
                last;
            }
        }
        
        # Delete meta file if all done
        if ($all_done) {
            unlink $file if -e $file;
        }
    }
}

# Calculate XP gain for combat victory
sub calculate_xp_gain {
    my ($player, $opponent) = @_;
    
    # Base XP is based on opponent level
    my $opp_level = $opponent->{level} // 1;
    my $base_xp = $opp_level * 100;
    
    # Adjust for player level difference
    my $player_level = $player->{level} // 1;
    my $level_diff = $opp_level - $player_level;
    
    # Bonus for defeating higher level opponents, penalty for lower
    my $xp_modifier = 1.0;
    if ($level_diff > 0) {
        $xp_modifier += ($level_diff * 0.2);  # +20% per level above
    } elsif ($level_diff < 0) {
        $xp_modifier -= (abs($level_diff) * 0.1);  # -10% per level below
        $xp_modifier = 0.1 if $xp_modifier < 0.1;  # Minimum 10% of base
    }
    
    # Extra bonus for player vs player combat
    $xp_modifier *= 1.5 if !$opponent->{is_monster};
    
    # Calculate final XP
    my $xp_gain = int($base_xp * $xp_modifier);
    
    # Ensure minimum XP gain
    $xp_gain = 5 if $xp_gain < 5;
    
    return $xp_gain;
}

# Display unread combat logs to player
sub display_unread_combat_logs {
    my ($player, $meta) = @_;
    my $player_hash = safe_name($player->{name});
    
    if ($meta->{log} && @{$meta->{log}}) {
        my $displayed_count = 0;
        
        foreach my $entry (@{$meta->{log}}) {
            next unless $entry->{msg};
            next if $entry->{displayed_to} && $entry->{displayed_to}{$player_hash};
            
            writeline($config{'datacolor'}.$entry->{msg}.$config{'themecolor'}, 1);
            $entry->{displayed_to}{$player_hash} = 1;
            $displayed_count++;
        }
        
        # Return true if any messages were displayed
        return $displayed_count > 0;
    }
    
    return 0;
}

# Check if a combat handshake exists for this player
sub check_combat_handshake {
    my ($player) = @_;
    my $player_hash = safe_name($player->{name});
    my $handshake_file = "$config{transient}/combat_handshake_$player_hash.txt";
    
    if (-e $handshake_file) {
        # Read handshake file
        open(my $fh, "<", $handshake_file);
        my $data = <$fh>;
        close($fh);
        
        # Parse data
        if ($data && $data =~ /^([^|]+)\|([^|]*)\|(\d+)\|(\d+)$/) {
            my $attacker_name = $1;
            my $attacker_id = $2;
            my $attacker_room = $3;
            my $timestamp = $4;
            
            # Verify attacker is still in the same room
            my $attacker_present = 0;
            
            if ($player->{room} == $attacker_room) {
                if ($attacker_id) {
                    # Monster attacker
                    my $room = read_room_record($player->{room});
                    my @monsters = get_room_monsters($room);
                    foreach my $mon (@monsters) {
                        if ($mon->{id} eq $attacker_id) {
                            $attacker_present = 1;
                            last;
                        }
                    }
                } else {
                    # Player attacker
                    $attacker_present = player_in_room($attacker_name, $player->{room});
                }
            }
            
            # If attacker is present and handshake is fresh (< 30 seconds old)
            if ($attacker_present && time() - $timestamp < 30) {
                return {
                    attacker_name => $attacker_name,
                    attacker_id => $attacker_id,
                    attacker_room => $attacker_room,
                    timestamp => $timestamp
                };
            } else {
                # Stale handshake, remove it
                unlink $handshake_file;
            }
        }
    }
    
    return undef;
}

# Check if a combat response exists for this player
sub check_combat_response {
    my ($player_name) = @_;
    my $player_hash = safe_name($player_name);
    my $response_file = "$config{transient}/combat_response_$player_hash.txt";
    
    if (-e $response_file) {
        # Read response file
        open(my $fh, "<", $response_file);
        my $data = <$fh>;
        close($fh);
        
        # Parse data
        if ($data && $data =~ /^([^|]+)\|(\d+)$/) {
            my $response = $1;
            my $timestamp = $2;
            
            # Check if response is fresh (< 30 seconds old)
            if (time() - $timestamp < 30) {
                return {
                    response => $response,
                    timestamp => $timestamp
                };
            } else {
                # Stale response, remove it
                unlink $response_file;
            }
        }
    }
    
    return undef;
}

# Accept a combat request from another player
sub accept_combat_request {
    my ($player, $attacker_name) = @_;
    my $player_hash = safe_name($player->{name});
    my $response_file = "$config{transient}/combat_response_$player_hash.txt";
    
    combat_debug("accept_combat_request: $player->{name} accepting from $attacker_name");
    
    # Create response file
    open(my $fh, ">", $response_file);
    print $fh "fight|" . time();
    close($fh);
    
    combat_debug("accept_combat_request: response file created at $response_file");
    return 1;
}

# Decline a combat request from another player
sub decline_combat_request {
    my ($player, $attacker_name) = @_;
    my $player_hash = safe_name($player->{name});
    my $response_file = "$config{transient}/combat_response_$player_hash.txt";
    
    combat_debug("decline_combat_request: $player->{name} declining from $attacker_name");
    
    # Create response file
    open(my $fh, ">", $response_file);
    print $fh "run|" . time();
    close($fh);
    
    combat_debug("decline_combat_request: response file created at $response_file");
    return 1;
}

# Check if a player is ready for combat
sub check_combat_ready {
    my ($player_name) = @_;
    my $player_hash = safe_name($player_name);
    my $combat_pointer = "$config{transient}/player_$player_hash.combat";
    
    if (-e $combat_pointer) {
        # Read pointer file
        my $data = read_combat_pointer($combat_pointer);
        if ($data && $data->{meta} && -e $data->{meta}) {
            my $meta = eval { lock_retrieve($data->{meta}) };
            if ($meta && $meta->{players} && $meta->{players}{$player_hash}) {
                return (1, $meta->{players}{$player_hash});
            }
        }
    }
    
    return (0, undef);
}

# Setup a new combat between two participants
sub setup_combat {
    my ($p1, $p2) = @_;
    
    # Start combat and get meta file path
    my ($meta_file, $creator_id) = atomic_start_pvp_combat($p1, $p2);
    
    if ($meta_file) {
        # Extract the combat ID from the file path
        my $combat_id;
        if ($meta_file =~ /combat_([^_]+)_([^\.]+)\.storable$/) {
            $combat_id = "$1_$2";
        } else {
            $combat_id = substr($meta_file, rindex($meta_file, '/') + 1);
            $combat_id =~ s/\.storable$//;
            $combat_id =~ s/^combat_//;
        }
        
        combat_debug("setup_combat: Combat initialized with ID $combat_id");
        return $combat_id;
    }
    
    combat_debug("setup_combat: Failed to initialize combat");
    return undef;
}

# Get the combat ID for a player
sub get_combat_id {
    my ($player_name) = @_;
    my $player_hash = safe_name($player_name);
    my $combat_pointer = "$config{transient}/player_$player_hash.combat";
    
    if (-e $combat_pointer) {
        my $data = read_combat_pointer($combat_pointer);
        if ($data && $data->{meta}) {
            my $file = $data->{meta};
            if ($file =~ /combat_([^_]+)_([^\.]+)\.storable$/) {
                return "$1_$2";
            } else {
                my $id = substr($file, rindex($file, '/') + 1);
                $id =~ s/\.storable$//;
                $id =~ s/^combat_//;
                return $id;
            }
        }
    }
    
    return undef;
}

# Read combat metadata by combat ID
sub read_combat_metadata {
    my ($combat_id) = @_;
    
    # Convert ID to file path
    my $file;
    if ($combat_id =~ /^([^_]+)_([^_]+)$/) {
        $file = "$config{transient}/combat_$1_$2.storable";
    } else {
        $file = "$config{transient}/combat_$combat_id.storable";
    }
    
    if (-e $file) {
        my $meta = eval { lock_retrieve($file) };
        return $meta;
    }
    
    return undef;
}

# Display combat status to player
sub display_combat_status {
    my ($player, $meta) = @_;
    my $player_hash = safe_name($player->{name});
    
    # Determine if this is a duel or group combat
    my @participants = keys %{$meta->{players}};
    my $is_duel = @participants == 2;
    
    if ($is_duel) {
        # Get opponent key
        my ($opponent_key) = grep { $_ ne $player_hash } @participants;
        my $opponent = $meta->{players}{$opponent_key};
        my $player_state = $meta->{players}{$player_hash};
        
        # Display duel status
        writeline($config{'systemcolor'}."--- Combat Status ---".$config{'themecolor'}, 1);
        writeline($config{'systemcolor'}."You are in combat with $opponent->{name}!".$config{'themecolor'}, 1);
        writeline(sprintf("%s%s: %d/%d HP%s", 
            $config{'usercolor'}, $player->{name}, $player_state->{hp}, $player_state->{max_hp}, $config{'themecolor'}), 1);
        writeline(sprintf("%s%s: %d/%d HP%s", 
            $config{'datacolor'}, $opponent->{name}, $opponent->{hp}, $opponent->{max_hp}, $config{'themecolor'}), 1);
    } else {
        # Display group combat status
        writeline($config{'systemcolor'}."--- Combat Status ---".$config{'themecolor'}, 1);
        writeline($config{'systemcolor'}."It's your turn in group combat!".$config{'themecolor'}, 1);
        
        # Show round number if applicable
        if ($meta->{round_number}) {
            writeline($config{'systemcolor'}."Round: $meta->{round_number}".$config{'themecolor'}, 1);
        }
        
        # Group participants by team
        my %teams;
        
        foreach my $key (keys %{$meta->{players}}) {
            my $p = $meta->{players}{$key};
            
            # Skip dead or fled participants
            next if $p->{hp} <= 0 || $p->{fled};
            
            # Group by team
            my $team = $p->{team} // $key;
            $teams{$team} //= [];
            push @{$teams{$team}}, {
                key => $key,
                name => $p->{name},
                hp => $p->{hp},
                max_hp => $p->{max_hp},
                is_monster => $p->{is_monster} // 0,
                is_self => ($key eq $player_hash),
                is_ally => $meta->{alliances}{$player_hash}{$key},
            };
        }
        
        # Display teams
        foreach my $team (sort keys %teams) {
            my $is_player_team = 0;
            my $is_allied_team = 0;
            
            # Check if this is player's team or allied
            foreach my $member (@{$teams{$team}}) {
                if ($member->{is_self}) {
                    $is_player_team = 1;
                    last;
                }
                if ($member->{is_ally}) {
                    $is_allied_team = 1;
                }
            }
            
            # Determine team display color
            my $team_color = $is_player_team ? $config{'usercolor'} : 
                             $is_allied_team ? $config{'systemcolor'} : 
                             $config{'errorcolor'};
            
            # Display team header
            writeline($team_color."Team: $team".$config{'themecolor'}, 1);
            
            # Display team members
            foreach my $member (sort { $a->{name} cmp $b->{name} } @{$teams{$team}}) {
                my $status_color = $member->{is_self} ? $config{'usercolor'} : 
                                   $member->{is_ally} ? $config{'systemcolor'} : 
                                   $config{'datacolor'};
                
                writeline(sprintf("%s%s: %d/%d HP%s", 
                    $status_color, $member->{name}, $member->{hp}, $member->{max_hp}, $config{'themecolor'}), 1);
            }
        }
    }
}

# Get player action in combat
sub get_player_combat_action {
    my ($player, $meta) = @_;
    my $player_hash = safe_name($player->{name});
    
    # Determine if this is a duel or group combat
    my @participants = keys %{$meta->{players}};
    my $is_duel = @participants == 2;
    
    if ($is_duel) {
        # Get opponent key
        my ($opponent_key) = grep { $_ ne $player_hash } @participants;
        
        # Show duel combat options
        writeline($config{'promptcolor'}."Combat Actions:".$config{'themecolor'}, 1);
        writeline($config{'promptcolor'}."[A] Attack      [D] Dodge       [R] Run".$config{'themecolor'}, 1);
        writeline($config{'promptcolor'}."[C] Charm       [P] Parry       [Q] Punch".$config{'themecolor'}, 1);
        writeline($config{'promptcolor'}."[B] Beguile     [T] Thrust      [E] Beat".$config{'themecolor'}, 1);
        writeline($config{'promptcolor'}."[S] Shield      [H] Charge      [U] Pummel".$config{'themecolor'}, 1);
        writeline($config{'promptcolor'}."[G] Guard       [O] Counter     [F] Feint".$config{'themecolor'}, 1);
        writeline($config{'promptcolor'}."[L] Lunge       [M] Talk".$config{'themecolor'}, 1);
        
        # Prompt for action
        writeline($config{'promptcolor'}."Choose action: ".$config{'themecolor'}, 0);
        my $action_key = uc(mud_key("A"));
        
        # Map key to action
        my $action = "attack";  # Default
        
        if ($action_key eq "D") {
            $action = "dodge";
            $player->{_dodge_next} = 1;
        } elsif ($action_key eq "R") {
            $action = "run";
        } elsif ($action_key eq "C") {
            $action = "charm";
        } elsif ($action_key eq "P") {
            $action = "parry";
            $player->{_parry_next} = 1;
        } elsif ($action_key eq "Q") {
            $action = "punch";
        } elsif ($action_key eq "B") {
            $action = "beguile";
        } elsif ($action_key eq "T") {
            $action = "thrust";
        } elsif ($action_key eq "E") {
            $action = "beat";
        } elsif ($action_key eq "S") {
            $action = "shield";
            $player->{_shield_next} = 1;
        } elsif ($action_key eq "H") {
            $action = "charge";
        } elsif ($action_key eq "U") {
            $action = "pummel";
        } elsif ($action_key eq "G") {
            $action = "guard";
            $player->{_guard_next} = 1;
        } elsif ($action_key eq "O") {
            $action = "counter";
            $player->{_counter_next} = 1;
        } elsif ($action_key eq "F") {
            $action = "feint";
        } elsif ($action_key eq "L") {
            $action = "lunge";
        } elsif ($action_key eq "M") {
            $action = "talk";
        }
        
        return ($action, $opponent_key);
    } else {
        # Group combat action selection
        return get_player_group_combat_action($player, $meta);
    }
}

# Process a round of combat
sub process_combat_round {
    my ($player, $meta, $combat_id) = @_;
    my $player_hash = safe_name($player->{name});
    
    # If meta wasn't passed, load it
    unless ($meta) {
        $combat_id = get_combat_id($player->{name}) unless $combat_id;
        return 0 unless $combat_id;
        $meta = read_combat_metadata($combat_id);
        return 0 unless $meta && $meta->{status} eq "active";
    }
    
    # Check if it's our turn
    return 0 unless $meta->{current_turn} eq $player_hash || $meta->{turn} eq $player_hash;
    
    # Display any unread logs first
    display_unread_combat_logs($player, $meta);
    
    # Get opponent hash for 1v1 combat
    my ($opponent_hash) = grep { $_ ne $player_hash } keys %{$meta->{players}};
    
    # Determine combat mode
    my $is_group_combat = ($meta->{combat_mode} && $meta->{combat_mode} != COMBAT_MODE_NORMAL);
    
    # Display combat status
    if ($is_group_combat) {
        display_group_combat_status($player, $meta);
    } else {
        display_combat_status($player, $meta);
    }
    
    # Get action and target from player based on combat type
    my ($action, $target_hash) = $is_group_combat ? 
        get_player_group_combat_action($player, $meta) :
        get_player_combat_action($player, $meta);
    
    $target_hash //= $opponent_hash; # Default target in 1v1
    
    # Process the action
    if ($is_group_combat) {
        # Group combat actions
        if ($action eq "attack") {
            perform_group_attack($player_hash, $target_hash, $meta);
        } elsif ($action eq "defend") {
            $meta->{players}{$player_hash}{defending} = 1;
            push @{$meta->{log}}, { 
                actor => $player->{name}, 
                msg => "$player->{name} takes a defensive stance.",
                time => time(),
                displayed_to => {}
            };
        } elsif ($action eq "flee") {
            # Calculate flee chance based on Dexterity
            my $dex_mod = int(($player->{stats}{dex} // 10) / 2) - 5;
            my $flee_roll = int(rand(20)) + 1 + $dex_mod;
            
            if ($flee_roll >= 15) { # DC 15 to flee
                $meta->{players}{$player_hash}{fled} = 1;
                push @{$meta->{log}}, { 
                    actor => $player->{name}, 
                    msg => "$player->{name} successfully flees from combat!",
                    time => time(),
                    displayed_to => {}
                };
                writeline($config{'systemcolor'}."You successfully flee from combat!".$config{'themecolor'}, 1);
            } else {
                push @{$meta->{log}}, { 
                    actor => $player->{name}, 
                    msg => "$player->{name} tries to flee but fails!",
                    time => time(),
                    displayed_to => {}
                };
                writeline($config{'errorcolor'}."You try to flee but fail!".$config{'themecolor'}, 1);
            }
        } elsif ($action eq "betray") {
            process_betrayal($player, $meta, $target_hash);
        } elsif ($action eq "alliance") {
            process_alliance_request($player, $meta, $target_hash);
        }
        
        # Advance turn in group combat
        advance_group_turn($meta, "$config{transient}/combat_$combat_id.meta");
    } else {
        # 1v1 combat actions
        if ($action eq "attack" || $action =~ /^(punch|thrust|beat|charge|pummel|lunge|feint)$/) {
            # Get base weapon damage
            my ($num_dice, $dice_type) = get_weapon_damage_dice($player);
            my $weapon_bonus = get_equipped_bonus($player, "weapon");
            
            # Calculate ability modifiers
            my $str = $player->{stats}{str} // 10;
            my $dex = $player->{stats}{dex} // 10;
            my $str_mod = int(($str - 10) / 2);
            my $dex_mod = int(($dex - 10) / 2);
            
            # Determine if using finesse weapon
            my $is_finesse = 0;
            if ($player->{equipped} && $player->{equipped}{weapon}) {
                my $wname = lc($player->{equipped}{weapon}{name} // '');
                $is_finesse = ($wname =~ /dagger|rapier|shortsword|scimitar|bow|crossbow/);
            }
            
            # Use better modifier for finesse weapons
            my $attack_mod = $is_finesse ? 
                max($str_mod, $dex_mod) : $str_mod;
            
            # Apply action-specific modifiers
            if ($action eq "thrust") {
                $attack_mod += 2;  # Better accuracy
            } elsif ($action eq "charge") {
                $attack_mod -= 2;  # Less accurate but more damage
                $num_dice++;
            } elsif ($action eq "pummel") {
                $dice_type = max(4, $dice_type - 2);  # Smaller dice
                $num_dice += 2;    # More hits
            } elsif ($action eq "lunge") {
                $attack_mod -= 2;  # Less accurate
                $weapon_bonus += 4; # More damage
            } elsif ($action eq "feint") {
                $attack_mod += 4;  # Much better accuracy
            }
            
            # Roll for attack with proficiency bonus
            my $prof_bonus = int(($player->{level} // 1) / 4) + 2;
            my $attack_roll = int(rand(20)) + 1;
            my $is_critical = ($attack_roll == 20);
            $attack_roll += $attack_mod + $prof_bonus;
            
            # Calculate target's AC
            my $target_dex_mod = int(($meta->{players}{$opponent_hash}{stats}{dex} // 10) / 2) - 5;
            my $target_ac = 10 + $target_dex_mod;
            
            # Add armor bonus if target has armor
            if ($meta->{players}{$opponent_hash}{equipped} && 
                $meta->{players}{$opponent_hash}{equipped}{armor}) {
                my $armor_bonus = 2; # Base armor bonus
                $target_ac += $armor_bonus;
            }
            
            if ($attack_roll < $target_ac && !$is_critical) {
                # Attack missed
                push @{$meta->{log}}, { 
                    actor => $player->{name}, 
                    msg => "$player->{name} misses $meta->{players}{$opponent_hash}{name}!",
                    time => time(),
                    displayed_to => {}
                };
                writeline($config{'systemcolor'}."Your attack misses!".$config{'themecolor'}, 1);
            } else {
                # Calculate base damage
                my $damage = 0;
                my $num_rolls = $is_critical ? $num_dice * 2 : $num_dice;
                
                for (my $i = 0; $i < $num_rolls; $i++) {
                    $damage += 1 + int(rand($dice_type));
                }
                
                # Add modifiers
                $damage += $weapon_bonus;
                $damage += $attack_mod;
                $damage = max(1, $damage);
                
                # Apply defensive effects
                $damage = resolve_defense_effects(
                    $meta->{players}{$player_hash},
                    $meta->{players}{$opponent_hash},
                    $damage,
                    $player->{room}
                );
                
                # Apply final damage
                $meta->{players}{$opponent_hash}{hp} -= $damage;
                $meta->{players}{$opponent_hash}{hp} = max(0, $meta->{players}{$opponent_hash}{hp});
                
                # Create combat message
                my $msg = "$player->{name} ";
                $msg .= $action eq "attack" ? "attacks" :
                        $action eq "punch" ? "punches" :
                        $action eq "thrust" ? "thrusts at" :
                        $action eq "beat" ? "beats down on" :
                        $action eq "charge" ? "charges" :
                        $action eq "pummel" ? "pummels" :
                        $action eq "lunge" ? "lunges at" :
                        $action eq "feint" ? "feints and strikes" :
                        "strikes";
                
                $msg .= " $meta->{players}{$opponent_hash}{name} for $damage damage";
                $msg .= " (CRITICAL HIT!)" if $is_critical;
                $msg .= "!";
                
                # Check if opponent died
                if ($meta->{players}{$opponent_hash}{hp} <= 0) {
                    $meta->{players}{$opponent_hash}{hp} = 0;
                    $meta->{status} = "completed";
                    $meta->{end_reason} = "victory";
                    $meta->{winner} = $player_hash;
                    $meta->{victory_announced} = 1;  # Prevent duplicate victory/XP handling
                    $msg .= " You have defeated $meta->{players}{$opponent_hash}{name} in combat!";
                    
                    # Award XP for victory using proper calculation
                    if (!$meta->{players}{$opponent_hash}{is_monster}) {
                        my $xp_gain = calculate_xp_gain($player, $meta->{players}{$opponent_hash});
                        $player->{experience} = ($player->{experience} // 0) + $xp_gain;
                        writeline($config{'systemcolor'}."You gain $xp_gain experience!".$config{'themecolor'}, 1);
                    }
                }
                
                # Add to combat log
                push @{$meta->{log}}, { 
                    actor => $player->{name}, 
                    msg => $msg,
                    time => time(),
                    displayed_to => {}
                };
                
                writeline($config{'systemcolor'}.$msg.$config{'themecolor'}, 1);
            }
        } elsif ($action eq "run") {
            my $dex_mod = int(($player->{stats}{dex} // 10) / 2) - 5;
            my $flee_roll = int(rand(20)) + 1 + $dex_mod;
            
            if ($flee_roll >= 15) { # DC 15 to flee
                $meta->{status} = "completed";
                $meta->{end_reason} = "fled";
                $meta->{winner} = $opponent_hash;
                
                push @{$meta->{log}}, { 
                    actor => $player->{name}, 
                    msg => "$player->{name} successfully flees from combat!",
                    time => time(),
                    displayed_to => {}
                };
                writeline($config{'systemcolor'}."You successfully flee from combat!".$config{'themecolor'}, 1);
            } else {
                push @{$meta->{log}}, { 
                    actor => $player->{name}, 
                    msg => "$player->{name} tries to flee but fails!",
                    time => time(),
                    displayed_to => {}
                };
                writeline($config{'errorcolor'}."You try to flee but fail!".$config{'themecolor'}, 1);
            }
        }
        
        # Advance turn in 1v1 combat if still active
        if ($meta->{status} eq "active") {
            advance_turn($meta, "$config{transient}/combat_$combat_id.meta");
        }
    }
    
    # Save updated metadata
    eval { 
        lock_store($meta, "$config{transient}/combat_$combat_id.meta");
    };
    if ($@) {
        combat_debug("Error saving combat meta: $@");
    }
    
    # Check if combat should end
    check_combat_end_conditions($meta, $combat_id);
    
    return 1;
}

# Check if combat should end
sub check_combat_end_conditions {
    my ($meta, $combat_id) = @_;
    
    # Already ended
    return if $meta->{status} ne "active";
    
    # Check if any participant is still alive in each team
    my %living_teams;
    
    foreach my $key (keys %{$meta->{players}}) {
        my $p = $meta->{players}{$key};
        
        # Skip dead or fled participants
        next if $p->{hp} <= 0 || $p->{fled};
        
        # Count living members by team
        my $team = $p->{team} // $key;
        $living_teams{$team} = ($living_teams{$team} // 0) + 1;
    }
    
    # If no teams are left, it's a draw
    if (scalar(keys %living_teams) == 0) {
        $meta->{status} = "completed";
        $meta->{end_reason} = "all_dead";
        
        push @{$meta->{log}}, { 
            actor => "system", 
            msg => "Combat ends with no survivors!",
            time => time(),
            displayed_to => {}
        };
        
        # Save updated metadata
        eval { lock_store($meta, "$config{transient}/combat_$combat_id.meta") };
        return;
    }
    
    # If only one team remains, they win
    if (scalar(keys %living_teams) == 1) {
        my ($winner_team) = keys %living_teams;
        $meta->{status} = "completed";
        $meta->{end_reason} = "victory";
        $meta->{winner} = $winner_team;
        
        # Find a member of the winning team
        my $winner_name = $winner_team;
        foreach my $key (keys %{$meta->{players}}) {
            my $p = $meta->{players}{$key};
            if (($p->{team} // $key) eq $winner_team && $p->{hp} > 0) {
                $winner_name = $p->{name};
                last;
            }
        }
        
        push @{$meta->{log}}, { 
            actor => "system", 
            msg => "Team $winner_name is victorious!",
            time => time(),
            displayed_to => {}
        };
        
        # Save updated metadata
        eval { lock_store($meta, "$config{transient}/combat_$combat_id.meta") };
        return;
    }
}

# Advance the combat turn
sub advance_combat_turn {
    my ($combat_id) = @_;
    
    # Load metadata
    my $meta = read_combat_metadata($combat_id);
    return unless $meta && $meta->{status} eq "active";
    
    # Check if this is group combat
    if ($meta->{combat_mode} && $meta->{combat_mode} != COMBAT_MODE_NORMAL) {
        advance_group_turn($meta, "$config{transient}/combat_$combat_id.meta");
    } else {
        advance_turn($meta, "$config{transient}/combat_$combat_id.meta");
    }
}

# Export necessary functions
sub import {
    my $pkg = caller;
    no strict 'refs';
    for my $sym (qw(
        atomic_start_pvp_combat
        pvp_combat_metaloop
        group_combat_metaloop
        cleanup_stale_combat_files
        check_combat_status
        get_combat_id
        process_combat_round
    )) {
        *{"${pkg}::$sym"} = \&$sym;
    }
}

sub start_group_combat {
    my (@participants) = @_;
    
    # Input validation
    return unless @participants >= 2;
    foreach my $p (@participants) {
        next unless $p;
        return unless ref($p) eq 'HASH';
        return unless defined($p->{name}) || defined($p->{id});
    }
    
    # Separate players and monsters with validation
    my @players = grep { 
        $_ && ref($_) eq 'HASH' && !$_->{is_monster} && defined($_->{name})
    } @participants;
    
    my @monsters = grep { 
        $_ && ref($_) eq 'HASH' && $_->{is_monster} && defined($_->{id})
    } @participants;
    
    # Must have at least one player
    return unless @players > 0;
    
    # Default to 1v1 combat if only one player vs one monster
    if (@players == 1 && @monsters == 1) {
        my ($meta_file, $creator_id) = atomic_start_pvp_combat(
            $players[0], 
            $monsters[0], 
            COMBAT_MODE_NORMAL
        );
        combat_debug("start_group_combat: Initiated 1v1 combat between " . 
                    "$players[0]->{name} and $monsters[0]->{name}");
        return ($meta_file, $creator_id);
    }
    
    # Initialize combat with first player as initiator
    my $initiator = $players[0];
    my $target;
    
    # Select initial target (prefer monsters over players)
    if (@monsters > 0) {
        $target = $monsters[0];
    } elsif (@players > 1) {
        $target = $players[1];
    } else {
        combat_debug("start_group_combat: No valid target found for initiator");
        return;
    }
    
    # Start combat
    my ($meta_file, $creator_id) = atomic_start_pvp_combat(
        $initiator, 
        $target,
        COMBAT_MODE_PARTY
    );
    
    unless ($meta_file && $creator_id) {
        combat_debug("start_group_combat: Failed to initiate combat");
        return;
    }
    
    # Load meta file with error handling
    my $meta = eval { lock_retrieve($meta_file) };
    if ($@ || !$meta) {
        combat_debug("start_group_combat: Failed to load meta file: " . ($@ || "unknown error"));
        unlink $meta_file;
        return;
    }
    
    # Track successful additions
    my $additions = 0;
    
    # Add remaining players with duplicate checking
    for my $i (1..$#players) {
        my $player = $players[$i];
        next unless $player && $player->{name};
        
        # Skip initial participants
        next if $player->{name} eq $initiator->{name};
        next if !$target->{is_monster} && $player->{name} eq $target->{name};
        
        # Skip if already in combat
        next if player_in_combat($player->{name});
        
        # Try to add player
        eval {
            # Get player ID (safe name)
            my $player_id = safe_name($player->{name});
            
            # Skip if already in this combat
            next if exists $meta->{players}{$player_id};
            
            # Convert player to combatant 
            my $player_combatant = player_to_combatant($player);
            
            # Safety check - ensure conversion succeeded
            unless ($player_combatant && ref($player_combatant) eq 'HASH') {
                combat_debug("start_group_combat: Failed to convert player $player->{name} to combatant");
                next;
            }
            
            # Add player to combat
            $meta->{players}{$player_id} = $player_combatant;
            
            # Create combat pointer for this player
            write_combat_pointer(player_combat_pointer_path($player->{name}), $meta_file, $creator_id);
            
            # Set up alliances with other players on same team
            my $team = get_player_team($player);
            foreach my $key (keys %{$meta->{players}}) {
                next if $key eq $player_id;
                
                my $other_team = $meta->{players}{$key}{team} // $key;
                
                # If same team, create alliance
                if ($other_team eq $team) {
                    $meta->{alliances}{$player_id}{$key} = ALLIANCE_PERMANENT;
                    $meta->{alliances}{$key}{$player_id} = ALLIANCE_PERMANENT;
                }
            }
            
            # Notify player if they're online
            if (defined &write_session_message && player_online($player->{name})) {
                write_session_message($player->{name}, 
                    $config{'systemcolor'}."You have been drawn into combat!".$config{'themecolor'});
            }
            
            $additions++;
            combat_debug("start_group_combat: Added player $player->{name}");
        };
        if ($@) {
            combat_debug("start_group_combat: Failed to add player $player->{name}: $@");
        }
    }
    
    # Add remaining monsters with duplicate checking
    for my $i (1..$#monsters) {
        my $monster = $monsters[$i];
        next unless $monster && $monster->{id};
        
        # Skip initial target
        next if $target->{is_monster} && $monster->{id} eq $target->{id};
        
        # Skip if already in combat
        next if monster_in_combat($monster->{id});
        
        # Try to add monster
        eval {
            # Skip if already in this combat
            next if exists $meta->{players}{$monster->{id}};
            
            # Convert monster to combatant
            my $monster_combatant = monster_to_combatant($monster);
            
            # Safety check - ensure conversion succeeded
            unless ($monster_combatant && ref($monster_combatant) eq 'HASH') {
                combat_debug("start_group_combat: Failed to convert monster $monster->{name} to combatant");
                next;
            }
            
            # Add monster to combat
            $meta->{players}{$monster->{id}} = $monster_combatant;
            
            # Create combat pointer for this monster
            write_combat_pointer(monster_combat_pointer_path($monster->{id}), $meta_file, $creator_id);
            
            # IMPORTANT: Set combat lock for monsterai
            if (defined &set_monster_combat_lock) {
                set_monster_combat_lock($monster->{id}, $initiator->{name}, 300);  # 5 minute lock
                combat_debug("start_group_combat: Set combat lock for monster $monster->{id}");
            }
            
            # Set up alliances with other monsters
            foreach my $key (keys %{$meta->{players}}) {
                next if $key eq $monster->{id};
                
                if ($meta->{players}{$key}{is_monster}) {
                    $meta->{alliances}{$monster->{id}}{$key} = ALLIANCE_PERMANENT;
                    $meta->{alliances}{$key}{$monster->{id}} = ALLIANCE_PERMANENT;
                }
            }
            
            $additions++;
            combat_debug("start_group_combat: Added monster $monster->{name} (id: $monster->{id})");
        };
        if ($@) {
            combat_debug("start_group_combat: Failed to add monster $monster->{name}: $@");
        }
    }
    
    # Verify we have a valid combat scenario
    my $total_participants = scalar(keys %{$meta->{players}});
    unless ($total_participants >= 2) {
        combat_debug("start_group_combat: Invalid number of participants ($total_participants)");
        unlink $meta_file;
        return;
    }
    
    # Save final meta state
    eval { 
        # Update combat mode if needed
        $meta->{combat_mode} = COMBAT_MODE_PARTY;
        $meta->{status} = "initializing";
        $meta->{creation_time} = time();
        
        # Save with locking
        lock_store($meta, $meta_file);
    };
    if ($@) {
        combat_debug("start_group_combat: Failed to save final meta state: $@");
        unlink $meta_file;
        return;
    }
    
    combat_debug("start_group_combat: Successfully initiated group combat with " . 
                "$total_participants participants ($additions additional)");
    
    return ($meta_file, $creator_id);
}

# Convert a player object to a combatant object for combat state
sub player_to_combatant {
    my ($player) = @_;
    
    # Safety check - ensure we have a valid player hash
    return undef unless $player && ref($player) eq 'HASH';
    
    return {
        id        => safe_name($player->{name}),
        name      => $player->{name},
        hp        => $player->{hp} // 1,
        max_hp    => $player->{max_hp} // $player->{hp} // 1,
        stats     => $player->{stats} // {},
        is_monster=> 0,
        ready     => 0,
        initiator => 0,
        room      => $player->{room},
        level     => $player->{level} // 1,
        treasure  => $player->{treasure},
        gold      => $player->{gold} // 0,
        inventory => $player->{inventory},
        team      => get_player_team($player),
        alignment => $player->{alignment},
        alliance_type => ALLIANCE_PERMANENT,
    };
}

# Convert a monster object to a combatant object for combat state
sub monster_to_combatant {
    my ($monster) = @_;
    
    # Safety check - ensure we have a valid monster hash
    return undef unless $monster && ref($monster) eq 'HASH';
    
    return {
        id        => $monster->{id},
        name      => $monster->{name},
        hp        => $monster->{hp} // 1,
        max_hp    => $monster->{max_hp} // $monster->{hp} // 1,
        stats     => $monster->{stats} // {},
        is_monster=> 1,
        ready     => 1,
        initiator => 0,
        room      => $monster->{room},
        level     => $monster->{level} // 1,
        treasure  => $monster->{treasure},
        team      => "monsters",
        alliance_type => ALLIANCE_PERMANENT,
    };
}

sub update_player_alliances {
    my ($player, $meta) = @_;
    my $player_id = safe_name($player->{name});
    
    # Get player's team
    my $team = get_player_team($player);
    
    # Create alliances with other team members
    foreach my $key (keys %{$meta->{players}}) {
        next if $key eq $player_id;
        
        my $other_team = $meta->{players}{$key}{team} // $key;
        
        # If same team, create alliance
        if ($other_team eq $team) {
            $meta->{alliances}{$player_id}{$key} = ALLIANCE_PERMANENT;
            $meta->{alliances}{$key}{$player_id} = ALLIANCE_PERMANENT;
        }
    }
}

sub update_monster_alliances {
    my ($monster, $meta) = @_;
    my $monster_id = $monster->{id};
    
    # Create alliances with other monsters
    foreach my $key (keys %{$meta->{players}}) {
        next if $key eq $monster_id;
        
        if ($meta->{players}{$key}{is_monster}) {
            $meta->{alliances}{$monster_id}{$key} = ALLIANCE_PERMANENT;
            $meta->{alliances}{$key}{$monster_id} = ALLIANCE_PERMANENT;
        }
    }
}

# This function handles advancing turns properly in 1v1 combat
sub advance_turn {
    my ($meta, $file) = @_;
    
    # Get current turn index
    my $current_idx = $meta->{turn_index} // 0;
    
    # Move to next turn
    $current_idx = ($current_idx + 1) % scalar(@{$meta->{turn_order}});
    $meta->{turn_index} = $current_idx;
    
    # Set both turn fields to ensure consistency
    $meta->{turn} = $meta->{turn_order}[$current_idx];
    $meta->{current_turn} = $meta->{turn};
    
    # Reset turn_advanced_by flag for the new turn
    delete $meta->{turn_advanced_by};
    
    # Create a new log entry showing whose turn it is now
    push @{$meta->{log}}, { 
        actor => "system", 
        msg => "It's " . $meta->{players}{$meta->{turn}}{name} . "'s turn!",
        time => time(),
        displayed_to => {}
    };
    
    # Save updated meta - Ensure file is written to disk
    eval {
        lock_store($meta, $file);
        combat_debug("advance_turn: Advanced turn to $meta->{turn} ($meta->{players}{$meta->{turn}}{name})");
    };
    if ($@) {
        combat_debug("advance_turn: ERROR saving meta: $@");
    }
}

# Clean up combat metafiles and pointers
sub cleanup_pvp_metafiles {
    my ($actor_key, $opponent_key, $file, $creator_id) = @_;
    
    combat_debug("cleanup_pvp_metafiles: Starting cleanup for $actor_key vs $opponent_key (metafile: $file)");
    
    # Determine file paths
    my $player_pointer = "$config{transient}/player_$actor_key.combat";
    my $opponent_pointer = "$config{transient}/player_$opponent_key.combat";
    my $monster_pointer = "$config{transient}/monster_$opponent_key.combat";
    
    # Track which players we've already processed
    my %processed_players;
    
    # Check if meta file still exists and if it does, read it to see who died
    my $meta;
    my $winner_key = ""; # Initialize to prevent uninitialized warning
    my $end_reason = "";
    
    if ($file && -e $file) {
        $meta = eval { lock_retrieve($file) };
        
        # Process player death and victory states if meta contains that info
        if ($meta && $meta->{players}) {
            # Check if we have a definitive winner/loser
            $winner_key = $meta->{winner} // "";
            $end_reason = $meta->{end_reason} // '';
            
            foreach my $key (keys %{$meta->{players}}) {
                my $p = $meta->{players}{$key};
                
                # Skip if we've already processed this player
                next if $processed_players{$key};
                $processed_players{$key} = 1;
                
                # If this is a player (not monster) who died, handle death
                if (!$p->{is_monster} && $p->{hp} <= 0 && !$p->{_death_handled}) {
                    combat_debug("cleanup_pvp_metafiles: Player $p->{name} died in combat");
                    
                    my $player_obj = load_player($p->{name});
                    if ($player_obj) {
                        # Log the death for diagnostic purposes
                        combat_debug("cleanup_pvp_metafiles: Processing death for $p->{name}");
                        
                        # Mark player with 0 HP to ensure death handling
                        $player_obj->{hp} = 0;
                        
                        # Mark death as handled to prevent duplicate processing
                        $player_obj->{_death_handled} = 1;
                        $p->{_death_handled} = 1; # Also mark in meta
                        save_player($player_obj);
                        
                        # Force immediate player death handling (this sends all death messages)
                        if (defined &handle_player_death) {
                            combat_debug("cleanup_pvp_metafiles: Calling handle_player_death for $p->{name}");
                            handle_player_death($player_obj);
                        }
                    }
                }
                # If this is the winner, make sure they get a victory message
                elsif (!$p->{is_monster} && $key eq $winner_key && $end_reason eq "victory") {
                    if (defined &write_session_message && player_online($p->{name})) {
                        my $loser_name = "";
                        foreach my $other_key (keys %{$meta->{players}}) {
                            if ($other_key ne $key && $meta->{players}{$other_key}{hp} <= 0) {
                                $loser_name = $meta->{players}{$other_key}{name} || "opponent";
                                last;
                            }
                        }
                        if ($loser_name) {
                            write_session_message($p->{name}, 
                                "\n" . $config{'systemcolor'} . "You have defeated $loser_name in combat!" . $config{'themecolor'} . "\n");
                        }
                    }
                }
            }
            
            # Process monster deaths with proper cleanup and messaging
            foreach my $key (keys %{$meta->{players}}) {
                my $p = $meta->{players}{$key};
                
                # Skip if not a monster or not dead
                next unless $p->{is_monster} && $p->{hp} <= 0;
                
                # Broadcast monster death message to room with proper formatting
                if ($p->{room}) {
                    my $death_msg = "\n" . $config{'usercolor'} . "$p->{name} collapses and vanishes from the realm." . $config{'themecolor'} . "\n";
                    broadcast_room_message($p->{room}, undef, $death_msg);
                    combat_debug("cleanup_pvp_metafiles: Broadcasted death message for monster $p->{name}");
                    
                    # Remove monster from room data structures
                    my $monster_room = read_room_with_num($p->{room});
                    if ($monster_room) {
                        # Find and remove the monster from the room
                        my @monsters = get_room_monsters($monster_room);
                        my ($dead_monster) = grep { $_->{id} eq $key } @monsters;
                        if ($dead_monster) {
                            remove_monster_from_room($dead_monster, $monster_room);
                            combat_debug("cleanup_pvp_metafiles: Removed dead monster $p->{name} from room $p->{room}");
                        }
                    }
                }
            }
            
            # Mark this player as done in the meta file
            if ($meta->{players}{$actor_key}) {
                $meta->{players}{$actor_key}{done} = 1;
                $meta->{players}{$actor_key}{cleanup_time} = time();
                eval { lock_store($meta, $file) };
                if ($@) {
                    combat_debug("cleanup_pvp_metafiles: Error saving meta after marking done: $@");
                }
            }
        }
    }
    
    # Always clean up player's own pointer
    if (-e $player_pointer) {
        unlink $player_pointer;
        combat_debug("cleanup_pvp_metafiles: Removed player pointer $player_pointer");
    }
    
    # IMPORTANT: Update the actual player object with combat results BEFORE cleanup
    # BUT ONLY sync HP if player is still alive after combat
    if ($meta && $meta->{players} && $meta->{players}{$actor_key}) {
        my $combat_state = $meta->{players}{$actor_key};
        
        # Find the actual player object
        my $actor_player = undef;
        if (!$combat_state->{is_monster}) {
            # Try to find the player object from calling context
            if ($::player && safe_name($::player->{name}) eq $actor_key) {
                $actor_player = $::player;
            } else {
                # Load the player if we don't have it
                $actor_player = load_player($combat_state->{name});
            }
        }
        
        # Update the player object with combat results
        if ($actor_player && $actor_player->{name} && !$actor_player->{is_monster}) {
            # CRITICAL FIX: Only sync HP if player survived combat
            # If player died and was respawned, don't overwrite the respawn HP
            if ($combat_state->{hp} > 0) {
                # Player survived combat - sync HP from combat state
                $actor_player->{hp} = $combat_state->{hp};
                $actor_player->{max_hp} = $combat_state->{max_hp} // $actor_player->{max_hp};
                
                combat_debug("cleanup_pvp_metafiles: Updated surviving player $actor_player->{name} HP to $combat_state->{hp}");
            } else {
                # Player died - keep the HP that handle_player_death set (don't overwrite)
                combat_debug("cleanup_pvp_metafiles: Player $actor_player->{name} died, keeping respawn HP $actor_player->{hp}");
            }
            
            # Always clear combat flags
            $actor_player->{in_combat} = 0;
            delete $actor_player->{_dodge_next};
            delete $actor_player->{_parry_next};
            delete $actor_player->{_guard_next};
            delete $actor_player->{_shield_next};
            delete $actor_player->{_counter_next};
            delete $actor_player->{disadvantage_next};
            
            # Save the updated player state immediately
            save_player($actor_player);
            
            # Also update the global player variable if this is the current player
            if ($::player && $::player->{name} eq $actor_player->{name}) {
                # For living players, sync from combat state
                # For dead players, keep the respawned HP
                if ($combat_state->{hp} > 0) {
                    $::player->{hp} = $combat_state->{hp};
                }
                $::player->{max_hp} = $combat_state->{max_hp} // $::player->{max_hp};
                $::player->{in_combat} = 0;
                delete $::player->{_dodge_next};
                delete $::player->{_parry_next};
                delete $::player->{_guard_next};
                delete $::player->{_shield_next};
                delete $::player->{_counter_next};
                delete $::player->{disadvantage_next};
            }
        }
    }
    
    # Check if meta file is still in use by other participants
    my $still_active = 0;
    my @active_pointers;
    
    # Check opponent player pointer
    if ($opponent_key && -e $opponent_pointer) {
        my $opp_data = read_combat_pointer($opponent_pointer);
        if ($opp_data && $opp_data->{meta} eq $file) {
            $still_active = 1;
            push @active_pointers, $opponent_pointer;
            combat_debug("cleanup_pvp_metafiles: Found active pointer $opponent_pointer still referencing $file ($opponent_key)");
        }
    }
    
    # Check monster pointer
    if ($opponent_key && -e $monster_pointer) {
        my $mon_data = read_combat_pointer($monster_pointer);
        if ($mon_data && $mon_data->{meta} eq $file) {
            $still_active = 1;
            push @active_pointers, $monster_pointer;
            combat_debug("cleanup_pvp_metafiles: Found active monster pointer $monster_pointer still referencing $file ($opponent_key)");
        }
    }
    
    # Check for any other pointers that might reference this meta file
    foreach my $pointer_file (glob("$config{transient}/*.combat")) {
        next if $pointer_file eq $player_pointer; # Skip our own (already deleted)
        next if grep { $_ eq $pointer_file } @active_pointers; # Skip already checked
        
        my $data = read_combat_pointer($pointer_file);
        if ($data && $data->{meta} && $data->{meta} eq $file) {
            $still_active = 1;
            push @active_pointers, $pointer_file;
            combat_debug("cleanup_pvp_metafiles: Found additional active pointer $pointer_file");
        }
    }
    
    # Only delete meta file if not still in use
    if (!$still_active && $file && -e $file) {
        combat_debug("cleanup_pvp_metafiles: Deleting metafile $file");
        unlink $file;
    } elsif ($still_active && $file) {
        combat_debug("cleanup_pvp_metafiles: Not deleting metafile $file as it's still in use by " . scalar(@active_pointers) . " pointers");
        
        # Even if the file is still in use, process any unhandled player deaths
        if ($meta && $meta->{players}) {
            foreach my $key (keys %{$meta->{players}}) {
                my $p = $meta->{players}{$key};
                
                # Skip if already processed or not a player or not dead
                next if $processed_players{$key} || $p->{is_monster} || $p->{hp} > 0 || $p->{_death_handled};
                $processed_players{$key} = 1;
                
                combat_debug("cleanup_pvp_metafiles: Processing deferred death for $p->{name}");
                
                # Get a fresh copy of the player
                my $player_obj = load_player($p->{name});
                if ($player_obj && !$player_obj->{_death_handled}) {
                    # Set HP to 0 and mark death as handled
                    $player_obj->{hp} = 0;
                    $player_obj->{_death_handled} = 1;
                    $p->{_death_handled} = 1; # Also mark in meta
                    save_player($player_obj);
                    
                    # Force immediate player death handling (this sends all death messages)
                    if (defined &handle_player_death) {
                        combat_debug("cleanup_pvp_metafiles: Calling handle_player_death for $p->{name}");
                        handle_player_death($player_obj);
                    }
                }
            }
            
            # Save updated meta with death flags
            eval { lock_store($meta, $file) };
            if ($@) {
                combat_debug("cleanup_pvp_metafiles: Error saving meta after deferred death processing: $@");
            }
        }
        
        # Also sync any living players' HP
        if ($meta && $meta->{players}) {
            foreach my $key (keys %{$meta->{players}}) {
                my $p = $meta->{players}{$key};
                
                # Skip monsters or dead players
                next if $p->{is_monster} || $p->{hp} <= 0;
                
                # Update living players' HP
                my $player_obj = load_player($p->{name});
                if ($player_obj) {
                    # Only update if HP is different
                    if ($player_obj->{hp} != $p->{hp}) {
                        $player_obj->{hp} = $p->{hp};
                        $player_obj->{max_hp} = $p->{max_hp} // $player_obj->{max_hp};
                        
                        # Clear combat flags for living players too
                        $player_obj->{in_combat} = 0;
                        delete $player_obj->{_dodge_next};
                        delete $player_obj->{_parry_next};
                        delete $player_obj->{_guard_next};
                        delete $player_obj->{_shield_next};
                        delete $player_obj->{_counter_next};
                        delete $player_obj->{disadvantage_next};
                        
                        save_player($player_obj);
                        
                        # Also update global player if this is the current player
                        if ($::player && $::player->{name} eq $player_obj->{name}) {
                            $::player->{hp} = $p->{hp};
                            $::player->{max_hp} = $p->{max_hp} // $::player->{max_hp};
                            $::player->{in_combat} = 0;
                            delete $::player->{_dodge_next};
                            delete $::player->{_parry_next};
                            delete $::player->{_guard_next};
                            delete $::player->{_shield_next};
                            delete $::player->{_counter_next};
                            delete $::player->{disadvantage_next};
                        }
                        
                        combat_debug("cleanup_pvp_metafiles: Synced HP for living player $p->{name}: $p->{hp}");
                    }
                }
            }
        }
    }
    
    # Clean up any stale handshake or response files related to this combat
    foreach my $participant_key ($actor_key, $opponent_key) {
        next unless $participant_key;
        
        my $handshake_file = "$config{transient}/combat_handshake_$participant_key.txt";
        my $response_file = "$config{transient}/combat_response_$participant_key.txt";
        
        if (-e $handshake_file) {
            unlink $handshake_file;
            combat_debug("cleanup_pvp_metafiles: Cleaned up handshake file for $participant_key");
        }
        
        if (-e $response_file) {
            unlink $response_file;
            combat_debug("cleanup_pvp_metafiles: Cleaned up response file for $participant_key");
        }
    }
    
    combat_debug("cleanup_pvp_metafiles: Cleanup complete for $actor_key vs $opponent_key");
}

sub handle_player_death {
    my ($player) = @_;
    return unless $player && $player->{name};
    
    # Log the death event for debugging regardless of handled state
    photonmud_debug("handle_player_death: Processing death for $player->{name}");
    
    # Check if death has been handled already - return early to prevent duplicate messages
    if ($player->{_death_handled}) {
        photonmud_debug("handle_player_death: Death already handled for $player->{name}, skipping");
        return;
    }
    
    # Mark death as handled to prevent future duplicate processing
    $player->{_death_handled} = 1;
    
    # Clear any combat flags immediately
    $player->{in_combat} = 0;
    
    # Get old room for leaving notification and to check if player has already moved
    my $old_room = $player->{room};
    
    # Broadcast death message to room if player is still in the original combat room
    broadcast_room_message($old_room, $player->{name},
        $config{'usercolor'}."$player->{name} has been defeated!".$config{'themecolor'});
    
    # Lose some gold
    my $gold_loss = int($player->{gold} * 0.1);
    if ($gold_loss > 0) {
        $player->{gold} -= $gold_loss;
        writeline($config{'errorcolor'}."You lose $gold_loss gold.".$config{'themecolor'}, 1) 
            if player_online($player->{name});
    }
    
    # Find a random valid respawn room
    my $max_room = get_max_room();
    my $attempts = 0;
    my $max_attempts = 50;
    my $new_room;
    
    while ($attempts < $max_attempts) {
        $attempts++;
        my $try_room = 1 + int(rand($max_room));
        my $try = read_room_record($try_room);
        $try->{roomnum} = $try_room unless $try->{roomnum};
        
        # Only accept if has exits and not in forbidden region
        if ($try->{exits} && 
            scalar(grep { $try->{exits}{$_} && $try->{exits}{$_} > 0 } keys %{$try->{exits}}) > 0 &&
            (!$try->{region} || $try->{region} !~ /^(Mountain|Lake|Moat)$/i)) {
            $new_room = $try_room;
            last;
        }
    }
    
    # Fallback to start room if random room selection failed
    $new_room = $config{start_room} // 1 unless $new_room;
    
    # Don't respawn if already in a different room than the combat room
    if ($old_room != $new_room) {
        photonmud_debug("handle_player_death: Moving $player->{name} from room $old_room to $new_room");
        
        # Only send messages to the player if they're online
        if (player_online($player->{name})) {
            writeline("", 1);  # Blank line for spacing
            writeline($config{'errorcolor'}."You have been defeated!".$config{'themecolor'}, 1);
            writeline($config{'systemcolor'}."You wake up in a safe place...".$config{'themecolor'}, 1);
            writeline("", 1);  # Blank line before room description
        }
        
        # Properly handle room transitions - first leave the current room
        if (defined &photonmud_leave_room) {
            photonmud_leave_room($player, $old_room, "death");
        }
        
        # Set new room
        $player->{room} = $new_room;
        
        # Set HP to 25% of max (but at least 1)
        $player->{hp} = int($player->{max_hp} * 0.25);
        $player->{hp} = 1 if $player->{hp} < 1;
        
        # Save player state BEFORE room entry to ensure changes persist
        save_player($player);
        
        # Properly handle room entry
        if (defined &photonmud_enter_room) {
            photonmud_enter_room($player, $new_room, $old_room);
        }
        
        # Save player state AGAIN after room entry to ensure changes persist
        save_player($player);
        
        # Ensure the global player variable is updated if this is the current player
        if ($::player && $::player->{name} eq $player->{name}) {
            $::player->{hp} = $player->{hp};
            $::player->{room} = $new_room;
            $::player->{in_combat} = 0;
        }
        
        # Force update the session for this player if they're still online
        if (player_online($player->{name}) && defined &update_player_session) {
            update_player_session($player->{name}, { 
                hp => $player->{hp},
                room => $new_room,
                in_combat => 0
            });
        }
    }
    
    # Reset death flag after a short delay to allow for future deaths
    my $player_name = $player->{name};
    if (defined &schedule_event) {
        schedule_event(30, sub {
            my $p = load_player($player_name);
            if ($p) {
                delete $p->{_death_handled};
                save_player($p);
            }
        });
    }
    
    photonmud_debug("handle_player_death: Completed death handling for $player->{name}");
    
    return 1;  # Return success value
}

# Helper function for AI combat turn processing
sub ai_combat_turn {
    my ($actor, $meta, $actor_key, $opponent_key) = @_;
    my $actor_state = $meta->{players}{$actor_key};
    my $opp_state = $meta->{players}{$opponent_key};

    # --- Strategic Decision Making ---
    my $action;
    my $hp_ratio = $actor_state->{hp} / ($actor_state->{max_hp} // 1);
    my $opp_hp_ratio = $opp_state->{hp} / ($opp_state->{max_hp} // 1);
    
    # 1. Check if opponent is already defeated
    if ($opp_state->{hp} <= 0) {
        my $msg = "$actor_state->{name} holds position as opponent is defeated.";
        push @{$meta->{log}}, {
            actor => $actor_state->{name},
            msg => $msg,
            time => time(),
            displayed_to => {},
            immediate => 1
        };
        return "idle";
    }

    # 2. Emergency Actions (Low HP)
    if ($hp_ratio < 0.25) {
        my $flee_chance = 0.3 + (0.3 * (1 - $hp_ratio)); # Up to 60% flee chance when very low
        
        if (rand() < $flee_chance) {
            my $dex_mod = int(($actor_state->{stats}{dex} // 10) / 2) - 5;
            my $flee_roll = int(rand(20)) + 1 + $dex_mod;
            
            if ($flee_roll >= 15) {
                my $msg = "$actor_state->{name} flees from combat!";
                push @{$meta->{log}}, {
                    actor => $actor_state->{name},
                    msg => $msg,
                    time => time(),
                    displayed_to => {},
                    immediate => 1
                };
                $actor_state->{fled} = 1;
                return "run";
            }
        }
        
        # Failed flee or chose not to - use defensive action
        $action = "guard";
        
        # If opponent is also low, might risk an attack
        if ($opp_hp_ratio < 0.3 && rand() < 0.4) {
            $action = "attack";
        }
    }

    # 3. Tactical Decisions
    unless ($action) {
        # Consider current combat state
        if ($hp_ratio < 0.5) {
            # Wounded - mix defensive and offensive actions
            my @defensive = (
                ("dodge") x 3,    # Most reliable defense
                ("parry") x 2,    # Good vs single attacks
                ("guard") x 2,    # Consistent damage reduction
                ("shield") x 2,   # Strong defense
                "counter"         # Risky but can deal damage
            );
            
            my @offensive = (
                ("attack") x 4,   # Basic reliable attack
                ("thrust") x 2,   # Precision attack
                "feint"          # Harder to defend against
            );
            
            # More defensive when wounded
            $action = (rand() < 0.7) ? 
                     $defensive[rand @defensive] :
                     $offensive[rand @offensive];
                     
            # If opponent is very wounded, be more aggressive
            if ($opp_hp_ratio < 0.3) {
                $action = $offensive[rand @offensive];
            }
        }
        else {
            # Healthy - favor aggressive actions with tactical variety
            my @actions = (
                ("attack") x 6,     # Basic attack (highest weight)
                ("thrust") x 3,     # Precision attack (+2 hit)
                ("charge") x 2,     # Aggressive (-2 hit, +1 die)
                ("feint") x 3,      # Tactical (+4 hit)
                ("lunge") x 2,      # Power attack (-2 hit, +4 damage)
                ("pummel") x 2,     # Multiple hits
                "counter"           # Defensive option
            );
            
            # Add defensive options if opponent is strong
            if ($opp_hp_ratio > 0.7) {
                push @actions, ("dodge", "parry", "guard");
            }
            
            $action = $actions[rand @actions];
        }
    }

    # --- Process Combat Action ---
    if ($action =~ /^(dodge|parry|guard|shield|counter)$/) {
        # Set defensive stance
        $actor_state->{"_${action}_next"} = 1;
        
        # Create appropriate message based on action with more descriptive text
        my $msg = "$actor_state->{name} ";
        if ($action eq "dodge") {
            $msg .= "crouches low and prepares to evade incoming attacks!";
        } elsif ($action eq "parry") {
            $msg .= "raises their weapon defensively, ready to deflect strikes!";
        } elsif ($action eq "guard") {
            $msg .= "assumes a defensive stance, protecting vital areas!";
        } elsif ($action eq "shield") {
            $msg .= "raises their shield high, preparing to block attacks!";
        } elsif ($action eq "counter") {
            $msg .= "watches carefully, ready to strike back at the first opening!";
        }
        
        # Add to combat log with immediate flag
        push @{$meta->{log}}, {
            actor => $actor_state->{name},
            msg => $msg,
            time => time(),
            displayed_to => {},
            immediate => 1
        };
        
        return "defend";
    }
    elsif ($action =~ /^(attack|thrust|charge|feint|lunge|pummel)$/) {
        # Get base stats
        my $str = $actor_state->{stats}{str} // 10;
        my $dex = $actor_state->{stats}{dex} // 10;
        my $str_mod = int(($str - 10) / 2);
        my $dex_mod = int(($dex - 10) / 2);
        
        # Get base weapon damage
        my ($num_dice, $dice_type, $flat_bonus) = get_monster_damage_dice($actor);
        
        # Calculate attack modifiers
        my $attack_mod = $str_mod;
        my $damage_mod = $str_mod;
        
        # Action-specific modifiers
        if ($action eq "thrust") {
            $attack_mod += 2;  # Better accuracy
        }
        elsif ($action eq "charge") {
            $attack_mod -= 2;  # Less accurate but more damage
            $num_dice++;
        }
        elsif ($action eq "feint") {
            $attack_mod += 4;  # Much better accuracy
            $damage_mod -= 1;  # Slightly less damage
        }
        elsif ($action eq "lunge") {
            $attack_mod -= 2;  # Less accurate
            $flat_bonus += 4;  # More damage
        }
        elsif ($action eq "pummel") {
            $num_dice += 1;    # More hits
            $dice_type = max(4, $dice_type - 2);  # Smaller dice
        }

        # Apply proficiency bonus
        my $prof_bonus = int(($actor_state->{level} // 1) / 4) + 2;
        my $attack_roll = int(rand(20)) + 1;
        my $is_critical = ($attack_roll == 20);
        $attack_roll += $attack_mod + $prof_bonus;

        # Calculate target's defenses
        my $target_dex_mod = int(($opp_state->{stats}{dex} // 10) / 2) - 5;
        my $target_ac = 10 + $target_dex_mod;
        
        # Add armor bonus if target has armor
        if ($opp_state->{equipped} && $opp_state->{equipped}{armor}) {
            my $armor_bonus = 2; # Base armor bonus
            $target_ac += $armor_bonus;
        }

        # Check if attack hits
        if ($attack_roll < $target_ac && !$is_critical) {
            # Create detailed miss message based on action type
            my $miss_msg = "$actor_state->{name} ";
            if ($action eq "attack") {
                $miss_msg .= "swings wildly but misses $opp_state->{name}!";
            } elsif ($action eq "thrust") {
                $miss_msg .= "thrusts forward but $opp_state->{name} sidesteps the attack!";
            } elsif ($action eq "charge") {
                $miss_msg .= "charges forward but $opp_state->{name} dodges out of the way!";
            } elsif ($action eq "feint") {
                $miss_msg .= "attempts a deceptive strike but $opp_state->{name} sees through it!";
            } elsif ($action eq "lunge") {
                $miss_msg .= "lunges powerfully but overextends, missing $opp_state->{name}!";
            } elsif ($action eq "pummel") {
                $miss_msg .= "unleashes a flurry of strikes but none connect with $opp_state->{name}!";
            } else {
                $miss_msg .= "attacks $opp_state->{name} but misses!";
            }
            
            push @{$meta->{log}}, {
                actor => $actor_state->{name},
                msg => $miss_msg,
                time => time(),
                displayed_to => {},
                immediate => 1
            };
            return "attack";
        }

        # Calculate damage
        my $damage = 0;
        my $num_rolls = $is_critical ? $num_dice * 2 : $num_dice;
        
        for (my $i = 0; $i < $num_rolls; $i++) {
            $damage += 1 + int(rand($dice_type));
        }
        
        # Add modifiers
        $damage += $flat_bonus + $damage_mod;
        
        # Add mounted combat bonus
        my $mount_bonus = get_mounted_combat_bonus($actor_state);
        $damage += $mount_bonus;
        
        $damage = max(1, $damage); # Minimum 1 damage

        # Apply defensive effects
        $damage = resolve_defense_effects($actor_state, $opp_state, $damage, $actor_state->{room});
        
        # Apply final damage
        $opp_state->{hp} -= $damage;
        $opp_state->{hp} = max(0, $opp_state->{hp}); # Don't allow negative HP

        # Create detailed combat message based on action type
        my $msg = "$actor_state->{name} ";
        if ($action eq "attack") {
            $msg .= "strikes $opp_state->{name}";
        } elsif ($action eq "thrust") {
            $msg .= "delivers a precise thrust to $opp_state->{name}";
        } elsif ($action eq "charge") {
            $msg .= "charges fiercely into $opp_state->{name}";
        } elsif ($action eq "feint") {
            $msg .= "feints skillfully and then strikes $opp_state->{name}";
        } elsif ($action eq "lunge") {
            $msg .= "lunges powerfully at $opp_state->{name}";
        } elsif ($action eq "pummel") {
            $msg .= "unleashes a devastating flurry against $opp_state->{name}";
        } else {
            $msg .= "attacks $opp_state->{name}";
        }
        
        # Add mount information if mounted
        my $mount_msg = "";
        if ($mount_bonus > 0 && $actor_state->{mounted}) {
            $mount_msg = " (mounted on " . $actor_state->{mounted}{name} . ")";
            $msg = "$actor_state->{name}$mount_msg " . 
                  ($action eq "attack" ? "strikes" : 
                   $action eq "thrust" ? "delivers a precise thrust to" :
                   $action eq "charge" ? "charges fiercely into" :
                   $action eq "feint" ? "feints skillfully and then strikes" :
                   $action eq "lunge" ? "lunges powerfully at" :
                   $action eq "pummel" ? "unleashes a devastating flurry against" :
                   "attacks") . " $opp_state->{name}";
        }
        
        # Add damage and critical information
        $msg .= ", dealing $damage damage";
        if ($is_critical) {
            $msg .= " with a CRITICAL HIT";
        }
        $msg .= "!";
        
        # Add defeat message if opponent died
        if ($opp_state->{hp} <= 0) {
            $msg .= " $opp_state->{name} has been defeated!";
            
            # Update combat state
            $meta->{status} = "completed";
            $meta->{end_reason} = "victory";
            $meta->{winner} = $actor_key;
            $meta->{victory_announced} = 1;
        }

        # Add to combat log with immediate flag
        push @{$meta->{log}}, {
            actor => $actor_state->{name},
            msg => $msg,
            time => time(),
            displayed_to => {},
            immediate => 1
        };

        return "attack";
    }

    # Default fallback - basic attack
    my $msg = "$actor_state->{name} prepares for combat.";
    push @{$meta->{log}}, {
        actor => $actor_state->{name},
        msg => $msg,
        time => time(),
        displayed_to => {},
        immediate => 1
    };
    
    return "attack";
}

# Function to handle player combat turns with D&D-style mechanics
sub player_combat_turn {
    my ($actor, $meta, $actor_key, $opponent_key, $file) = @_;
    
    # Safety check - ensure actor and metadata are valid
    unless ($actor && ref($actor) eq 'HASH' && 
            $meta && ref($meta) eq 'HASH' && 
            $meta->{players} && ref($meta->{players}) eq 'HASH') {
        combat_debug("[ERROR] player_combat_turn: Invalid actor or meta parameters");
        return "error";
    }
    
    my $actor_state = $meta->{players}{$actor_key};
    my $opp_state = $meta->{players}{$opponent_key};
    
    # Safety check - ensure both states exist
    unless ($actor_state && ref($actor_state) eq 'HASH' && 
            $opp_state && ref($opp_state) eq 'HASH') {
        combat_debug("[ERROR] player_combat_turn: Invalid actor_state or opp_state");
        return "error";
    }
    
    # Display combat status
    writeline($config{'systemcolor'}."--- Combat Status ---".$config{'themecolor'}, 1);
    writeline($config{'systemcolor'}."You are in PvP combat with $opp_state->{name}!".$config{'themecolor'}, 1);
    writeline(sprintf("%s%s: %d/%d HP%s", 
        $config{'usercolor'}, $actor->{name}, $actor_state->{hp}, $actor_state->{max_hp}, $config{'themecolor'}), 1);
    writeline(sprintf("%s%s: %d/%d HP%s", 
        $config{'datacolor'}, $opp_state->{name}, $opp_state->{hp}, $opp_state->{max_hp}, $config{'themecolor'}), 1);
    
    # Show combat actions
    writeline($config{'promptcolor'}."Combat Actions:".$config{'themecolor'}, 1);
    writeline($config{'promptcolor'}."[A] Attack      [D] Dodge       [R] Run".$config{'themecolor'}, 1);
    writeline($config{'promptcolor'}."[C] Charm       [P] Parry       [Q] Punch".$config{'themecolor'}, 1);
    writeline($config{'promptcolor'}."[B] Beguile     [T] Thrust      [E] Beat".$config{'themecolor'}, 1);
    writeline($config{'promptcolor'}."[S] Shield      [H] Charge      [U] Pummel".$config{'themecolor'}, 1);
    writeline($config{'promptcolor'}."[G] Guard       [O] Counter     [F] Feint".$config{'themecolor'}, 1);
    writeline($config{'promptcolor'}."[L] Lunge       [M] Talk        ".$config{'themecolor'}, 1);
    
    # Get player's action
    writeline($config{'promptcolor'}."Choose action: ".$config{'themecolor'}, 0);
    my $action_key = uc(mud_key("A"));
    
    # Map key to action type
    my $action = "attack";  # Default
    my $action_name = "Attack";
    
    if ($action_key eq "D") {
        $action = "dodge";
        $action_name = "Dodge";
        $actor_state->{_dodge_next} = 1;
    } elsif ($action_key eq "R") {
        $action = "run";
        $action_name = "Run";
    } elsif ($action_key eq "C") {
        $action = "charm";
        $action_name = "Charm";
    } elsif ($action_key eq "P") {
        $action = "parry";
        $action_name = "Parry";
        $actor_state->{_parry_next} = 1;
    } elsif ($action_key eq "Q") {
        $action = "punch";
        $action_name = "Punch";
    } elsif ($action_key eq "B") {
        $action = "beguile";
        $action_name = "Beguile";
    } elsif ($action_key eq "T") {
        $action = "thrust";
        $action_name = "Thrust";
    } elsif ($action_key eq "E") {
        $action = "beat";
        $action_name = "Beat";
    } elsif ($action_key eq "S") {
        $action = "shield";
        $action_name = "Shield";
        $actor_state->{_shield_next} = 1;
    } elsif ($action_key eq "H") {
        $action = "charge";
        $action_name = "Charge";
    } elsif ($action_key eq "U") {
        $action = "pummel";
        $action_name = "Pummel";
    } elsif ($action_key eq "G") {
        $action = "guard";
        $action_name = "Guard";
        $actor_state->{_guard_next} = 1;
    } elsif ($action_key eq "O") {
        $action = "counter";
        $action_name = "Counter";
        $actor_state->{_counter_next} = 1;
    } elsif ($action_key eq "F") {
        $action = "feint";
        $action_name = "Feint";
    } elsif ($action_key eq "L") {
        $action = "lunge";
        $action_name = "Lunge";
    } elsif ($action_key eq "M") {
        $action = "talk";
        $action_name = "Talk";
    }
    
    # Echo action for player feedback
    writeline($config{'systemcolor'}."[Action: $action_name]".$config{'themecolor'}, 1);
    
    # Process action based on type
    if ($action eq "run") {
        # Try to flee - DC 15 Dexterity check
        my $dex = $actor_state->{stats}{dex} // 10;
        my $dex_mod = int(($dex - 10) / 2);
        my $flee_roll = int(rand(20)) + 1 + $dex_mod;
        
        if ($flee_roll >= 15) {
            # Successfully fled
            $meta->{status} = "completed";
            $meta->{end_reason} = "fled";
            $meta->{winner} = $opponent_key;
            
            # Add to log and show to player
            my $msg = "$actor->{name} successfully flees from combat!";
            push @{$meta->{log}}, { 
                actor => $actor->{name}, 
                msg => $msg,
                time => time(),
                displayed_to => {}
            };
            writeline($config{'systemcolor'}."You successfully flee from combat!".$config{'themecolor'}, 1);
            return "run";
        } else {
            # Failed flee attempt
            my $msg = "$actor->{name} tries to flee but fails!";
            push @{$meta->{log}}, { 
                actor => $actor->{name}, 
                msg => $msg,
                time => time(),
                displayed_to => {}
            };
            writeline($config{'errorcolor'}."You try to flee but fail!".$config{'themecolor'}, 1);
            return "attack"; # Counts as your action, turn ends
        }
    } 
    elsif ($action eq "talk") {
        writeline($config{'promptcolor'}."Enter message: ".$config{'themecolor'}, 0);
        my $message = mud_getline();
        
        if ($message) {
            # Add to log and show to player
            my $msg = "$actor->{name} says: $message";
            push @{$meta->{log}}, { 
                actor => $actor->{name}, 
                msg => $msg,
                time => time(),
                displayed_to => {}
            };
            writeline($config{'systemcolor'}."You say: $message".$config{'themecolor'}, 1);
        }
        
        # Save changes to meta file immediately
        eval { lock_store($meta, $file) } if $file;
        
        # Talking is a free action in D&D, doesn't end turn
        return "talk";
    }
    elsif ($action =~ /^(dodge|parry|guard|counter|shield)$/) {
        # Defensive actions - set up for next opponent's turn
        my $def_msg = "$actor->{name} prepares to $action!";
        
        # Add to log and show to player
        push @{$meta->{log}}, { 
            actor => $actor->{name}, 
            msg => $def_msg,
            time => time(),
            displayed_to => {}
        };
        writeline($config{'systemcolor'}."You prepare to $action!".$config{'themecolor'}, 1);
        
        # Save changes to meta file immediately
        eval { lock_store($meta, $file) } if $file;
        
        # Defensive stance ends your turn
        return "attack";
    }
    elsif ($action eq "charm" || $action eq "beguile") {
        # Spell-like abilities - DC 15 Charisma check, modified by class
        my $cha = $actor_state->{stats}{cha} // 10;
        my $cha_mod = int(($cha - 10) / 2);
        my $class_bonus = 0;
        
        # Class bonuses
        if ($actor->{class}) {
            if ($actor->{class} eq 'Bard') {
                $class_bonus = int($actor->{level} / 2) + 2;
            } elsif ($actor->{class} =~ /^(MagicUser|Druid|Cleric)$/) {
                $class_bonus = int($actor->{level} / 3) + 1;
            }
        }
        
        # Minimum ability for non-casters (need Cha 12+)
        unless ($class_bonus > 0 || $cha >= 12) {
            writeline($config{'errorcolor'}."You lack the charisma or magical training to use this ability!".$config{'themecolor'}, 1);
            return "failed";  # Failed attempt, but doesn't end turn
        }
        
        # Roll for success - DC 15
        my $spell_roll = int(rand(20)) + 1 + $cha_mod + $class_bonus;
        
        if ($spell_roll >= 15) {
            # Success - opponent has disadvantage next turn (D&D mechanic)
            $opp_state->{disadvantage_next} = 1;
            
            # For beguile, also skip turn on a high roll
            if ($action eq "beguile" && $spell_roll >= 18) {
                $opp_state->{skip_turn} = 1;
            }
            
            # Create effect message
            my $effect_msg = $action eq "charm" 
                ? "$actor->{name} charms $opp_state->{name}, causing confusion!"
                : "$actor->{name} beguiles $opp_state->{name}, who is momentarily distracted!";
            
            # Add to log and show to player
            push @{$meta->{log}}, { 
                actor => $actor->{name}, 
                msg => $effect_msg,
                time => time(),
                displayed_to => {}
            };
            writeline($config{'systemcolor'}.$effect_msg.$config{'themecolor'}, 1);
        } else {
            # Failed spell attempt
            my $fail_msg = "$actor->{name} attempts to $action $opp_state->{name}, but fails!";
            
            # Add to log and show to player
            push @{$meta->{log}}, { 
                actor => $actor->{name}, 
                msg => $fail_msg,
                time => time(),
                displayed_to => {}
            };
            writeline($config{'errorcolor'}."Your magical attempt fails!".$config{'themecolor'}, 1);
        }
        
        # Save changes to meta file immediately
        eval { lock_store($meta, $file) } if $file;
        
        # Special abilities end your turn
        return "attack";
    }
    else {
        # All physical attacks (attack, punch, thrust, beat, charge, pummel, lunge, feint)
        # Calculate base weapon damage
        my ($num_dice, $dice_type) = get_weapon_damage_dice($actor);
        my $weapon_bonus = get_equipped_bonus($actor, "weapon");
        
        # Calculate ability modifiers (D&D style)
        my $str = $actor_state->{stats}{str} // 10;
        my $dex = $actor_state->{stats}{dex} // 10;
        my $str_mod = int(($str - 10) / 2);
        my $dex_mod = int(($dex - 10) / 2);
        
        # Determine attack stat (Str for melee, Dex for finesse weapons)
        my $is_finesse_weapon = 0;
        if ($actor->{equipped} && $actor->{equipped}{weapon}) {
            my $weapon_name = lc($actor->{equipped}{weapon}{name} // '');
            $is_finesse_weapon = ($weapon_name =~ /dagger|rapier|shortsword|scimitar|bow|crossbow/);
        }
        
        # Use the better stat for finesse weapons, otherwise Str for melee
        my $attack_mod = $is_finesse_weapon ? 
            ($dex_mod > $str_mod ? $dex_mod : $str_mod) : $str_mod;
        
        # Special action modifiers (D&D-inspired)
        if ($action eq "thrust") {
            # Precision attack (+2 to hit, normal damage)
            $attack_mod += 2;
        } elsif ($action eq "charge") {
            # All-out attack (-2 to hit, +1 damage die)
            $attack_mod -= 2;
            $num_dice += 1;
        } elsif ($action eq "pummel") {
            # Multiple weak hits (more dice but smaller, like two-weapon fighting)
            $dice_type = max(4, $dice_type - 2); # Minimum d4
            $num_dice += 1;
        } elsif ($action eq "lunge") {
            # Risky attack (+4 damage, -2 to hit)
            $attack_mod -= 2;
            $weapon_bonus += 4;
        } elsif ($action eq "feint") {
            # Feint gives advantage (roll twice, take better roll)
            # Simulate by adding +4 (similar to D&D 5e advantage)
            $attack_mod += 4;
        } elsif ($action eq "beat") {
            # Beat down attack (normal hit, +2 damage)
            $weapon_bonus += 2;
        } elsif ($action eq "punch") {
            # Unarmed strike (1d4 damage)
            $num_dice = 1;
            $dice_type = 4;
            $weapon_bonus = $str_mod;
        }
        
        # Roll for attack (D&D style with proficiency bonus based on level)
        my $prof_bonus = int(($actor_state->{level} // 1) / 4) + 2; # D&D 5e proficiency
        my $attack_roll_1 = int(rand(20)) + 1;
        my $attack_roll_2 = int(rand(20)) + 1;
        
        # Apply disadvantage if affected by status
        my $attack_roll = $actor_state->{disadvantage_next} ?
            min($attack_roll_1, $attack_roll_2) : $attack_roll_1;
        $actor_state->{disadvantage_next} = 0; # Clear status after use
        
        # Calculate total attack roll
        $attack_roll += $attack_mod + $prof_bonus;
        
        # Calculate target's AC (D&D style)
        my $target_dex_mod = int(($opp_state->{stats}{dex} // 10) / 2) - 5;
        my $base_ac = 10; # Base AC
        my $armor_bonus = 0; # Additional armor
        
        # Add armor bonus if target has armor
        if ($opp_state->{equipped} && $opp_state->{equipped}{armor}) {
            my $armor_item = $opp_state->{equipped}{armor};
            my $armor_plus = 0;
            
            if ($armor_item->{idx}) {
                my $treas = read_treasure_record($armor_item->{idx});
                $armor_plus = $treas->{plus} // 0;
            }
            
            $armor_bonus = $armor_plus + 2; # Basic armor bonus
        }
        
        my $target_ac = $base_ac + $target_dex_mod + $armor_bonus;
        
        # Critical hit on natural 20
        my $is_critical = ($attack_roll_1 == 20);
        
        # Check if attack hits
        if ($attack_roll < $target_ac && !$is_critical) {
            # Attack missed
            my $miss_msg = "$actor->{name} misses $opp_state->{name}!";
            push @{$meta->{log}}, { 
                actor => $actor->{name}, 
                msg => $miss_msg,
                time => time(),
                displayed_to => {}
            };
            writeline($config{'systemcolor'}."Your attack misses!".$config{'themecolor'}, 1);
        } else {
            # Calculate damage
            my $damage = 0;
            
            # Roll damage dice
            for (my $i = 0; $i < $num_dice; $i++) {
                $damage += 1 + int(rand($dice_type));
            }
            
            # Double dice on critical hit (D&D 5e rules)
            if ($is_critical) {
                my $crit_damage = 0;
                for (my $i = 0; $i < $num_dice; $i++) {
                    $crit_damage += 1 + int(rand($dice_type));
                }
                $damage += $crit_damage;
            }
            
            # Add bonuses
            $damage += $weapon_bonus;
            $damage += $attack_mod; # Add ability modifier to damage
            
            # Add mounted combat bonus
            my $mount_bonus = get_mounted_combat_bonus($actor_state);
            $damage += $mount_bonus;
            
            $damage = max(1, $damage); # Minimum 1 damage on hit
            
            # Apply defensive effects
            if ($opp_state->{_dodge_next}) {
                # Dodge gives disadvantage to attacker (simulated with 50% damage reduction)
                $damage = int($damage / 2);
                push @{$meta->{log}}, { 
                    actor => $opp_state->{name}, 
                    msg => "$opp_state->{name} partially dodges the attack!",
                    time => time(),
                    displayed_to => {}
                };
                $opp_state->{_dodge_next} = 0;
            }
            
            if ($opp_state->{_parry_next}) {
                # Parry reduces damage
                $damage = int($damage * 0.7);
                $damage = max(1, $damage);
                push @{$meta->{log}}, { 
                    actor => $opp_state->{name}, 
                    msg => "$opp_state->{name} parries, reducing the damage!",
                    time => time(),
                    displayed_to => {}
                };
                $opp_state->{_parry_next} = 0;
            }
            
            if ($opp_state->{_guard_next}) {
                # Guard stance provides flat damage reduction
                $damage -= 3;
                $damage = max(0, $damage);
                push @{$meta->{log}}, { 
                    actor => $opp_state->{name}, 
                    msg => "$opp_state->{name} guards against the attack!",
                    time => time(),
                    displayed_to => {}
                };
                $opp_state->{_guard_next} = 0;
            }
            
            if ($opp_state->{_shield_next}) {
                # Shield provides better protection than parry
                $damage = int($damage * 0.5);
                $damage = max(1, $damage);
                push @{$meta->{log}}, { 
                    actor => $opp_state->{name}, 
                    msg => "$opp_state->{name} blocks with a shield!",
                    time => time(),
                    displayed_to => {}
                };
                $opp_state->{_shield_next} = 0;
            }
            
            if ($opp_state->{_counter_next}) {
                # Counter reflects partial damage back
                my $reflected = int($damage * 0.3);
                if ($reflected > 0) {
                    $actor_state->{hp} -= $reflected;
                    push @{$meta->{log}}, { 
                        actor => $opp_state->{name}, 
                        msg => "$opp_state->{name} counters and reflects $reflected damage!",
                        time => time(),
                        displayed_to => {}
                    };
                }
                $opp_state->{_counter_next} = 0;
            }
            
            # Apply damage to opponent
            $opp_state->{hp} -= $damage;
            
            # Sync HP changes to player objects immediately
            if (!$actor->{is_monster}) {
                $actor->{hp} = $actor_state->{hp};
                $actor->{max_hp} = $actor_state->{max_hp} // $actor->{max_hp};
                
                # Update global player if this is the current player
                if ($::player && $::player->{name} eq $actor->{name}) {
                    $::player->{hp} = $actor_state->{hp};
                    $::player->{max_hp} = $actor_state->{max_hp} // $::player->{max_hp};
                }
                
                # Save updated player state
                save_player($actor);
            }
            
            # Create attack message with proper verb
            my $msg = "$actor->{name} ";
            
            # Add mount information if mounted
            my $mount_msg = "";
            if ($mount_bonus > 0 && $actor_state->{mounted}) {
                $mount_msg = " (mounted on " . $actor_state->{mounted}{name} . ")";
                $msg = "$actor->{name}$mount_msg ";
            }
            
            if ($action eq "attack") {
                $msg .= "attacks";
            } elsif ($action eq "punch") {
                $msg .= "punches";
            } elsif ($action eq "thrust") {
                $msg .= "thrusts at";
            } elsif ($action eq "beat") {
                $msg .= "beats down on";
            } elsif ($action eq "charge") {
                $msg .= "charges";
            } elsif ($action eq "pummel") {
                $msg .= "pummels";
            } elsif ($action eq "lunge") {
                $msg .= "lunges at";
            } elsif ($action eq "feint") {
                $msg .= "feints and strikes";
            }
            
            # Add critical hit message
            if ($is_critical) {
                $msg .= " with a CRITICAL HIT";
            }
            
            $msg .= " $opp_state->{name} for $damage damage!";
            
            # Add weapon info
            if ($actor->{equipped} && $actor->{equipped}{weapon}) {
                my $weapon_name = $actor->{equipped}{weapon}{name} // "weapon";
                $msg .= " (using $weapon_name)";
            }
            
            # Add mount bonus info if applicable
            if ($mount_bonus > 0) {
                $msg .= " [Mount bonus: +$mount_bonus]";
            }
            
            # Check if opponent died - THIS IS THE CRITICAL SECTION
            if ($opp_state->{hp} <= 0) {
                $opp_state->{hp} = 0;
                $meta->{status} = "completed";
                $meta->{end_reason} = "victory";
                $meta->{winner} = $actor_key;
                $meta->{victory_announced} = 1;  # Prevent duplicate victory/XP handling
                
                # Flag opponent as dead immediately to prevent multiple death handling
                $opp_state->{done} = 1;
                $opp_state->{death_time} = time();
                
                # Add the single defeat message to the attack message
                $msg .= " You have defeated $opp_state->{name} in combat!";
                
                # Add the complete message to log ONCE
                push @{$meta->{log}}, { 
                    actor => $actor->{name}, 
                    msg => $msg,
                    time => time(),
                    displayed_to => {}
                };
                
                # Show the complete message to player ONCE
                writeline($config{'systemcolor'}.$msg.$config{'themecolor'}, 1);
                
                # Award XP using unified calculation (follows documented rules)
                if (!$actor->{is_monster}) {
                    my $xp_gain = calculate_xp_gain($actor, $opp_state);
                    
                    # Add XP to player
                    $actor->{experience} = ($actor->{experience} // 0) + $xp_gain;
                    
                    # Show XP message separately after victory message
                    writeline($config{'systemcolor'}."You gain $xp_gain experience!".$config{'themecolor'}, 1);
                    
                    # Check for level up
                    check_level_up($actor);
                    
                    # Save player state to persist XP gain
                    save_player($actor);
                    
                    # Log XP gain separately (no duplicate message)
                    push @{$meta->{log}}, { 
                        actor => "system", 
                        msg => "$actor->{name} gains $xp_gain experience!",
                        time => time(),
                        displayed_to => {}
                    };
                }
            } else {
                # If opponent didn't die, just add regular attack message to log
                push @{$meta->{log}}, { 
                    actor => $actor->{name}, 
                    msg => $msg,
                    time => time(),
                    displayed_to => {}
                };
                
                # Show message to player
                writeline($config{'systemcolor'}.$msg.$config{'themecolor'}, 1);
            }
        }
        
        # Save changes to meta file immediately
        eval { lock_store($meta, $file) } if $file;
        
        # Make sure we always return "attack" to end the turn for all attack actions
        return "attack";
    }
}

sub calculate_monster_xp {
    my ($monster_state) = @_;
    
    # Base XP based on monster level
    my $level = $monster_state->{level} // 1;
    my $base_xp = $level * 25;
    
    # Minimum XP award
    $base_xp = 35 if $base_xp < 35;
    
    return $base_xp;
}

sub monster_in_combat {
    my ($monster_id) = @_;
    return 0 unless $config{monster_ai_enabled};
    
    # Check for a combat pointer file
    my $pointer_file = "$config{transient}/monster_$monster_id.combat";
    return 1 if -e $pointer_file;
    
    # Check for active combat locks
    my $data_dir = $config{transient};
    opendir(my $dh, $data_dir) or return 0;
    while (my $file = readdir($dh)) {
        if ($file =~ /^monster_player_combat_lock_${monster_id}_/) {
            my $lock_file = "$data_dir/$file";
            # Check if lock is still valid
            open(my $fh, "<", $lock_file);
            my $expiry = <$fh>;
            close($fh);
            
            if (time() <= $expiry) {
                closedir($dh);
                return 1;
            } else {
                # Clean up expired lock
                unlink $lock_file;
            }
        }
    }
    closedir($dh);
    
    return 0;
}

sub write_pointer_file {
    my ($pointer_file, $combat_file, $creator_id) = @_;
    my $data = {
        meta    => $combat_file,
        creator => $creator_id,
        time    => time,
        host    => `hostname` =~ /(\S+)/ ? $1 : '',
        pid     => $$,
    };
    open(my $fh, '>', $pointer_file) or do {
        combat_debug("write_pointer_file: ERROR - Cannot open $pointer_file: $!");
        die "Cannot open $pointer_file: $!";
    };
    print $fh encode_json($data);
    close($fh);
    combat_debug("[DEBUG] Wrote pointer file $pointer_file with combat file $combat_file (creator_id=$creator_id)");
    return 1;  # Return success
}

sub read_pointer_file {
    my ($pointer_file) = @_;
    return unless -e $pointer_file;
    open(my $fh, '<', $pointer_file) or return;
    local $/;
    my $json = <$fh>;
    close($fh);
    my $data = eval { decode_json($json) };
    return $data if $data && $data->{meta};
    return;
}

sub delete_pointer_file_if_creator {
    my ($pointer_file, $expected_creator) = @_;
    my $data = read_pointer_file($pointer_file);
    return unless $data && $data->{creator} && $data->{creator} eq $expected_creator;
    unlink $pointer_file;
    combat_debug("[DEBUG] Deleted pointer file $pointer_file (creator_id=$expected_creator)");
}

sub read_room_with_num {
    my ($roomid) = @_;
    my $room = read_room_record($roomid);
    $room->{roomnum} = $roomid if $room && ref($room) eq 'HASH' && !$room->{roomnum};
    ensure_room_exits($room);
    return $room;
}

sub ensure_room_exits {
    my ($room) = @_;
    return unless $room && ref($room) eq 'HASH';
    return if $room->{exits} && ref($room->{exits}) eq 'HASH' && %{$room->{exits}};
    my @dirs = qw(N S E W NE NW SE SW UP DOWN IN OUT);
    my %exits;
    if ($room->{direct} && length($room->{direct}) >= 48) {
        for my $i (0..11) {
            my $dir = $dirs[$i];
            my $bytes = substr($room->{direct}, $i*4, 4);
            my $val = unpack("f<", $bytes);
            my $ival = int($val + 0.0001);
            if ($ival > 0) {
                $exits{$dir} = $ival;
            }
        }
    }
    $room->{exits} = { %exits };
}

sub remove_monster_from_room {
    my ($mon, $room) = @_;
    return unless $room && $room->{roomnum};
    return unless $mon && (defined $mon->{id} || defined $mon->{name});
    
    my $perm_file = "$config{transient}/permmon_$room->{roomnum}.dat";
    unless (-e $perm_file) {
        combat_debug("[DEBUG] remove_monster_from_room: $perm_file does not exist for " . 
                 ($mon->{name} // "unnamed monster") . 
                 (defined $mon->{id} ? " (id $mon->{id})" : ""));
        return;
    }
    
    my $monsters = eval { retrieve($perm_file) };
    if ($@ || !$monsters || ref($monsters) ne 'ARRAY') {
        combat_debug("[DEBUG] remove_monster_from_room: Failed to retrieve $perm_file: $@");
        return;
    }
    
    # Safely build debug string with ID and name checks
    my $debug_str = "";
    foreach my $m (@$monsters) {
        $debug_str .= ($m->{name} // "unnamed") . 
                     (defined $m->{id} ? "($m->{id})" : "(no-id)") . ", ";
    }
    $debug_str =~ s/, $//; # Remove trailing comma
    
    combat_debug("[DEBUG] remove_monster_from_room: BEFORE: $debug_str");
    
    my $before = scalar(@$monsters);
    @$monsters = grep {
        !($mon->{id} && $_->{id} && $_->{id} eq $mon->{id}) &&
        !($mon->{name} && $_->{name} && $_->{name} eq $mon->{name} && !$mon->{id})
    } @$monsters;
    my $after = scalar(@$monsters);
    
    # Safely build after debug string
    $debug_str = "";
    foreach my $m (@$monsters) {
        $debug_str .= ($m->{name} // "unnamed") . 
                     (defined $m->{id} ? "($m->{id})" : "(no-id)") . ", ";
    }
    $debug_str =~ s/, $//; # Remove trailing comma
    
    combat_debug("[DEBUG] remove_monster_from_room: AFTER: $debug_str");
    
    if ($before == $after) {
        combat_debug("[DEBUG] remove_monster_from_room: " . 
                 ($mon->{name} // "unnamed monster") . 
                 (defined $mon->{id} ? " (id $mon->{id})" : "") . 
                 " not found in room $room->{roomnum}");
    } else {
        combat_debug("[DEBUG] remove_monster_from_room: Removed " . 
                 ($mon->{name} // "unnamed monster") . 
                 (defined $mon->{id} ? " (id $mon->{id})" : "") . 
                 " from room $room->{roomnum} ($before -> $after)");
    }
    
    eval { store($monsters, $perm_file); };
    if ($@) {
        combat_debug("[DEBUG] remove_monster_from_room: Failed to store updated list to $perm_file: $@");
    }
}

1;
