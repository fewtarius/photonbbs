#!/usr/bin/perl
# filepath: /Users/andrew/repositories/fewtarius/photonbbs/tools/photonmud-object-import
use strict;
use warnings;
use Encode qw(encode);

# CSV FORMAT:
# name|shortname|roomlink|invisible|jailtrap|doorlock|destination|permanent|hidden|closed|keyed|relocks|longdesc|fromhour|frommin|tohour|tomin|lightroom|lighttime|shortdesc|teleport|trap
# Each record is exactly 270 bytes

my $csvfile = shift || 'objects.csv';
my $outfile = shift || 'objects.dat';
my $reclen = 270; # 270 bytes record length
my $debug_mode = 0; # Set to 1 to see verbose debugging

open(my $infh, "<:encoding(utf8)", $csvfile) or die "Cannot open $csvfile: $!";
open(my $outfh, ">:raw", $outfile) or die "Cannot open $outfile: $!";

my $header = <$infh>;
chomp $header;
my $record_count = 0;

while (my $line = <$infh>) {
    chomp $line;
    next if $line =~ /^\s*$/ || $line =~ /^\/\//;
    my @row = parse_csv_line($line);
    $record_count++;

    # Defensive: pad missing fields
    $row[$_] //= 0 for (0..21);
    
    # Debug output if needed
    if ($debug_mode && $record_count == 1) {
        print "Processing record 1: $row[0]\n";
        print "Long description: $row[12]\n";
        print "Short description: $row[19]\n";
    }
    
    # Normalize numeric values for safety
    for my $i (2..21) {
        # Skip description fields
        next if $i == 12 || $i == 19;
        $row[$i] = 0 unless defined $row[$i] && $row[$i] =~ /^-?\d+(\.\d+)?$/;
    }

    # Pack fields according to object structure
    my $name        = pack_str($row[0], 30);
    my $shortname   = pack_str($row[1], 30);
    my $roomlink    = pack("f<", $row[2]);   # Little-endian float
    my $invisible   = pack("s<", $row[3]);   # Little-endian short
    my $jailtrap    = pack("s<", $row[4]);
    my $doorlock    = pack("s<", $row[5]);
    my $destination = pack("s<", $row[6]);
    my $permanent   = pack("s<", $row[7]);
    my $hidden      = pack("s<", $row[8]);
    my $closed      = pack("s<", $row[9]);
    my $keyed       = pack("s<", $row[10]);
    my $relocks     = pack("s<", $row[11]);
    my $longdesc    = pack_str($row[12], 80);  # String field
    my $fromhour    = pack("s<", $row[13]);
    my $frommin     = pack("s<", $row[14]);
    my $tohour      = pack("s<", $row[15]);
    my $tomin       = pack("s<", $row[16]);
    my $lightroom   = pack("s<", $row[17]);
    my $lighttime   = pack("s<", $row[18]);
    my $shortdesc   = pack_str($row[19], 80);  # String field
    my $teleport    = pack("f<", $row[20]);    # Little-endian float
    my $trap        = pack("s<", $row[21]);    # Little-endian short
    
    # Add padding - 10 bytes to reach 270 bytes total
    my $padding     = "\0" x 10;
    
    # Assemble record
    my $record = $name . $shortname . $roomlink . $invisible . $jailtrap . 
                 $doorlock . $destination . $permanent . $hidden . $closed . 
                 $keyed . $relocks . $longdesc . $fromhour . $frommin . 
                 $tohour . $tomin . $lightroom . $lighttime . $shortdesc .
                 $teleport . $trap . $padding;
    
    # Verify record length
    my $record_len = length($record);
    if ($record_len != $reclen) {
        print "WARNING: Record $record_count '$row[0]' has incorrect length: " . 
              $record_len . " bytes (expected $reclen)\n";
        
        # Fix the record length if needed
        if ($record_len < $reclen) {
            $record .= "\0" x ($reclen - $record_len);
        } else {
            $record = substr($record, 0, $reclen);
        }
    }
    
    # Debug - show record length of first record
    if ($debug_mode && $record_count == 1) {
        print "Record length: " . length($record) . " bytes\n";
        print "Name field size: " . length($name) . " bytes\n";
        print "Longdesc field size: " . length($longdesc) . " bytes\n";
        print "Shortdesc field size: " . length($shortdesc) . " bytes\n";
    }
    
    print $outfh $record;
}

close $infh;
close $outfh;
print "Import complete: $outfile ($record_count records)\n";

# Helper function to pack strings with null padding
sub pack_str {
    my ($str, $len) = @_;
    $str //= '';
    
    # Remove control characters
    $str =~ s/[\x00-\x1F]/ /g;
    
    # Convert to ASCII, replacing non-ASCII with spaces
    $str = encode('ascii', $str, sub { ' ' });
    
    # Ensure string doesn't exceed maximum length
    $str = substr($str, 0, $len);
    
    # Pad with nulls to ensure fixed length
    return $str . ("\0" x ($len - length($str)));
}

# Improved CSV parser that handles quoted fields properly
sub parse_csv_line {
    my ($line) = @_;
    my @fields;
    my $field = '';
    my $in_quotes = 0;
    
    # Handle simple case first (no quotes)
    if ($line !~ /"/) {
        return split(/\|/, $line);
    }
    
    # Handle quoted fields
    my @chars = split(//, $line);
    while (@chars) {
        my $c = shift @chars;
        if ($c eq '"') {
            # Check for escaped quotes
            if (@chars && $chars[0] eq '"') {
                $field .= '"';
                shift @chars;  # Skip the second quote
            } else {
                $in_quotes = !$in_quotes;
            }
        } elsif ($c eq '|' && !$in_quotes) {
            push @fields, $field;
            $field = '';
        } else {
            $field .= $c;
        }
    }
    push @fields, $field;
    return @fields;
}